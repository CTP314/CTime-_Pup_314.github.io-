<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[NEERC2016(NR)G] Gangsters in Central City]]></title>
    <url>%2F2020%2F10%2F13%2FNEERC2016-NR-G-Gangsters-in-Central-City%2F</url>
    <content type="text"><![CDATA[题目描述长期以来，中心市的水没有什么问题。城市的下水道系统是一种有根树结构：中央水库位于树的根节点，房屋位于树的叶节点。水从中央水库通过管道延树边流向每间房屋，所有房屋都可以使用到水。 突然，强盗们占领了一些房屋。作为市长，你非常忧虑并且想要驱逐这些强盗。所以，你打算停止向那些强盗占领的房屋供水。为此，你可能需要阻断下水道系统的某些管道。如果从水库到某房屋的路径中至少有一条被阻断的管道，那么该房屋将无法取水。你非常害怕强盗，所以你决定阻断最小数量的管道以免发生意外。同时，你关心居民，因此对于已确定数量的被阻断的管道，你希望最大限度减少没有强盗且无法取水的房屋的数量。 不幸的是，强盗们可能出现或消失在某些房屋里。所以在每次强盗位置改变后，你要询问科学家被阻断管道的最小数量和没有强盗且无法取水的房屋的最小数量。 输入格式第一行的输入包含两个整数 $n$ 和 $q$，下水道系统中节点的数量和强盗位置改变的次数 $(2\le n \le 10^5;1\le q \le 10^5)$。 第二行包含对下水道系统的描述：一个有 $n-1$ 个整数的序列 $p_2,p_3,\dots,p_n$，其中 $p_i$ 表示节点 $i$ 的父节点 $(1\le p_i &lt; i)$。中央水库位于 $1$ 号节点。 接下来 $q$ 行表示强盗位置的变化。每次改变为下面两种方式之一：$“+\ v”$ — 强盗占领了位于节点 $v$ 的房屋；$“-\ v”$ — 强盗离开了位于节点 $v$ 的房屋。 一开始，所有房屋都没有强盗。所有更改以正确的顺序进行：强盗不能占领它们已经占领的房屋，并且不能离开它们尚未占领的房屋。 输出格式输出应包含 $2q$ 个整数，每行有两个：$c_i$ — 被阻断的管道的最小数量以及 $h_i$ — 在阻断 $c_i$ 个管道的情况下没有强盗且无法取水的房屋的最小数量。 题解首先考虑最优化被阻断的管道个数，我们将叶节点按照所属 $1$ 子节点的子树分组，对于分别位于两组的一对占领节点，我们无法找到一条管道阻断后使这两个节点同时不可达，而对于存在占领节点的一组而言，设占领节点构成的集合为 $S$，我们总能找到一条管道切断根节点到 $S$ 的路径，具体的，这条管道就是 $\operatorname{LCA}(S)$ 到根节点路径上任意一条边。综上，$c$ 的值即为 $1$ 子节点含有被占领节点的子树个数。 之后最优化没有强盗且无法取水的房屋的最小数量。根据上述分析，每组相互独立，$h$ 为选择阻断的边 $(p_x,\ x)$ 中 $x$ 内叶节点的个数减去该组占领节点的个数，$x$ 取值为 $\operatorname{LCA}(S)$ 到根节点（不含根节点）的路径上的任意一点，$x$ 深度越浅，叶节点的个数就越多，因此 $x$ 取 $\operatorname{LCA}(S)$ 最优。 所以我们将问题转化为求 $\operatorname{LCA}(S)$。我们对树进行从 $1$ 节点开始的 DFS，记 $x$ 的 DFS 序为 $dfn_x$。存在下述性质： $$dfn_x=\min_{v\in S}dfn_v,dfn_y=\max_{v\in S}dfn_v\Rightarrow \operatorname{LCA}(S)=\operatorname{LCA}(x,y)$$ 证明：假设存在 $z$ 满足 $dfn_z\in(dfn_x,dfn_y)$ 使得 $\operatorname{LCA}(x,y)$ 不是 $z$ 的祖先，那么在 DFS 进行对 $\operatorname{LCA}(x,y)$ 的子树遍历时就不会访问到节点 $z$，所以 $dfn_z\notin(dfn_x,dfn_y)$，与假设矛盾，所以上述性质成立。 因此我们需要找到一个支持加入和删除，查询最值得数据结构。使用堆或平衡树即可在单次修改 $O(\log n)$ 得时间内维护。而 $\operatorname{LCA}$ 的计算，我们可以使用倍增，树链剖分，欧拉序等轻松得出。标程的复杂度为 $O((n+q)\log n)$。]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[WF2015L]Weather Report]]></title>
    <url>%2F2020%2F10%2F12%2FWF2015L-Weather-Report%2F</url>
    <content type="text"><![CDATA[题目描述你已被气候测量协会聘用，该协会是致力于追踪全球气候在长时间内变化趋势的科学组织。 当然，这绝非易事。 他们在世界各地部署了许多小型设备，旨在对当地天气状况进行定期测量。 这些是廉价的设备，它们的功能受到某些限制。每天，它们观测一次可能会发生于当天的四类标准天气中的一种：$Sunny$、$Cloudy$、$Rainy$ 或 $Frogs$。每进行 $n$ 次观测之后，将结果报告给主服务器进行分析。但是，大量的设备导致可用的通信带宽过载。协会需要你帮忙提出一种压缩这些报告序列位数的方法。对于一个特定的设备所处的位置，你可以假设该地每天的天气是一个独立的随机事件，并且你会得知上述四种天气发生的概率。设备的 $4^n$ 个可能报告中的每一个都必须编码为唯一的二进制序列，满足任意序列都不是其它任意序列的前缀（重要性质，若不满足则服务器将不知道每个序列何时结束）。你的目标是使用一种编码方式，以最大减少期望的传输位数。 输入格式第一行包含一个整数 $n$（$1\le n\le 20$） 代表每个设备进行的观测次数。 第二行包含四个正实数，$p_{\operatorname{sunny}}$，$p_{\operatorname{cloudy}}$，$p_{\operatorname{rainy}}$ 和 $p_{\operatorname{frogs}}$ 代表各自天气发生的概率。保证这 $4$ 个概率小数点后不超过 $6$ 位且和为 $1$。 输出格式输出报告编码的最小期望位数，要求误差不超过 $10^{-4}$。 题解设一个设备 $4^n$ 个可能报告构成的集合 $S$，报告 $x$ 的编码长度 $l_x$，出现概率为 $w_x$，则最后的期望： $$\sum_{x\in S}w_xl_x$$ 我们不难发现这个恰好满足哈夫曼编码的代价，启发我们使用哈夫曼树来解决这类问题。 首先一个很粗糙的想法就是暴力枚举 $4^n$ 个不同的报告序列再执行哈夫曼树算法的过程。但实际上我们注意到可以分成较少的组，满足每个组内的 $w_x$ 的值相同。这样我们就可以用二元组 $(c,w)$ 来表示一个大小为 $c$ 权值为 $w$ 的组。一开始，对于一个权值形如 $p_{\operatorname{sunny}}^ap_{\operatorname{cloudy}}^bp_{\operatorname{rainy}}^cp_{\operatorname{frogs}}^d(a+b+c+d=n)$ 的组而言，其大小为 $\binom{n}{a\ b\ c\ d}$。之后我们执行哈夫曼树算法的流程，每次取出堆顶的二元组 $(c,w)$ 并弹出，根据 $c$ 的大小进行讨论： 若 $c=1$ 则再次取出堆顶的二元组 $(c’,w’)$，将 $(1,w+w’)$ 和 $(c’-1,w)$ 重新加入堆中，答案加上 $w+w’$。 若 $c&gt;1$ 且 $c$ 为奇数，则将 $(\frac{c-1}{2},2w)$ 和 $(1,w)$ 加入堆中，答案加上 $2w$。 若 $c&gt;0$ 且 $c$ 为偶数，则将 $(\frac{c}{2},2w)$ 加入堆中，答案加上 $2w$。 重复上述步骤直到堆中只有一个二元组，且该二元组大小为 $1$。 时间复杂度限于笔者能力，不能给出一个精确的计算，只能给出一个粗略的上下界。首先一开始初始的二元组个数为 $O(n^3)$，上界即通过假定每个二元组中 $c$ 的 $\log n!$ 个二进制位都取 $1$ 得到，此时堆中最多会有 $O(n^3\log n!)$ 即 $O(n^4\log n)$ 个二元组，那么复杂度上界为 $O(n^4\log n\log(n^4\log n))$ 即 $O(n^4\log^2 n)$ 级别；下界为假设每次都恰好使当前方案数总和减半，那么复杂度为 $O(n^3\log 4^n\log n^4)$ 即 $O(n^4\log n)$ 级别，若有读者知道如何精确分析上下界欢迎与笔者讨论。 通过实际的检验，在题目数据范围内该算法的实际运行与上面估计有较好的拟合，但若出现概率为 $0$ 的情况（在数据范围外），则会呈现明显高于上文估计的上界的增长，这大概是由于上述分析忽略情况 $1$ 对 $c’$ 减 $1$ 的结果，但笔者尚未清楚其中的机理。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈夫曼编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝对做不完的IOI2021集训队作业]]></title>
    <url>%2F2020%2F10%2F12%2F%E7%BB%9D%E5%AF%B9%E5%81%9A%E4%B8%8D%E5%AE%8C%E7%9A%84IOI2021%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[希望不要丢人 试题一 完成情况 试题二 完成情况 试题三 完成情况 UC DG RB HC IB FJ GK UH QH EE DJ IH HL MI EJ MB UI ED AA BG ML CF TE QG PH UJ BB CI SD NG DK LD IJ NC BJ FK CH NJ RH QF BE KI AC PG HM PJ ID EG SI KC GI $\color{green}{√}$ OG CK DB QE GH NI OL KA MG SG NL KH QJ KG AB KD IL NF CM NE HD DH EC BM LC CD JI DL ME PE LI AI RJ SF II HG RE LL OA FB QD DA TC AE CB GF AG JC PA TH EH AJ TK EI UL AF SK BH RD OK FC JD OE TF FF DD CJ HK MJ FG GL AL FI IC QC MD OJ HI KK JH OB BK GJ KE CA IK LE RI LK PD JE LB HB BL $\color{green}{√}$ RG $\color{green}{√}$ AH AK GG JG $\color{green}{√}$ 主要是自己完成，$\color{red}{×}$ 主要是抄题解 A 2014 ACM-ICPC World Finals : ABCEFGHIJKL B 2015 ACM-ICPC World Finals : BEGHJKLM C 2016 ACM-ICPC World Finals : ABDFHIJKM D 2017 ACM-ICPC World Finals : ABDGHJKL E 2018 ACM-ICPC World Finals : CDEGHIJ F 2019 ICPC World Finals : BCFGIJK G 2017-2018 ACM-ICPC Northern Eurasia (Northeastern European Regional) Contest (NEERC17) : FGHIJKL H 2016-2017 ACM-ICPC Northeastern European Regional Contest (NEERC 16) : BCDGIKLM I 2015-2016 ACM-ICPC Northeastern European Regional Contest (NEERC 15) : BCDHIJKL J 2014-2015 ACM-ICPC Northeastern European Regional Contest (NEERC 14) : CDEGHI K 2013-2014 ACM-ICPC Northeastern European Regional Contest (NEERC 13) : ACDEGHIK L 2017-2018 ACM-ICPC, Central Europe Regional Contest (CERC 17) : BCDEIKL M 2016-2017 ACM-ICPC, Central Europe Regional Contest (CERC 16) : BDEGIJL N 2015-2016 ACM-ICPC, Central Europe Regional Contest (CERC 15) : CEFGIJL O 2014-2015 ACM-ICPC, Central Europe Regional Contest (CERC 14) : ABEGJKL P 2013-2014 ACM ICPC, Central Europe Regional Contest (CERC 13) : ADEGHJ Q 2017-2018 ACM-ICPC, NEERC, Northern Subregional Contest : CDEFGHJ R 2016-2017 ACM-ICPC, NEERC, Northern Subregional Contess : BDEGHIJ S 2015-2016 ACM-ICPC, NEERC, Northern Subregional Contest : DFGIK T 2014-2015 ACM-ICPC, NEERC, Northern Subregional Contest : CEFHK U 2013-2014 ACM-ICPC, NEERC, Northern Subregional Contest : CHIJL]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[退役前的做题记录]]></title>
    <url>%2F2020%2F10%2F08%2F%E9%80%80%E5%BD%B9%E5%89%8D%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[由于集训队作业出来了，所以这篇文章就不再更新了QwQ $\color{red}{\bullet}$ 是抄的题解 10.8[PKUWC2018]随机游走 $\color{red}{\bullet}$显然用 $\min-\max$ 容斥将所求变成到达一个点集的最早期望时间。考虑最早时间如何求出，对于一个点集 $S$，不妨设 $f_x$ 为 $x$ 内的点到 $S$ 的最早期望时间。则对于 $x\in S$ 有 $f_x=0$。 对于 $x\notin S$ 有 $$f_x=1+\frac{1}{\deg x}\sum_{(x,y)\in E}f_y$$ 这样需要高斯消元，但考虑到本题的树形结构，我们以起点 $x$ 为根，通过一次函数来分离父子关系，即设 $$f_x=A_x\times f_{fa_x}+B_x$$ 那么对于 $x\notin S$ 即可改写为 $$f_x=1+\frac{1}{\deg x}(f_{fa_x}+\sum_{y\in son_x}(A_yf_x+B_y))$$ 化简得 $$\begin{aligned}A_x&amp;=\frac{1}{\deg x-\sum_{y\in son_x}A_x}\\B_x&amp;=\frac{\deg x+\sum_{y\in son_x}B_x}{\deg x-\sum_{y\in son_x}A_x}\end{aligned}$$ 显然对于起点 $x$ 而言，$f_x=B_x$，对于 $x\in S$ 而言 $A_x=B_x=0$。 之后就是一个高维前缀和了，复杂度 $O(n2^n\log P+q)$。 code CF1422F Boring Queries $\color{red}{\bullet}$这道题就类似于在线区间数颜色。先离线考虑，会发现确定右端点后存在一个类似单调栈的结构，用主席树存下来就行了。 code CF1422E Minlexes $\color{red}{\bullet}$会发现题中的最优化具有最优子结构，直接 dp 就行了，比较字典序大小的时候大力猜结论，需要比较的前缀一定都是同一个字母就好了，或者封装一个哈希表。 code CF1422D Returning Home $\color{red}{\bullet}$降智题，自己写的时候优化建图写歪了。正解就是排序后按顺序连边。 code [10.8模拟赛] 石子游戏 $\color{red}{\bullet}$根据 $(x-y)_2{[j]}=(x-y-k\times2^{j+1})_2{[j]}$ 进行合理的后缀和加减即可得出。 10.9今天什么是也没干，帮学弟写完题解之后就一直在颓颓颓，就把题解搬到这里吧。 签到题考虑最优解的形态，一定是一个字符依次非严格递减且最长的序列，用单调栈维护即可，也可以存一个后缀最大值暴力跳。复杂度 $O(n)$。 送分题题目来源 [EER1]代价。 通过观察样例，我们不难得到一个较优解，它的值为： $$\sum_{i=1}^{n-1}a_i\times a_{i-1}+\min_{i=1}^na_i$$ 我们记最小值的位置为 $p$，则这个解的一种构造方式为先删除 $1$ 到 $p-1$ 的数，在删除 $n$ 到 $p$ 的数。我们注意到 $a_i\times a_{i-1}$ 无论以什么方式删除，至少都会产生一次的贡献，因此这样构造已经比大多数情况优了。考虑少数情况何时取到，注意到满足 $$a_{i-1}\times a_i+a_i\times a_{i+1}&gt;a_{i-1}\times a_i \times a_{i+1}$$ 时这种构造就不够优秀了，此时 $a_{i-1}\le 1$ 或 $a_{i+1}\le 1$ 因此我们以 $1$ 为分界点，重复上述构造即可，复杂度 $O(n)$。 白给题依旧是考虑最优解的形态，不难发现最优解一定是从 $X$先走一段 $X$ 到 $Y$ 的最短路，再走 $0$ 边，通过 $X$ 到 $Y$ 的最短路走到 $Y$。若出现中间交错显然不优，所以我们建立 $S-T$ 的最短路图，在上面 dp 即可。 简单题题目来源 [MtOI2019]恶魔之树。 一个很粗糙的想法就是先离散化，记 $x$ 出现次数为 $c_x$ 则若它被选中有 $2^{c_x}-1$ 的贡献，然后状压质因数的次数。从这个想法出发，如果我们只关注 $\le\sqrt{300}$ 的 $7$ 个质数，对他们的指数进行状压，剩下用 $0-1$ 背包的形式添加贡献就可做到 $O(300\times9\times6\times4\times3\times3\times3\times3)$ 的复杂度。 具体的就是设 $f(i)$ 表示最后子集 $\le\sqrt{300}$ 的质数构成的数为 $\prod p_k^{i_k}$ 的带权方案数，这里的带权是指它会带上那些 $&gt;\sqrt{300}$ 质数的权值。我们对于 $&gt;\sqrt{300}$ 的质数一批一批的考虑，记当前考虑的数为 $p$，那么我们把所有 $p|x$ 的 $x$，先带上 $2^{c_x}-1$ 的贡献，加入到这个 $\max$ 卷积的背包中，最后统一乘上 $p$ 即可。注意实现过程中的不要出现自己更新自己的情况。]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[20200225模拟赛]]></title>
    <url>%2F2020%2F02%2F25%2F20200225%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[div首先我们有一个十分简单的式子 $$\operatorname{E}(n)=\frac{1}{\sigma_0(n)}\sum_{d|n}E(d)+1$$ 其中 $\sigma_0$ 为约数个数 化简之后得$$\operatorname{E}(n)=\frac{1}{\sigma_0(n)-1}\Big(\sum_{d|n,d\ne n}E(d)+\sigma_0(n)\Big)$$ 复杂度为 $\operatorname{O}(n)$ 显然过不了，但是这个式子其实告诉我们转移只与唯一分解质因子的指数集有关，而每次转移正好是一次高维前缀和 我们不需要表示出每一个数的指数集，我们只需要关注那些随质因子单调递增，指数非严格单调递增的数就好了，而这些数在 $1\times10^{18}$ 中只有 $172513$ 个，而与之有关的质因子也只有前 $18$ 个，这些是可以通过 DFS 预处理出来的 我们将这些数按照转移顺序排序记第 $i$ 个数 $n$ 的期望为 $f_i$，那么我们考虑高维前缀和 $s_{j,i}$ 表示第 $i$ 个数满足前 $0$ 到 $j-1$ 个指数的大小与 $n$ 相同，而剩下的指数小于等于其对应 $n$ 的指数，根据这个我们列出方程 $$s_{j,i}=s_{j+1,i}+s_{j,[\frac{n}{p_k}]}$$ 这个式子前一部分的意思是 $j$ 这一位不做改变，而后面的式子就是将 $j$ 这一位的指数减 $1$，其中 $k$ 是满足 $c_j=c_k$ 最大的 $k$，这是由于我们需要满足指数非严格单调递减的条件，否则就搜不到，$n$ 除以 $p_j$ 和 $p_k$ 在指数集的意义上是等价的 由于我们先有的 $s_{j,i}$ 那么这时候 $s_{0,i}$ 的意义就是 $n$ 所有约数的期望和，直接转移可得 $f_i$ 的值，最后将 $f_i$ 的值更新所有的 $s_{j,i}$ 即可 最后查询的话我们只有求出指数集，从大到小排序后即可找到其对应的等价的数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;typedef long long i64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int P = 1e9+7, N = 172513+5, M = 19, p[] = &#123; 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73&#125;; const i64 B = 1e9;struct num26&#123; i64 a, b; num26(i64 a = 0, i64 b = 0):a(a), b(b) &#123;&#125;; int read() &#123; char s[30]; if(!~scanf("%s", s)) return -1; int n = strlen(s); reverse(s, s+n), a = 0, b = 0; for(int i = min(8, n-1); ~i; --i) a = a*10+s[i]-'0'; for(int i = min(23, n-1); i &gt; 8; --i) b = b*10+s[i]-'0'; return 1; &#125; friend bool operator &lt; (num26 a, num26 b) &#123; return a.b^b.b?a.b&lt;b.b:a.a&lt;b.a; &#125; num26 friend operator + (num26 a, num26 b) &#123; return num26((a.a+b.a)%B, a.b+b.b+(a.a+b.a)/B); &#125; num26 friend operator * (num26 a, int b) &#123; return num26(a.a*b%B, a.b*b+a.a*b/B); &#125; num26 friend operator / (num26 a, int b) &#123; return num26(((a.a%b)+(a.b%b)*B)/b, 0)+num26(a.a/b, a.b/b); &#125; int friend operator % (num26 a, int b) &#123; return (a.a%b+a.b%b*B%b)%b; &#125; const void print(char c) const &#123; if(b) printf("%lld%09lld", b, a); else printf("%lld", a); putchar(c); &#125;&#125;;const num26 oo(0, (i64)1e15);int T, m, c[M], tot, s[M][N], f[N]; num26 n, w[N]; pair&lt;num26, int&gt; h[N];int H(num26 n) &#123; return h[lower_bound(h+1, h+1+tot, make_pair(n, 0))-h].second; &#125;void dfs(num26 n, int i, int pre)&#123; ++tot, h[tot] = make_pair(n, tot), w[tot] = n; if(oo &lt; n*p[i]) return; n = n*p[i]; for(int j = 1; j &lt;= pre; ++j, n = n*p[i]) &#123; dfs(n, i+1, j); if(oo &lt; n*p[i]) return; &#125;&#125;i64 inv(int i) &#123; return i == 1?1:P-(P/i)*inv(P%i)%P; &#125;int main()&#123; freopen("div.in", "r", stdin), freopen("div.out", "w", stdout), dfs(num26(1, 0), 0, 90), sort(h+1, h+1+tot); for(int i = 2; i &lt;= tot; ++i) &#123; num26 n = w[i], m = w[i]; int sig = 1; for(int j = 0; j &lt; 18; ++j) &#123; while(m%p[j] == 0) m = m/p[j], ++c[j]; sig *= c[j]+1; &#125; for(int j = 17, k; ~j; --j) &#123; for(k = j; k&lt;17&amp;&amp;c[k+1] == c[j]; ++k); if(c[k]) s[j][i] = (s[j+1][i]+s[j][H(n/p[k])])%P; &#125; f[i] = (s[0][i]+sig)*inv(sig-1)%P; for(int j = 0; j &lt; 18; ++j) s[j][i] = (s[j][i]+f[i])%P, c[j] = 0; &#125; while(~n.read()) &#123; m = read(); for(int i = 0, p; i &lt; m; ++i) &#123; p = read(); while(n%p == 0) n = n/p, ++c[i]; &#125; sort(c, c+m), reverse(c, c+m); for(int i = 0; i &lt; m; ++i) for( ; c[i]; n = n*p[i], --c[i]); printf("%d\n", f[H(n)]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1054H Epic Convolution]]></title>
    <url>%2F2020%2F02%2F24%2FCF1054H-Epic-Convolution%2F</url>
    <content type="text"><![CDATA[最近突然想做多项式了，就找了些题，这道题用的 2D-FFT 的科技我还不会 首先和式的 $i$ 和 $j$ 除了出现在下标上，就是出现在指数上，并且 $490019$ 是一个质数 $\varphi(490019)=490018=2\times491\times499$ 我们就可以想到按照 $i^2j^3$ 模这些数的值的余数来计算，即答案为$$\sum_x\sum_y\sum_zc^{[x,y,z]}\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}A_iB_j[i^2j^2\operatorname{mod}491=x][i^2j^2\operatorname{mod}499=y][i^2j^2\operatorname{mod}2=z]$$ 其中 $[x,y,z]$ 为中国剩余定理的合并 并且我们知道通过离散对数可以很容易把乘变成加，其中 $2$ 的原根为 $1$，$491$ 的原根为 $2$，$499$ 的原根为 $7$，$2$ 其实也可以不搞原根，直接暴力，那么考虑我们最后需要求出的二元函数 $f_i(x,y)$， $g_i(x,y)$，$h_i(x,y)$ 实际上表示为 $$[x^ny^m]f_t=\sum_{i^2\operatorname{mod}2=t,\operatorname{ind}_2^{491}i^2=n,\operatorname{ind}_7^{499}i^2=m}A_i$$ $$[x^ny^m]g_t=\sum_{i^2\operatorname{mod}2=t,\operatorname{ind}_2^{491}i^3=n,\operatorname{ind}_7^{499}i^3=m}B_i$$ $$[x^ny^m]h_t=\sum_{a\And b=t}[x^ny^m]{(f_a\times g_b)}$$ 而后面的 $f_a$ 与 $g_b$ 为二维卷积，需要用 2D-FFT 优化 其中，2D-FFT 的公式通过如下给出，首先是 DFT $$y_{i,j}=\sum_{k=0}^{n-1}\sum_{l=0}^{m-1}a_{k,l}\omega_n^{ik}\omega_n^{jl}$$ 而加入我们定列 DFT 为 $$z_{i,l}=\sum_{k=0}^{n-1}a_{k,l}\omega_n^{ik}$$ 很显然 $$y_{i,j}=\sum_{l=0}^{m-1}\omega_n^{jl}z_{i,l}$$ 综上，2D-DFT 即为先做列 DFT 在做行 DFT，颠倒也可以，那么 IDFT 同理 最后需要考虑有一些不存在离散对数的情况，那么这些为 $491$ 或 $499$ 的倍数，需要单独抽出来考虑，我们认为 $n,m$ 同阶的话复杂度有 $\operatorname{O}(p\log p+\frac{n^2}{\sqrt p})$ 需要轻微卡常]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CTSC2010]性能优化]]></title>
    <url>%2F2020%2F02%2F23%2FCTSC2010-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[深知自己快退役了，所以这段时间打算把 FFT 原理的那一部分搞明白 首先，我们需要知道平常我们做的 FFT 实际上是循环卷积，循环卷积的长度相当于单位根的下指标，而平时这个值都是大于最后次数的，所以和普通卷积并无差别，具体来说我们要求的是 $$c_k=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_ib_j[(i+j)\operatorname{mod}n=k]$$ 由单位根反演可得$$\begin{aligned}c_k&amp;=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_ib_j\big(\frac{1}{k}\sum_{d=0}^{n-1}\omega_n^{(i+j-k)d}\big)\\&amp;=\frac{1}{k}\sum_{d=0}^{n-1}\omega_n^{-kd}\big(\sum_{i=0}^{n-1}a_i\omega_n^{id}\big)\big(\sum_{j=0}^{n-1}b_j\omega_n^{jd}\big)\end{aligned}$$ 我们发现前一部分是 IDFT 而后一部分是 DFT，合起来就是 FFT 了 但这就要求我们可以实现任意长度 FFT，然而对于 FFT 实际求解中最关键的一步却要求需要为 $2$ 的整数次幂，具体过程如下 考虑当前多项式 $A(x)$ 我们不妨设 $$A^{[0]}(x)=\sum_{i\operatorname{mod}2=0}a_ix^{\frac{i}{2}}$$ 以及 $$A^{[1]}(x)=\sum_{i\operatorname{mod}2=1}a_ix^{\frac{i-1}{2}}$$ 那么显然 $$A(\omega_n^i)=A^{[0]}(w_n^{2i})+w_n^iA^{[1]}(\omega_n^{2i})$$ 由折半引理得，对于前一半 $$A(\omega_n^i)=A^{[0]}(w_{\frac{n}{2}}^i)+w_n^iA^{[1]}(w_{\frac{n}{2}}^i)$$ 对于后一半而言 $$A(\omega_n^i)=A^{[0]}(w_{\frac{n}{2}}^i)-w_n^iA^{[1]}(w_{\frac{n}{2}}^i)$$ 所以达到问题规模减小的目的 但对于一般的 $n$ 而言我们需要找到它的因子 $m$ 类比上方做如下变换，设 $$A^{[j]}(x)=\sum_{i\operatorname{mod}m=j}a_ix^{\frac{i-j}{m}}$$ 而最终的 $$\begin{aligned}A(w_n^i)&amp;=\sum_{j=0}^{m-1}\omega_n^{ij}A^{[j]}(\omega_n^{im})\\&amp;=\sum_{j=0}^{m-1}\omega_n^{ij}A^{[j]}(\omega_{\frac{n}{m}}^i)\end{aligned}$$ 这道题由于保证 $n$ 可以表示为若干不超过 $10$ 的正整数乘积，所以复杂度得到保证，更一般的我们可以使用 Bluestein&#39;s Algorithm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long i64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 5e5+5;int n, C, m, P, gn, lim, d[N]; i64 g[N];i64 qpow(i64 a, int b) &#123; i64 ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%P) if(b&amp;1) ret = ret*a%P; return ret; &#125;void prepare()&#123; vector&lt;int&gt; p; for(int i = 2, n = P-1; i &lt;= 7; ++i) if(n%i == 0) &#123; p.push_back(i); while(n%i == 0) n /= i, d[++m] = i; &#125; for(gn = 1; ; ++gn) &#123; int i = 0; for( ; i &lt; p.size()&amp;&amp;qpow(gn, (P-1)/p[i]) != 1; ++i); if(i == p.size()) break; &#125; g[0] = 1; for(int i = 1; i &lt; n; ++i) g[i] = g[i-1]*gn%P;&#125;struct Poly&#123; vector&lt;int&gt; A; int&amp; operator [] (const int i) &#123; return A[i]; &#125; int ti() &#123; return A.size()-1; &#125; void set(int ti) &#123; A.resize(ti+1); &#125;&#125;A, B;void _FFT(Poly &amp;A, int _)&#123; if(!A.ti()) return; int n = A.ti()+1, m = d[_]; vector&lt;Poly&gt; B; B.resize(m); for(int i = 0; i &lt; m; ++i) B[i].set(n/m-1); for(int i = 0; i &lt;= n-1; ++i) B[i%m][(i-(i%m))/m] = A[i]; for(int i = 0; i &lt; m; ++i) _FFT(B[i], _+1); for(int i = 0, q = lim/n; i &lt;= n-1; ++i) &#123; A[i] = 0; for(int j = 0, p = 0; j &lt; m; ++j, p = (p+i)%n) A[i] = (A[i]+g[p*q]*B[j][i%(n/m)]%P)%P; &#125;&#125;void FFT(Poly &amp;A, int t)&#123; if(!t) _FFT(A, 1); else &#123; reverse(++A.A.begin(), A.A.end()), _FFT(A, 1); i64 v = qpow(n, P-2); for(int i = 0; i &lt; lim; ++i) A[i] = A[i]*v%P; &#125;&#125;int main()&#123; n = read(), C = read(), A.set(n-1), B.set(n-1), lim = n, P = n+1, prepare(); for(int i = 0; i &lt; n; ++i) A[i] = read(); for(int i = 0; i &lt; n; ++i) B[i] = read(); FFT(A, 0), FFT(B, 0); for(int i = 0; i &lt; n; ++i) A[i] = A[i]*qpow(B[i], C)%P; FFT(A, 1); for(int i = 0; i &lt; n; ++i) printf("%d\n", A[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2019]白兔之舞]]></title>
    <url>%2F2020%2F02%2F22%2FHNOI2019-%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E%2F</url>
    <content type="text"><![CDATA[很显然，设答案序列为 $a$ 则有 $$a_t=\sum_{i=0}^L\binom{L}{i}w^i_{x,y}[i\operatorname{mod}k=t]$$ 由单位根反演 $$[n|k]=\frac{1}{n}\sum_{i=0}^{n-1}\omega_n^{ki}$$带入答案式子就有 $$a_t=\sum_{i=0}^L\binom{L}{i}w_{x,y}^i\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{(i-t)j}$$ 我们交换求和顺序 $$a_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}\sum_{i=0}^L\binom{L}{i}w_{x,y}^i\omega_k^{ij}$$ 后面的部分用二项式定理得 $$a_t=\frac{1}{k}\sum_{j=0}^{k-1}\omega_k^{-tj}(\omega_k^jw+e)^L_{x,y}$$ 我们考虑多项式 $$f(x)=\frac{1}{k}\sum_{j=0}^{k-1}x^j(\omega_k^jw+e)^L_{x,y}$$ 那么有 $$a_t=f(\omega_k^{-t})$$ 单位根的求值可以用 FFT 快速求出，但前提是在项数为 $2$ 的整数次幂的情况下，如果我们要做任意长度的 DFT 那么就需要用 Bluestein&#39;s Algorithm 具体细节如下 考虑 DFT 的形式 $$y_j=\sum_{i=0}^{n-1}a_i(\omega_n^j)^i$$ 根据 $ij=\binom{i+j}{2}-\binom{i}{2}-\binom{j}{2}$ 可以得到 $$y_j=\omega_n^{-\binom{j}{2}}\sum_{i=0}^{n-1}a_i\omega_n^{-\binom{i}{2}}\omega_n^{\binom{i+j}{2}}$$ 如果设 $$f=\sum_{i=0}^{n-1}a_i\omega_n^{-\binom{i}{2}}x^i$$ $$g=\sum_{i=0}^{2n-2}\omega_n^{\binom{2n-2-i}{2}}x^i$$ 则 $$y_j=\omega_n^{-\binom{j}{2}}[x^{2n-2-j}]{(f\times g)}$$ 而后者就是一个普通的卷积 接着，我们考虑 IDFT $$c_j=\frac{1}{n}\sum_{i=0}^{n-1}a_i\omega_n^{-ij}$$ 其实与上面同理，只不过是符号变了罢了 若我们考虑模 $p$ 意义下的原根 $g$，用 $g^{\frac{p-1}{k}}$ 来代替 $\omega_k$ 的话，就用拆系数 FTT 即可 计算一下总复杂度为 $\operatorname{O}(\Delta+kn^3\log L+k\log k)$ 最前面是求原根的复杂度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long i64;typedef double f64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 3, K = 1&lt;&lt;18|5; const f64 PI = acos(-1);int n, k, kinv, L, x, y, P, gn, g[K], f[K];struct Mat&#123; i64 A[N][N]; Mat() &#123; memset(A, 0, sizeof(A)); &#125; i64* operator [] (const int i) &#123; return A[i]; &#125; friend Mat operator * (Mat A, Mat B) &#123; Mat C; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) for(int k = 0; k &lt; n; ++k) C[i][j] = (C[i][j]+A[i][k]*B[k][j]%P)%P; return C; &#125; friend Mat operator * (int k, Mat A) &#123; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) A[i][j] = k*A[i][j]%P; return A; &#125; friend Mat operator + (Mat A, Mat B) &#123; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) A[i][j] = (A[i][j]+B[i][j])%P; return A; &#125; void set() &#123; for(int i = 0; i &lt; n; ++i) A[i][i] = 1; &#125; friend Mat operator ^ (Mat A, int b) &#123; Mat ret; ret.set(); for( ; b; b &gt;&gt;= 1, A = A*A) if(b&amp;1) ret = ret*A; return ret; &#125;&#125;w, e;i64 qpow(i64 a, int b) &#123; i64 ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%P) if(b&amp;1) ret = ret*a%P; return ret; &#125;void groot()&#123; vector&lt;int&gt; p; int n = P-1; for(int i = 2, t = sqrt(n); i &lt;= n; ++i) if(n%i == 0) &#123; p.push_back(i); while(n%i == 0) n /= i; &#125; if(n != 1) p.push_back(n); for(gn = 1; ; ++gn) &#123; int i = 0; for( ; i &lt; p.size()&amp;&amp;qpow(gn, (P-1)/p[i]) != 1; ++i); if(i == p.size()) break; &#125; gn = qpow(gn, (P-1)/k), g[0] = 1; for(int i = 1; i &lt; k; ++i) g[i] = 1ll*g[i-1]*gn%P;&#125;namespace Bluestein&#123;struct C&#123; f64 a, b; C(f64 a = 0, f64 b = 0):a(a), b(b) &#123;&#125;; friend C operator + (C a, C b) &#123; return C(a.a+b.a, a.b+b.b); &#125; friend C operator - (C a, C b) &#123; return C(a.a-b.a, a.b-b.b); &#125; friend C operator * (C a, C b) &#123; return C(a.a*b.a-a.b*b.b, a.a*b.b+a.b*b.a); &#125; C operator ~ () &#123; return C(a, -b); &#125;&#125;w[K], S[K], T[K];int lim, rev[K], C2[K];void prepare(int ti)&#123; for(lim = 1; lim &lt;= ti; lim &lt;&lt;= 1); for(int i = 0, j = 0; i &lt; lim; ++i) &#123; w[i] = C(cos(2*PI*i/lim), sin(2*PI*i/lim)), rev[i] = j; for(int k = lim&gt;&gt;1; (j ^= k) &lt; k; k &gt;&gt;= 1); &#125;&#125;struct Poly&#123; vector&lt;int&gt; A; vector&lt;C&gt; B; int&amp; operator [] (const int i) &#123; return A[i]; &#125; void set(int ti) &#123; A.resize(ti+1); &#125; int ti() &#123; return A.size()-1; &#125; void clear() &#123; return B.clear(); &#125; void init() &#123; int n = ti(); B.resize(n+1); for(int i = 0; i &lt;= n; ++i) B[i] = C(A[i]&gt;&gt;15, A[i]&amp;32767); &#125; void FFT(int t) &#123; if(!t) &#123; B.resize(lim); for(int i = 0; i &lt; lim; ++i) if(i &lt; rev[i]) swap(B[i], B[rev[i]]); for(int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) for(int j = 0, len = mid&lt;&lt;1; j &lt; lim; j += len) for(int k = 0, p = 0, q = lim/len; k &lt; mid; ++k, p += q) &#123; C x = B[j+k], y = w[p]*B[j+k+mid]; B[j+k] = x+y, B[j+k+mid] = x-y; &#125; &#125; else &#123; reverse(++B.begin(), B.end()), FFT(0); C v(1.0/lim, 0); for(int i = 0; i &lt; lim; ++i) B[i] = B[i]*v; &#125; &#125; friend Poly operator * (Poly A, Poly B) &#123; int n = A.ti(), m = B.ti(); prepare(n+m), A.init(), B.init(); A.FFT(0), B.FFT(0); C p, q, a, b, c, d; for(int i = 0; i &lt; lim; ++i) &#123; p = A.B[i], q = ~A.B[i?lim-i:0], a = (p+q)*C(0.5, 0), b = (p-q)*C(0, -0.5); p = B.B[i], q = ~B.B[i?lim-i:0], c = (p+q)*C(0.5, 0), d = (p-q)*C(0, -0.5); S[i] = a*c+b*d*C(0, 1), T[i] = a*d+b*c; &#125; for(int i = 0; i &lt; lim; ++i) A.B[i] = S[i], B.B[i] = T[i]; A.FFT(1), B.FFT(1), A.set(n+m); for(int i = 0; i &lt;= n+m; ++i) &#123; i64 a = A.B[i].a+0.5, b = B.B[i].a+0.5, c = A.B[i].b+0.5; A[i] = (a%P*(1&lt;&lt;30)+b%P*(1&lt;&lt;15)+c)%P, A[i] = (A[i]+P)%P; &#125; A.clear(), B.clear(); return A; &#125;&#125;;void solve(int *a, int n)&#123; Poly F, G; F.set(n-1), G.set((n-1)&lt;&lt;1); for(int i = 1; i &lt; (n-1)&lt;&lt;1; ++i) C2[i+1] = (C2[i]+i)%n; for(int i = 0; i &lt; n; ++i) F[i] = 1ll*a[i]*g[C2[i]?n-C2[i]:0]%P; for(int i = 0; i &lt;= (n-1)&lt;&lt;1; ++i) G[i] = g[C2[(n-1)*2-i]]; F = F*G; for(int i = 0; i &lt; n; ++i) a[i] = 1ll*g[C2[i]?n-C2[i]:0]*F[(n-1)*2-i]%P;&#125;&#125;int main()&#123; n = read(), k = read(), L = read(), x = read()-1, y = read()-1, P = read(); kinv = qpow(k, P-2), e.set(), groot(); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n; ++j) w[i][j] = read(); for(int i = 0; i &lt; k; ++i) f[i] = kinv*((g[i]*w+e)^L)[x][y]%P; Bluestein::solve(f, k); for(int i = 0; i &lt; k; ++i) printf("%d\n", f[i?k-i:0]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[确实学不会的类欧几里得算法]]></title>
    <url>%2F2020%2F02%2F21%2F%E7%A1%AE%E5%AE%9E%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[所谓类欧几里得就是复杂度与欧几里得算法类似，但其他完全不一样的算法 开始之前，先做一个简单的约定，其中 $0^0=1$ $$\operatorname{S_m}(n)=\sum_{i=0}^ni^m$$ P5170 【模板】类欧几里得算法设题目中所要求的为 $$\operatorname{f}(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor\\\operatorname{g}(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor^2\\\operatorname{h}(a,b,c,n)=\sum_{i=0}^ni\lfloor\frac{ai+b}{c}\rfloor$$我们先从 $\operatorname{f}$ 入手首先，有一个很明显的恒等式 $$\begin{aligned}\lfloor\frac{Ax}{y}\rfloor&amp;=\lfloor\frac{A(y\lfloor\frac{x}{y}\rfloor+x\operatorname{mod}y)}{y}\rfloor\\&amp;=\lfloor\frac{A(x\operatorname{mod}y)}{y}\rfloor+A\lfloor\frac{x}{y}\rfloor\end{aligned}$$ 所以就有 $$\begin{aligned}\operatorname{f}(a,b,c,n)&amp;=\operatorname{S_1}(n)\lfloor\frac{a}{c}\rfloor+\operatorname{S_0}(n)\lfloor\frac{b}{c}\rfloor+\sum_{i=0}^n\lfloor\frac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor\\&amp;=\operatorname{S_1}(n)\lfloor\frac{a}{c}\rfloor+\operatorname{S_0}(n)\lfloor\frac{b}{c}\rfloor+\operatorname{f}(a\operatorname{mod}c,b\operatorname{mod}c,c)\end{aligned}$$ 根据这个我们就可以把 $a\ge c$ 和 $b\ge c$ 转化为 $a&lt;c$ 和 $b&lt;c$ 那么考虑 $a&lt;c\land b &lt; c$ 的情形，设 $m=\lfloor\frac{an+b}{c}\rfloor$ 我们有 $$\begin{aligned}\operatorname{f}(a,b,c,n)&amp;=\sum_{i=0}^n\sum_{j=1}^m[j\le\lfloor\frac{ai+b}{c}\rfloor]\\&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n[jc+c\le ai+b]\end{aligned}$$ 之后我们需要明确 $$\lfloor\frac{a}{b}\rfloor\le\frac{a}{b}\le\lceil\frac{a}{b}\rceil=\lfloor\frac{a-1}{b}\rfloor+1$$ 当且仅当 $b|a$ 时等号取到 所以 $$\begin{aligned}\operatorname{f}(a,b,c,n)&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n[\lceil\frac{jc+c-b}{a}\rceil\le i]\\&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n[\lfloor\frac{jc+c-b-1}{a}\rfloor&lt; i]\end{aligned}$$ 由于 $\frac{(m-1)c+c-b-1}{a}&lt;n$ 所以式子可以变为 $$\begin{aligned}\operatorname{f}(a,b,c,n)&amp;=nm-\sum_{j=0}^{m-1}\lfloor\frac{jc+c-b-1}{a}\rfloor\\&amp;=nm-\operatorname{f}(c,c-b-1,a,m-1)\end{aligned}$$ 这就是一个类似于更相减损的方法了，那么很显然有边界 当 $a=0\lor n=0$ 时， $\operatorname{f}(a,b,c,n)=\operatorname{S}_0(n)\lfloor\frac{b}{c}\rfloor$ 之后我们再看 $\operatorname{g}$，我们类比 $\operatorname{f}$ 的过程 首先 $a\ge c\lor b\ge c$ 时， $$\begin{aligned}\operatorname{g}(a,b,c,n)=&amp;\sum_{i=0}^n(\lfloor\frac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\frac{a}{c}\rfloor+\lfloor\frac{b}{c}\rfloor)^2\\=&amp;\operatorname{S}_2(n)\lfloor\frac{a}{c}\rfloor^2+2\operatorname{S}_1(n)\lfloor\frac{a}{c}\rfloor\lfloor\frac{b}{c}\rfloor+\operatorname{S}_0(n)\lfloor\frac{b}{c}\rfloor^2+\operatorname{g}(a\operatorname{mod}c,b\operatorname{mod}c,c)\\&amp;+2\lfloor\frac{a}{c}\rfloor\operatorname{h}(a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\frac{b}{c}\rfloor\operatorname{f}(a\operatorname{mod}c,b\operatorname{mod}c,c)\end{aligned}$$ 接着我们讨论 $a&lt; c\land b&lt; c$ 不妨设 $m=\lfloor\frac{an+b}{c}\rfloor$ $$\begin{aligned}\operatorname{g}(a,b,c,n)&amp;=\sum_{i=0}^n(\sum_{j=1}^m[j\le\lfloor\frac{ai+b}{c}\rfloor])^2\\&amp;=\sum_{i=0}^n\sum_{j=1}^m\sum_{k=1}^m[j\le\lfloor\frac{ai+b}{c}\rfloor][k\le\lfloor\frac{ai+b}{c}\rfloor]\\&amp;=\sum_{i=0}^n\sum_{j=0}^{m-1}\sum_{k=0}^{m-1}[\lfloor\frac{jc+c-b-1}{a}\rfloor&lt; i][\lfloor\frac{kc+c-b-1}{a}\rfloor&lt; i]\\&amp;=nm^2-\sum_{j=0}^{m-1}\sum_{k=0}^{m-1}\max(\lfloor\frac{jc+c-b-1}{a}\rfloor,\lfloor\frac{kc+c-b-1}{a}\rfloor)\end{aligned}$$ 根据对称性不难得到 $$\begin{aligned}\operatorname{g}(a,b,c,n)&amp;=nm^2-(2\sum_{j=0}^{m-1}(j+1)\lfloor\frac{jc+c-b-1}{a}\rfloor-\sum_{j=0}^{m-1}\lfloor\frac{jc+c-b-1}{a}\rfloor)\\&amp;=nm^2-2\operatorname{h}(c,c-b-1,a,m-1)-\operatorname{f}(c,c-b-1,a,m-1)\end{aligned}$$ 考虑边界条件 $a=0\lor n=0$ 则有 $\operatorname{g}(a,b,c,n)=\operatorname{S}_0(n)\lfloor\frac{b}{c}\rfloor^2$ 最后计算 $\operatorname{h}$ 同样类比我们可以得到 首先 $a\ge c\lor b\ge c$ 时 $$\begin{aligned}\operatorname{h}(a,b,c,n)&amp;=\sum_{i=0}^ni(\lfloor\frac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\frac{a}{c}\rfloor+\lfloor\frac{b}{c}\rfloor)\\&amp;=\operatorname{S}_2(n)\lfloor\frac{a}{c}\rfloor+\operatorname{S}_1(n)\lfloor\frac{b}{c}\rfloor+\operatorname{h}(a\operatorname{mod}c,b\operatorname{mod}b,c)\end{aligned}$$ 其次 $a&lt;c\land b&lt;c$ 时，同理设 $m=\lfloor\frac{an+b}{c}\rfloor$$$\begin{aligned}\operatorname{h}(a,b,c,n)&amp;=\sum_{i=0}^ni\sum_{j=1}^m[j\le\lfloor\frac{ai+b}{c}\rfloor]\\&amp;=\sum_{j=0}^{m-1}\sum_{i=0}^ni[\lfloor\frac{jc+c-b-1}{a}\rfloor&lt;i]\\&amp;=\operatorname{S_1}(n)m-\sum_{j=0}^{m-1}\frac{1}{2}(\lfloor\frac{jc+c-b-1}{a}\rfloor+\lfloor\frac{jc+c-b-1}{a}\rfloor^2)\\&amp;=\operatorname{S_1}(n)m-\frac{1}{2}\operatorname{f}(c,c-b-1,a,m-1)-\frac{1}{2}\operatorname{g}(c,c-b-1,a,m-1)\end{aligned}$$ 最后 $a=0\lor n=0$ 时 $\operatorname{h}=\operatorname{S}_1(n)\lfloor\frac{b}{c}\rfloor$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int P = 998244353, I2 = P-(P/2), I6 = 166374059;struct Euclid &#123; int f, g, h; &#125;;Euclid solve(int a, int b, int c, int64 n)&#123; int64 p = a/c%P, q = b/c%P, p2 = p*p%P, q2 = q*q%P, m = n%P; Euclid E, F; int s0 = m+1, s1 = (m+1)*m%P*I2%P, s2 = (m+1)*I6%P*(2*m+1)%P*m%P; if(a == 0||n == 0) E.f = s0*q%P, E.g = s0*q2%P, E.h = s1*q%P; else if(a &gt;= c||b &gt;= c) &#123; F = solve(a%c, b%c, c, n); E.f = (s1*p+s0*q+F.f)%P; E.g = ((s2*p2+2*s1*p%P*q%P+s0*q2)%P+F.g+2*p*F.h%P+2*q*F.f%P)%P; E.h = (s2*p+s1*q+F.h)%P; &#125; else &#123; m = (a*n+b)/c, n %= P, F = solve(c, c-b-1, a, m-1); E.f = (n*m+P-F.f)%P, E.g = (n*m%P*m%P-F.f%P-2*F.h%P+P*2)%P, E.h = (s1*m%P-1ll*I2*(F.f+F.g)%P+P)%P; &#125; return E;&#125;int t;int main()&#123; t = read(); while(t--) &#123; int n = read(), a = read(), b = read(), c = read(); Euclid E = solve(a, b, c, n); printf("%d %d %d\n", E.f, E.g, E.h); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20200218模拟赛]]></title>
    <url>%2F2020%2F02%2F18%2F20200218%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[Jump题目描述求 $n$ 个点 $m$ 条边的无向图，求可将每个边定向的方案满足最后的图是 DAG 的方案数 题解设 $f_S$ 为点集为 $S$ 的方案数，枚举入度为 $0$ 的点，可得到 $$f_S=\sum_{T\subseteq S\land T\ne\emptyset}(-1)^{|T|+1}w_Tf_{S-T}$$ 其中 $w_T$ 为点集 $T$ 内不存在相互之间的边是否为真，因为入度为零即 $T\rightarrow S-T$ 的边都被定向方案数为 $1$，由于入度为零那么相互之间必然不能有边 但是我们考虑到对于一个入度为 $0$ 的集合 $I$ 而言，它的每个子集实际上都把它算了一遍，所以我们要算上容斥系数 $(-1)^{|I|+1}$ 具体来说，我们考虑 $$\sum_{J\subseteq I}a_J=[I\ne\emptyset]$$ 用子集反演得到 $$a_I=\sum_{J\subseteq I}(-1)^{|I-J|}[J\ne\emptyset]$$ 化简得 $$a_I=\sum_{i=1}^{|I|}\binom{|I|}{i}(-1)^{|I|-i}$$ 即当 $I$ 不为空时 $$a_I=(-1)^{|I|+1}$$ 然后就是标准的子集卷积，FWT 可以在 $\operatorname{O}(n^22^n)$ 的解决，注意取模的常数即可 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e1+5, S = 1&lt;&lt;20|5, P = 1e9+7;int n, m, e[N], c[S], f[N][S], g[N][S];void add(int &amp;x, int y) &#123; x = x+y&lt;P?x+y:x+y-P; &#125;void FWT(int *A, int n, int t)&#123; for(int mid = 1; mid &lt; n; mid &lt;&lt;= 1) for(int j = 0, len = mid&lt;&lt;1; j &lt; n; j += len) for(int k = 0; k &lt; mid; ++k) if(!t) add(A[j+k+mid], A[j+k]); else add(A[j+k+mid], P-A[j+k]);&#125;int W(int s) &#123; for(int i = 0; i &lt; n; ++i) if((s&gt;&gt;i&amp;1)&amp;&amp;c[e[i]&amp;s]) return 0; return (c[s]&amp;1)?1:P-1; &#125;int main()&#123; freopen("jump.in", "r", stdin), freopen("jump.out", "w", stdout); n = read(), m = read(); for(int i = 1; i &lt;= m; ++i) &#123; int x = read()-1, y = read()-1; e[x] |= 1&lt;&lt;y, e[y] |= 1&lt;&lt;x; &#125; for(int s = 1; s &lt; 1&lt;&lt;n; ++s) c[s] = c[s&gt;&gt;1]+(s&amp;1), g[c[s]][s] = W(s); f[0][0] = 1, FWT(f[0], 1&lt;&lt;n, 0); for(int i = 1; i &lt;= n; ++i) FWT(g[i], 1&lt;&lt;n, 0); for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt; i; ++j) for(int s = 0; s &lt; 1&lt;&lt;n; ++s) add(f[i][s], 1ll*f[j][s]*g[i-j][s]%P); FWT(f[n], 1&lt;&lt;n, 1), printf("%d\n", f[n][(1&lt;&lt;n)-1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>贪心</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[20200215模拟赛] 学习]]></title>
    <url>%2F2020%2F02%2F16%2F20200215%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E5%A5%BD%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[一半看到这种代价为 $k$ 次方的形式，且需要转移复杂度的题，都是用第二类斯特林数解决的 第二类斯特林数我们记作 $\begin{Bmatrix} n \\ m \end{Bmatrix}$ 表示将 $n$ 个相互作区分的元素放入 $m$ 个不做区分的集合里，每个集合元素非空的方案数，我们很容易就能有多项式得到一个恒等式 我们不妨计 $\begin{Bmatrix} n \\ m \end{Bmatrix}\times m!$ 的 egf 为 $f$，即集合做区分的母函数，考虑另一个 egf 为 $g_n$ 满足 $$g_n=\sum_{i}i^n\frac{x^i}{i!}$$很显然 $[x^m]g_n$ 的意义就是我们要求做区分的集合可以为空的方案数的生成函数，那么显然有 $$e^xf=g_n$$ 我们就可以得到 $$m^n=\sum_{i=0}^{\min(n,m)}\binom{m}{i}\begin{Bmatrix} n \\ i \end{Bmatrix}\times i!$$ 所以代入这道题要求的式子 $$\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^mx_i^{k_i}$$ 化简得到 $$\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^m\sum_{j=0}^{\min(x_i,k_i)}\binom{x_i}{j}\begin{Bmatrix} k_i \\ j \end{Bmatrix}\times j!$$ 注意到 $\sum_{i=1}^mk_i\le1\times10^5$，所以我们考虑求这样的多项式 $$\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^m\sum_{j=0}^{\min(x_i,k_i)}\binom{x_i}{j}\begin{Bmatrix} k_i \\ j \end{Bmatrix}\times j!\ x^j$$ 那么我们就可以将最内侧的和式移到外面 $$\sum_j\sum_{\sum_{i=1}^mc_i=j}\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^m\binom{x_i}{c_i}\prod_{i=1}^m\begin{Bmatrix} k_i \\ c_i \end{Bmatrix}\times c_i!\ x^j$$ 我们注意到中间的 $$\sum_{\sum_{i=1}^mx_i=n}\prod_{i=1}^m\binom{x_i}{c_i}$$ 实际上是有组合意义的，与隔板法非常类似，我们想象有个长度为 $n+m-1$ 的序列，我们从中选出 $m-1+\sum_{i=1}^mc_i$ 个元素，对于每一种选择方案我们这样构造，先是 $c_1$ 个元素，再算上 $1$ 个隔板依次类推，所以答案的多项式又可以简化为 $$\sum_j\sum_{\sum_{i=1}^mc_i=j}\binom{n+m-1}{m-1+j}\prod_{i=1}^m\begin{Bmatrix} k_i \\ c_i \end{Bmatrix}\times c_i!\ x^j$$ 而实际上我们只需要多项式 $$\prod_{i=1}^m\sum_{j=0}^{k_i}\begin{Bmatrix} k_i \\ j \end{Bmatrix}\times j!\ x^j$$ 再算上相应的系数即可 那么用最开始斯特林数的生成函数的等式 那么为 $$\prod_{i=1}^m\sum_{j=0}^{k_i}j!\times[x^j]{(}e^{-x}\times g_{k_i}{)}\ x^j$$ 实际上后面的 $e^x$ 和 $g_{k_i}$ 只需要求到 $x^{k_i}$ 即可，那么整个式子可以用分治 FFT 优化，用一个类似于线段树的结构求出 $$\prod_{i=l}^r\sum_{j=0}^{k_i}j!\times[x^j]{(}e^{-x}\times g_{k_i}{)}\ x^j$$ 每一层总的项数和为 $S=\sum_{i=1}^mk_i$ 所以复杂度为 $\operatorname{O}(S\log^2S)$ 其他类似题目可参照 [BZOJ 5093] 图的价值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 8e5+5, M = 1e7+5+1e5, P = 998244353;int64 w[2][N], fac[M], ifac[M]; int lim, rev[N];int64 qpow(int64 a, int b) &#123; int64 ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%P) if(b&amp;1) ret = ret*a%P; return ret;&#125;void prepare(int ti)&#123; for(lim = 1; lim &lt;= ti; lim &lt;&lt;= 1); int64 g = qpow(3, (P-1)/lim); w[0][0] = w[1][0] = w[0][lim] = w[1][lim] = 1; for(int i = 1, j = lim&gt;&gt;1; i &lt; lim; ++i) &#123; w[0][i] = w[1][lim-i] = w[0][i-1]*g%P, rev[i] = j; for(int k = lim&gt;&gt;1; (j ^= k) &lt; k; k &gt;&gt;= 1); &#125;&#125;struct Poly&#123; vector&lt;int&gt; A; int&amp; operator [] (const int i) &#123; return A[i]; &#125; void set(int ti) &#123; A.resize(ti+1); &#125; int ti() &#123; return A.size()-1; &#125; void NTT(int t) &#123; if(!t) A.resize(lim); for(int i = 0; i &lt; lim; ++i) if(rev[i] &gt; i) swap(A[rev[i]], A[i]); for(int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) for(int len = mid&lt;&lt;1, j = 0; j &lt; lim; j += len) for(int k = 0, p = 0, q = lim/len; k &lt; mid; ++k, p += q) &#123; int x = A[j+k], y = A[j+k+mid]*w[t][p]%P; A[j+k] = (x+y)%P, A[j+k+mid] = (x-y+P)%P; &#125; if(!t) return; int64 v = qpow(lim, P-2); for(int i = 0; i &lt; lim; ++i) A[i] = A[i]*v%P; &#125; friend Poly operator * (Poly A, Poly B) &#123; int n = A.ti(), m = B.ti(); prepare(n+m), A.NTT(0), B.NTT(0); for(int i = 0; i &lt; lim; ++i) A[i] = 1ll*A[i]*B[i]%P; return A.NTT(1), A.set(n+m), A; &#125;&#125;F;int n, m, s, a[N], ans;int64 C(int n, int m) &#123; return 0 &lt;= m&amp;&amp;m &lt;= n?fac[n]*ifac[m]%P*ifac[n-m]%P:0; &#125;Poly solve(int l, int r)&#123; if(l == r) &#123; Poly A, B; A.set(a[l]), B.set(a[l]); for(int i = 0; i &lt;= a[l]; ++i) A[i] = i&amp;1?P-ifac[i]:ifac[i], B[i] = qpow(i, a[l])*ifac[i]%P; A = A*B, A.set(a[l]); for(int i = 0; i &lt;= a[l]; ++i) A[i] = A[i]*fac[i]%P; return A; &#125; int mid = (l+r)&gt;&gt;1; return solve(l, mid)*solve(mid+1, r);&#125;int main()&#123; freopen("b.in", "r", stdin), freopen("b.out", "w", stdout); m = read(), n = read(), fac[0] = 1; for(int i = 1; i &lt;= m; ++i) a[i] = read(), s += a[i]; for(int i = 1; i &lt;= n+m-1; ++i) fac[i] = fac[i-1]*i%P; ifac[n+m-1] = qpow(fac[n+m-1], P-2); for(int i = n+m-1; i; --i) ifac[i-1] = ifac[i]*i%P; F = solve(1, m); for(int i = 0; i &lt;= s; ++i) ans = (ans+C(n+m-1, m-1+i)*F[i]%P)%P; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LGR-068]传染病研究]]></title>
    <url>%2F2020%2F02%2F07%2FLGR-068-%E4%BC%A0%E6%9F%93%E7%97%85%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[这道题做法很常规，考场上rush失败了QwQ 我们设 $d_{n,k}=\sum[d|n^k]$ 那么显然对于 $n$ 唯一分解后，$d_{n,k}=\prod_{i=1}^n(kc_i+1)$，$c_i$ 质因数的质数那么我们最后要求的答案必定为 $k$ 的多项式，且多项式的次数不超过 $8$，因为 $2\times3\times5\times7\times11\times13\times17\times19\times23&gt;1\times10^7$ 所以我们取 $k\in[0,8]$ 的值，其余值用拉格朗日插值插出来即可，对于前者，我们可以记录 $d_{n,k}$ 的值和最小质因数的指数用线筛来维护，对于后者，可以 $O(64logP)$ 也可以 $O(8)$ 常数很大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e7+5, P = 998244353;int t, n, k, py[N][9], d[N], vis[N], p[N], num[N];void solve(int n, int k)&#123; int tot = 0; py[1][k] = d[1] = 1; for(int i = 2; i &lt;= n; ++i) &#123; if(!vis[i]) p[++tot] = i, d[i]= k+1, num[i] = k; for(int j = 1; j &lt;= tot&amp;&amp;i*p[j] &lt;= n; ++j) &#123; vis[i*p[j]] = 1; if(i%p[j] == 0) d[i*p[j]] = d[i]/(num[i]+1)*(num[i]+k+1), num[i*p[j]] = num[i]+k, j = tot; else d[i*p[j]] = d[i]*d[p[j]], num[i*p[j]] = k; &#125; py[i][k] = (py[i-1][k]+d[i])%P, vis[i] = 0; &#125;&#125;int64 inv(int i) &#123; return i == 1?1:P-(P/i)*inv(P%i)%P; &#125;int lagrange(int n, int *y, int xi) &#123; int ans = 0; for (int i = 0; i &lt;= n; ++i) &#123; int s1 = 1, s2 = 1; for (int j = 0; j &lt;= n; ++j) if (i != j) &#123; s1 = 1ll*s1*(xi-j)%P; s2 = 1ll*s2*(i-j)%P; &#125; ans = (1ll*ans+1ll*y[i]*s1%P*inv(s2)%P)%P; &#125; return (ans+P)%P;&#125;int main()&#123; n = 1e7; for(int i = 1; i &lt;= n; ++i) py[i][0] = i; for(int i = 1; i &lt;= 8; ++i) solve(n, i); t = read(); while(t--) &#123; n = read(), k = read(); printf("%d\n", lagrange(8, py[n], k)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF1091E]New Year and the Acquaintance Estimation题解]]></title>
    <url>%2F2020%2F01%2F31%2FCF1091E-New-Year-and-the-Acquaintance-Estimation%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简单无向图的可视化，根据 Erdős–Gallai 定理将度数序列 $d$ 排序可得，若满足 $$\forall k\in[1,n],\sum_{i=1}^kd_k\le k\times(k-1)+\sum_{i=k+1}^n\min(k,d_i)$$且 $$\sum_{i=1}^nd_i\equiv0\ mod\ 2$$ 则序列可图，感性理解就是我们不断满足构成部分完全图的上界 稍加分析我们也可以发现，最后的答案是一个连续的序列简单证明就是若 $d_n=i$ 和 $d_n=j$ 都是可图的，那么我们可以删去两边增加一条边的方法递推得到中间的合法值 所以这道题再套上一个二分即可 二分是二分一个区间的左右端点，因此我们需要分清什么时候偏大，什么时候偏小 若 $i$ 时不满足条件，当 $mid\ge d_i$ 时，$mid$ 偏大，否则偏小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 5e5+5; int n, p, ansl, ansr, b[N], tax[N], a[N], l, r; int64 s[N];int valid(int mid)&#123; for(int i = 0; i &lt; n; ++i) tax[i] = 0; ++tax[mid]; for(int i = 1; i &lt; n; ++i) ++tax[b[i]]; for(int i = n-1, j = 0; ~i; --i) for(int k = 1; k &lt;= tax[i]; ++k) a[++j] = i; for(int i = 1; i &lt;= n; ++i) s[i] = s[i-1]+a[i]; for(int i = 1, j = n+1; i &lt; n; ++i) &#123; for(j = max(i+1, j); j &gt; i+1&amp;&amp;a[j-1] &lt;= i; --j); if(s[i] &gt; (j-1ll-i)*i+s[n]-s[j-1]+i*(i-1ll)) return a[i]&lt;=mid?-1:1; &#125; return 0;&#125;int main()&#123; n = read()+1; for(int i = 1; i &lt; n; ++i) b[i] = read(), p ^= b[i]&amp;1; l = 0, r = (n-1-p)&gt;&gt;1, ansr = -1; while(l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if(valid(mid&lt;&lt;1|p) == -1) r = mid-1; else l = mid+1, ansr = mid; &#125; l = 0, r = (n-1-p)&gt;&gt;1, ansl = -1; while(l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if(valid(mid&lt;&lt;1|p) == 1) l = mid+1; else r = mid-1, ansl = mid; &#125; if(ansl &gt; ansr||ansl == -1||ansr == -1) return puts("-1"), 0; for(int i = ansl; i &lt;= ansr; ++i) printf("%d ", i&lt;&lt;1|p); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[[CSGRound3]仙人掌]题解]]></title>
    <url>%2F2020%2F01%2F30%2FCSGRound3-%E4%BB%99%E4%BA%BA%E6%8E%8C-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这道题考完之后一直也没题解，蒟蒻就自己找了些资料，一知半解地写了这道题，主要参考 NERC2019 C.Cactus Revenge 和 Cactus graph realization of degree sequence，接下来的事情也主要复读这两个资料的 我们在之后的讨论中设度数序列为 $d$，图的点集大小为 $n$，边集大小为 $m$，首先有个很明显的性质即$$\sum_{i=1}^nd_i=2m$$ 首先考虑树的情况，树的情况很好猜，一个度数序能构成树的充要条件即 $$\sum_{i=1}^nd_i=2(n-1)\land \forall i,d_i\ge1$$ 考虑归纳证明，首先 $n=2$ 是 $d_1=d_2=1$ 两者互相连边即可，结论显然成立 对于 $n&gt;2$，若 $\forall i,d_i\ge2$，则 $\sum_{i=1}^nd_i\ge2n$ 所以一定有 j，满足 $d_j=1$，我们将 $j$ 与剩下任意一个 $k,d_k\ge2$ 连边，将 $d_j$ 和 $d_k$ 减 $1$，将 $j$ 删去，得到新的度数序 $d’$，那么由于 $d’$ 是可以构成树的，所以 $d$ 也可以 接着我们考虑边仙人掌的情况 我们任取图的一个生成树，每条非树边都仅代表一个环，所以环数 $c$ 显然满足$$ c=m-(n-1)\in[0,\lfloor\frac{n-1}{2}\rfloor]$$ 若度数都为偶数，分两种情况，都为 $2$ 时，我们只需要构成一个大环即可，否则我们其中一定存在相异的 $u$ 和 $v$ 满足 $d_u=d_v=2$（可以用树的反证法说明)，我们令 $u$ 和 $v$ 与另一个 $w,d_w\ge4$ 构成一个三元环，与树同理构造出 $d’$，这是 $d’$ 满足 $c-1\le\lfloor\frac{n-3}{2}\rfloor$，于是可以归纳证明 若度数不全为偶数，则显然奇数个数为偶数并且我们需要找到更强的约束条件，考虑割边的个数为 $b$，奇数个数为 $o$，叶子个数为 $l$，对于 $b$，满足 $b\ge\max(\frac{o}{2},l)$，所以对 $c$ 有更强的约束为 $$c\le\lfloor\frac{n-1-\max(\frac{o}{2},l)}{2}\rfloor\le\lfloor\frac{n-1-b}{2}\rfloor$$ 首先对于一些平凡的情况，若序列满足上述条件即可构造出仙人掌，对于剩下的分两种情况考虑当 $l\ge1$ 时我们从度数最大的点 $u$ 向叶子 $v$ 连边，构造出 $d’$ 这时 $d’$ 满足 $c\le\lfloor\frac{n-1-\max(\frac{o-1-k}{2},l-1)}{2}\rfloor,k\le1$ 成立，我们从度数最大的点 $u$ 向度数最小的 $v$ 和 $w$ 构成三元环，与上面同理可证成立 所以我们就得到判断度数序列是否可以构成仙人掌的条件 计数就很简单了，我们考虑枚举 $o$ 和 $l$，用组合数计算出不定方程$$\sum_{i=1}^nd_i=2m$$ 其中满足有 $o-l$ 个 $d_i$ 不小于 $3$ 且为奇数，$l$ 个 $d_i$ 为 $1$，$n-o$ 个 $d_i$ 为不小于 $2$ 且为偶数的解的方案数 这里我不太会用隔板法算，所以用生成函数暴力算很显然我们要求出的就是 $$[x^{2m-l}]\binom{n}{o}\binom{o}{l}(\frac{1}{1-x^2}-1)^{n-o}(\frac{x}{1-x^2}-x)^{o-l}$$ 将后面的多项式展开就不多赘述了 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 6e3+5, P = 998244353;int t, n, m, c; int64 C[N][N], ans;int main()&#123; for(int i = 0, n = 6e3; i &lt;= n; ++i) &#123; C[i][0] = 1; for(int j = 1; j &lt;= i; ++j) C[i][j] = (C[i-1][j-1]+C[i-1][j])%P; &#125; t = read(); while(t--) &#123; n = read(), m = read(), c = m-(n-1), ans = 0; if(0 &lt;= c&amp;&amp;c &lt;= (n-1)/2) for(int o = 0; o &lt;= n; o += 2) for(int l = 0; l &lt;= o; ++l) &#123; int b = max(o/2, l), i = (2*m-2*n-o+2*l)/2; if(c &lt;= (n-1-b)/2) ans = (ans+C[n][o]*C[o][l]%P*C[n-l+i-1][i]%P)%P; &#125; printf("%lld\n", ans); &#125; return 0;&#125; 这道题应该属于图的可视化问题，这类问题常用这样的归纳证明，欲了解更多可以参照Graph realization problem 或这道题 CF1091E]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一辈子都学不会的图论技巧]]></title>
    <url>%2F2019%2F11%2F08%2F%E4%B8%80%E8%BE%88%E5%AD%90%E9%83%BD%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E5%9B%BE%E8%AE%BA%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[树的直径树的直径具有许多优美的性质，我们将在以下几题探讨 最长性与对称性树上一个点与其对应最长简单路径的另一端点一定是直径的端点，即直径的最长性，除此之外，直径上会存在中点，具有很好的对称性 [SDOI2011]消防我们找出树的直径 $\Gamma$ 则根据题意列出式子 $$\min\lbrace \max_{p_{u,v}\subseteq\Gamma,d_{u,v}\ge s}\lbrace \max_{i\in p}\lbrace f_i\rbrace,d_{u,\Gamma},d_{v,\Gamma}\rbrace\rbrace$$ 其中 $f_i$ 表示不经过树的直径的最长长度，根据树的直径的最长性$$\max_{i\notin p,i\in\Gamma}\lbrace f_i\rbrace\le\min\lbrace d_{u,\Gamma},d_{v,\Gamma}\rbrace$$ 所以中间部分可以修改上界，那么这道题直接用双指针维护即可 [AGC005C]Tree Restoring最大值一定为直径，最小值一定为树的半径，根据直径奇偶性就可以确定最小值个数，再根据非半径路径的对称性判断即可 [AGC001C]Shorten Diameter枚举树的直径的中心，贪心构造即可 直径的合并当合并两个联通块是，新的树的直径一定产生于原先两个树的直径的四个端点之中，当未指定合并方式时就可以通过控制连接点来构造我们想要的直径 [雅礼集训 2017 Day5]远行动态维护树的直径的裸题，用 LCT 维护树上距离即可，不会 LCT 可以考虑启发式合并与倍增 [TJOI2017]城市枚举断边，再重新连接两个直径的中点即可求出新树中的最小半径 多直径这类问题通常会要求我们求出若干条边不相交或点不相交的链使得和最大 [APIO2010]巡逻这道题很明显要找出两条不相交的链使得其和最大，由于边权都为 $1$ 所以我们可以先求一边树的直径，再将直径上的边赋值为 $-1$ 再求一遍树的直径就可以处理出合法的贡献 [51NOD]树的双直径这道题依旧是两条直径，但边权为整数，所以考虑改进求树的直径的 DP，维护每个点子树内外的最长链，最长直链，次长直链换根 DP 即可，注意让乘积最大，且边权有负数，所以还要维护最小值和次小值 [八省联考2018]林克卡特树lct思考题，不作要求，要选出 $k$ 条直径，只能考虑直径的形态并用背包维护了，最后能发现凸性，用 WQS 二分即可 树的重心树的重心有很多好看的特性，我们将在以下几题探讨 折半性与极少性根据树的重心定义，树的重心是树上所有点在其被出去后使剩下联通块最大值最小的点，很明显这个最大值最小值小于整棵树大小的一半，点分治就是利用这一原理简化复杂度 并且，树的重心很少，最多不超过 $2$ 个，无根树哈希以及无根无编号树的计数问题就利用了这个特性 [AGC018]Tree and Hamilton Path根据贪心问题的套路，我们盲猜一波答案的上界，单独考虑每条边的贡献，我们让每条边利用充分，则贡献为 $$\min(x,\ y)\times w$$ 其中 $x$ 和 $y$ 是断掉这条边后树变成的两个联通块的大小 考虑什么时候答案可以达到上界，我们注意到当树存在双重心时，我们让两个重心连边断开后剩下的两个联通块互相配对即可达到上界，这启发我们找到合适的边或点断开，使剩下联通块配对即可，根据集合配对的结论，配对集合的最大值不超过总大小的一半即可完成配对，所以我们找到重心即可，注意这是路径，所以最后需要减去一条边的贡献 [CF1182D]Complete Mirror可以发现若选择的点度数大于 $2$ 必定是树的重心，否则以这个点为根时，各个子树大小都不平均，要么一定位于重心所在的长链上，画图很好证明，所以重心也暗含对称性 我们也可用同样具有对称性的直径或树哈希解决此问题，细节留给读者思考 带权重心我们还可以定义重心为满足所有点到它距离和最小的点为树的重心，观察换根 DP 方程的转移，可以很明显发现这个定义与之前定义等价，当存在边权或点权，我们将重心扩展为带权重心 [ZJOI2015]幻想乡战略游戏思考题由于没有找到在联赛范围的题，动态维护带权重心，利用线段树在点分树上二分即可 重心的移动当两个联通块合并时，树的重心一定位于原来两个联通块重心的连线上，结合带权重心的定义理解，若可以往外移动，则在未合并前就已经移动了 [LG4299] 首都合并时用 LCT 抽出连线，在 Splay 上二分移动即可 树的遍历序树的遍历序可以转化树上问题为序列上的偏序问题 DFS 序DFS 序最直接的利用应该就是重链剖分中把树转化为序列问题，和虚树中的利用，其中对应的实质是 DFS 序使子树连续，以及它的子序列所对应的联通块极大的性质 [SDOI2015]寻宝游戏用 set 动态维护 DFS 序子序列，就可以维护极大联通块 [CF1225F]Tree Factory很明显最后要求的就是树的一个 DFS 序，那么 dfn 中的第 $i$ 个点贡献为 $d_{dfn_{i-1}}-d_{fa_{dfn_i}}$ 显然最后走长链即可 BFS 序BFS 序不经常使用，最基础的一个性质是相邻两个节点要么为兄弟要么为父亲，且位于深度之差小于 $1$，可以在某些题优化做法 [CF893F]Subtree Minimum Query以 BFS 序为时间做可持久化线段树，维护 DFS 序信息，支持询问区间最值即可 树上统计信息对具有区间可减性的树上信息可以通过前缀和和差分高效维护，也可以通过考虑每条边或点的贡献高效统计 差分我们类比序列的差分，可以看出树也可以差分性质，树链(u, v) 的点权加即在 u 和 v添加贡献，fa[lca(u, v)] 和 lca(u, v) 减去贡献 [LGP1600]天天爱跑步考虑每个点会被哪些路径产生贡献，显然对于路径 (u, v) 上行部分满足 $d_u=d_i+w_i$ 下行满足 $d_{u,v}-d_v=w_i-d_i$ 会产生贡献，树上差分用桶统计即可 前缀和类比序列的前缀和，我们也可以维护每个点到根的信息和 [AGC014]Unplanned Queries很明显我们只关注奇偶性，对每条链的统计实际上通过反向考虑前缀和等价于链的每个端点到根的奇偶性，在这个意义下树的形态就不重要了，所以随便找一种判断即可 贡献单独考虑[HAOI2015]树上染色题干中要求统计树上点对两两之间的距离所以很套路的就可以考虑每条边的贡献为两边黑点和白点数量的乘积，直接树上背包就好了 [HAOI2018]苹果树同样是是求距离之和，所以我们只需要把大小作为状态转移即可，和这道题类似的计数题还有 [CF855G]Harry Vs Voldemort 需要大力分类讨论 和 [WC2019]数树 需要大力推式子 [AGC005]Many Easy Problems求大小之和，很自然地想到每个点会被多少个联通块算到，不妨设联通块大小为 $k$，删去一个点后剩下地联通块集合为 $S$ 则贡献为 $$\binom{n}{k}-\sum_{s\in S}\binom{s}{k}$$ 直接统计复杂度为 $O(n^2)$ 所以还要搞一下答案生成函数，用 NTT 即可解决 图论建模一些人类智慧题可以通过建立图论模型解决 欧拉路感觉自己就没做出来过欧拉路的题 [AGC017]Jigsaw当我们发现以每个积木作为点建图很难搞，考虑把积木当作边，对于每个积木而言左边若 $c=0$ 则当作编号为 $a$ 的点，否则为 $-c$，右边而言若 $d=0$ 则当作编号为 $-b$ 的点，否则为 $d$，积木本身作为连接两点的边，现在题目等价于求若干条不边相交的路径覆盖图的问题，且对于每条路径而言必须从编号为正的路径开始，编号为负的路径结束，所以编号为正的路径的出度必须大于等于入度，标号为负的路径入度必须大于出度，且对于每一个联通块而言入度和出度不能相等 二分图这里重点强调的是二分的匹配问题 [AGC018]Two Trees首先一个很明显的事实是，对于两棵树而言，若两个标号相同的点，他们子节点个数奇偶性必然相同，否则一定无解，接着我们考虑构造方案，首先我们把子节点个数为偶数的点的值赋值为零，其他节点赋值为 $1$ 或 $-1$，那么每颗子树一定有 $2k+1$ 个奇数点，我们把这些节点自底向上两两配对，不能配的上传到父亲，配对关系可以建图，这样每个点的度数为 $2$ 并且一条是在树 A 产生的边，另一条是在树 B 产生的边，一个点只有两者交替才能回到自己，所以图为二分图，可以产生匹配方案 有向无环图一般在字典序问题或排列问题起到作用 [AGC010]Rearranging互质的数不会交换，先后顺序不变，所以将互质的数之间连边，那么先手操作为给边定向，后手操作为求 DAG 的最大字典序，两遍贪心即可 [AGC001]Wide Swap首先题干中的条件有点复杂，我们不妨把排列的下标和值互换，这样最后求出字典序最小与原问题等价，发现这样题干中的交换条件就变为交换差值超过 $k$ 相邻两个数，那么差值不超过 $k$ 的一定不会交换，和上一题一样又转变为 DAG 字典序最小拓扑序问题，但这是 $O(n^2)$ 的建边，所以考虑优化，最终发现只需要向里当前点最近的连边即可 最小生成树最小生成树我自己也不太会啊 QAQ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LGR-060D1] 小猪佩奇学数学]]></title>
    <url>%2F2019%2F10%2F13%2FLGR-060D1-%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87%E5%AD%A6%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[考试时多项式推错惨遭爆零 首先，这道题很明显式子是一个二项卷积，考虑 EGF 不妨设 $$f=\sum_np^n\lfloor\frac{n}{k}\rfloor\frac{x^n}{n!}$$则答案为 $$[x^n]e^x\times f$$ 现在考虑 $f$ 如何求出 由于 EGF 的移位和指标下放很好实现，所以考虑多项式 $$\hat{f}_n=\sum_i[n|i]\frac{x^i}{i!}$$ 显然 $\hat{f}_2$ 很好求出，即为 $$\hat{f}_2=\frac{e^x+e^{-x}}{2}$$ 这也启发我们 $\hat{f}_n$ 可以用若干个形如 $e^{kx}$ 组合出 于是我们想到了单位根，即 $$w_n^{in}=1$$ 对于 $w_n^i$ 而言，有 $$\frac{1}{n}\sum_{k=0}^{n-1}w_n^{ik}=[i=0]$$ 那么可以得出 $$\hat{f_n}=\frac{1}{n}\sum_{i=0}^{n-1}e^{w_n^ix}$$ 同时根据 EGF 的性质 $$\frac{\partial\hat{f}_n}{\partial x^k}=\sum_i[n|(i+k)]\frac{x^i}{i!}$$ 乘上 $\frac{x}{n}$ 就有 $$\frac{x}{n}\times\frac{\partial\hat{f}_n}{\partial x^k}=\sum_i[n|(i+k-1)]\frac{i}{n}\frac{x^i}{i!}$$ 结合之前就有 $$\frac{x}{n}\times\frac{\partial\hat{f}_n}{\partial x^k}+\frac{k-1}{n}\times\frac{\partial\hat{f}_n}{\partial x^{k-1}}=\sum_i[n|(i+k-1)]\lceil\frac{i}{n}\rceil\frac{x^i}{i!}$$ 所以当 $k\ge2$ 时 $$\frac{x}{n}\times\frac{\partial\hat{f}_n}{\partial x^k}+\frac{k-1}{n}\times\frac{\partial\hat{f}_n}{\partial x^{k-1}}-\frac{\partial\hat{f}_n}{\partial x^{k-1}}=\sum_i[n|(i+k-1)]\lfloor\frac{i}{n}\rfloor\frac{x^i}{i!}$$ 综上讨论 $$f=\sum_{k=1}^n\frac{x}{n}\times\frac{\partial\hat{f_n}}{\partial x^k}+\sum_{k=1}^n\frac{k-1}{n}\times\frac{\partial\hat{f_n}}{\partial x^{k-1}}-\sum_{k=2}^n\frac{\partial\hat{f_n}}{\partial x^{k-1}}$$ 而对于 $\frac{\partial\hat{f_n}}{\partial x^k}$ 有 $$\frac{\partial\hat{f_n}}{\partial x^k}=\frac{1}{n}\sum_{i=0}^{n-1}w_n^{ik}e^{w_n^ix}$$ 根据交换求和式的技巧我们可以把式子简化为只有一个和式而无嵌套情况，以中间的和式为例 $$\sum_{k=1}^n\frac{k-1}{n}\times\frac{\partial\hat{f_n}}{\partial x^{k-1}}=\frac{1}{n^2}\sum_{i=0}^{n-1}\sum_{k=1}^n(k-1)\times w_n^{i(k-1)}e^{w_n^ix}$$ 根据 $$\sum_{i=1}^nix^{i-1}=\frac{nx^{n+1}-nx^n-x^n+1}{(x-1)^2}$$ 上面的式子可以化简为 $$\sum_{i=1}^{n-1}\frac{1}{n\times(w_n^i-1)}e^{w_n^ix}+\frac{n-1}{2\times n}e^x$$ 其他同理 最后的问题只有单位根怎么求了，由于 $998244353$ 为 NTT 质数，所以 $2^k$ 的单位根就可以表示为 $3^{\frac{P-1}{2^k}}$ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;bitset&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int P = 998244353;int64 qpow(int64 a, int b)&#123; int64 ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%P) if(b&amp;1) ret = a*ret%P; return ret;&#125;int64 n, inv, inv2, p;int ans, k;int main()&#123; n = read(), p = read(), k = read(); inv = qpow(k, P-2); ans = n*p%P*qpow(p+1, n-1)%P*inv%P; ans = (ans+(k-1)*qpow(2*k, P-2)%P*qpow(p+1, n)%P)%P; ans = (ans+P-qpow(p+1, n))%P; for(int i = 1, wn = qpow(3, (P-1)/k), w = wn; i &lt; k; ++i, w = 1ll*w*wn%P) ans = (ans+qpow(w-1, P-2)*inv%P*qpow(w*p%P+1, n)%P)%P; for(int i = 0, w = 1, wn = qpow(3, (P-1)/k); i &lt; k; ++i, w = 1ll*w*wn%P) ans = (ans+inv*qpow(w*p%P+1, n)%P)%P; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[WC2019] 数树]]></title>
    <url>%2F2019%2F10%2F09%2FWC2019-%E6%95%B0%E6%A0%91%2F</url>
    <content type="text"><![CDATA[时隔 $9$ 个月，终于肝出这题了 设恰好有 $i$ 条边不重复的方案数为 $f_i$ $$f_i = \sum_{|E|=i}\sum_{E’\subseteq E}(-1)^{i-|E’|}n^{|E’|-1}\prod_{S=C(E’)}s$$交换求和次序得 $$f_i = \sum_{E’}(-1)^{i-|E’|}n^{|E’|-1}\prod_{S=C(E’)}s\sum_{|E|=i,E’\subseteq E}$$ 化简得 $$f_i = \sum_{E’}(-1)^{i-|E’|}n^{|E’|-1}\prod_{S=C(E’)}s\binom{n-1-|E’|}{i-|E’|}$$ 记 $$\mathcal{F_i}=\sum_{|E|=i}\prod_{S=C(E)}s$$ 则有 $$f_i = \sum_{j=0}^i(-1)^{i-j}n^{j-1}\binom{n-1-j}{i-j}\mathcal{F_j}$$ 答案为 $$\sum_{i=0}^{n-1}\sum_{j=0}^i(-1)^{i-j}n^{j-1}\binom{n-1-j}{i-j}\mathcal{F_j}y^i$$ 交换求和次序得 $$\sum_{j=0}^{n-1}n^{j-1}\mathcal{F_j}\sum_{i=j}^{n-1}(-1)^{i-j}\binom{n-1-j}{i-j}y^{i+1}$$ 化简为 $$\sum_{j=0}^{n-1}n^{j-1}\mathcal{F_j}\sum_{i=0}^{n-1-j}y^{i+j+1}(-1)^{i}\binom{n-1-j}{i}$$ 用二项式定理化简得 $$\sum_{j=0}^{n-1}n^{j-1}y^{j+1}(1-y)^{n-1-j}\mathcal{F_j}$$ 代入得 $$\sum_{j=0}^{n-1}n^{j-1}y^{j+1}(1-y)^{n-1-j}\sum_{|E|=j}\prod_{S=C(E)}s$$ 那么有 $$\frac{(1-y)^n}{n^2}\sum_{j=0}^{n-1}n^{j+1}(\frac{y}{1-y})^{j+1}\sum_{|E|=j}\prod_{S=C(E)}s$$ 进一步得 $$\frac{(1-y)^{n}}{n^2}\sum_{E}\prod_{S=C(E)}\frac{ny}{1-y}s$$ 后面部分可以使用背包完成，时间复杂度为 $O(n^2)$ 设 $f_n$ 为该联通块根节点所在联通块大小为 $n$ 的方案数，$k=\frac{1-y}{ny}$ 则在合并两个联通块时有 $$h_n=k\sum_{i=0}^nf_ig_{n-i}(\frac{1}{i}+\frac{1}{n-i})+f_n\sum_{i=0}^Ng_i$$ 注意到我们最后只需关注 $\sum_{i=0}^Nf_i$ 并结合母函数的技巧启发我们考虑幂级数 $$f(x)=\sum_{i=0}^Nf_ix^i$$ 最后答案即为 $f(1)$ 那么套在 DP 上就有 $$\sum_{n=0}^Nh_nx^n=k\sum_{n=0}^N\sum_{i=0}^nf_ig_{n-i}(\frac{1}{i}+\frac{1}{n-i})x^n+\sum_{n=0}^Nf_n\sum_{i=0}^Ng_ix^n$$ 化简为 $$h(x)=k((\sum_{i=0}^n\frac{f_n}{n}x^n)g(x)+(\sum_{i=0}^n\frac{g_n}{n}x^n)f(x))+g(1)f(x)$$ 考虑函数 $$\hat{f}(x)=\sum_{i=0}^n\frac{f_i}{i}x^i$$ 则有 $$h(x)=k(\hat{f}(x)g(x)+\hat{g}(x)f(x))+f(x)g(1)$$ 令 $x=1$ 得到 $$h(1)=k(\hat{f}(1)g(1)+\hat{g}(1)f(1))+f(1)g(1)$$ 考虑 $\hat{f}(x)$ 的求法 $$\sum_{n=0}^N\frac{h_n}{n}x^n=k\sum_{n=0}^N\frac{1}{n}\sum_{i=0}^nf_ig_{n-i}(\frac{1}{i}+\frac{1}{n-i})x^n+\sum_{n=0}^N\frac{f_n}{n}\sum_{i=0}^Ng_ix^n$$ 化简为 $$\hat{h}(x)=k\hat{f}(x)\hat{g}(x)+\hat{f}(x)g(1)$$ 同样 $$\hat{h}(1)=k\hat{f}(1)\hat{g}(1)+\hat{f}(1)g(1)$$ 这样我们就得到了 $O(n)$ 的 DP 考虑 op3 的做法，答案为 $$\sum_{T}\frac{(1-y)^{n}}{n^2}\sum_{E\subseteq T}\prod_{S=C(E)}\frac{ny}{1-y}s$$ 用 prufer 序列枚举联通块得 $$\frac{(1-y)^{n}}{n^4}\sum_{\sum_{i=1}^ms_i=n}\frac{1}{m!}\frac{n!}{\prod_{i=1}^ms_i!}\prod_{i=1}^ms_i^{s_i-2}\prod_{i=1}^m\frac{n^2y}{1-y}{s_i}^2$$ 考后面部分的 EGF 得，并设 $w=\frac{n^2y}{1-y}$ $$[x^n]f=\sum_{\sum_{i=1}^ms_i=n}\frac{1}{m!}\prod_{i=1}^m\frac{ws_i^{s_i}}{s_i!}$$ 这启发我们考虑函数 $g=\sum_{i}w\frac{i^i}{i!}x^i$ 带入有 $$f=\sum_m\frac{g^m}{m!}$$ 用等比数列求和化简得 $$f=e^g$$ 最终答案即为 $$\frac{n!(1-y)^{n}}{n^4}[x^n]f$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;typedef long long int64;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 8e5+5, P = 998244353;int n, y, op, ans;int64 qpow(int64 a, int b)&#123; int64 ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%P) if(b&amp;1) ret = a*ret%P; return ret;&#125;namespace solve0&#123;map&lt;pair&lt;int, int&gt;, int&gt; rec;void sol()&#123; for(int i = 2; i &lt;= n; ++i) &#123; int x = read(), y = read(); if(x &gt; y) swap(x, y); ++rec[make_pair(x, y)]; &#125; for(int i = 2; i &lt;= n; ++i) &#123; int x = read(), y = read(); if(x &gt; y) swap(x, y); ans += rec[make_pair(x, y)]; &#125; ans = qpow(y, n-ans);&#125;&#125;namespace solve1&#123;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N&lt;&lt;1];int head[N], tot;void _add(int x, int y) &#123; edge[++tot] = Edge(head[x], y), head[x] = tot; &#125;void add(int x, int y) &#123; _add(x, y), _add(y, x); &#125;int f[N], g[N], inv[N], w, invw;void dfs(int x, int fa)&#123; f[x] = g[x] = w; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(y == fa) continue; dfs(y, x); f[x] = ((1ll*g[x]*f[y]%P+1ll*f[x]*g[y]%P)%P*invw%P+1ll*f[x]*f[y]%P)%P; g[x] = (1ll*g[y]*invw%P+f[y])%P*g[x]%P; &#125;&#125;void sol()&#123; if(y == 1) return ans = qpow(n, n-2)%P, void(0); else inv[1] = 1, w = 1ll*n*y%P*qpow(P+1-y, P-2)%P, invw = qpow(w, P-2); for(int i = 2; i &lt;= n; ++i) &#123; int x = read(), y = read(); add(x, y), inv[i] = P-1ll*(P/i)*inv[P%i]%P; &#125; dfs(1, 0); ans = f[1]*qpow(P+1-y, n)%P*inv[n]%P*inv[n]%P;&#125;&#125;namespace solve2&#123;struct Poly&#123; vector&lt;int&gt; _; inline int&amp; operator [] (int i) &#123; return _[i]; &#125; inline int ti() &#123; return _.size()-1; &#125; inline void set(int ti) &#123; _.resize(ti+1); &#125;&#125;F;int64 w[2][N], inv[N], ifac[N], fac[N], k;int lim;void prepare(int ti)&#123; for(lim = 1; lim &lt;= ti; lim &lt;&lt;= 1); w[0][0] = w[0][lim] = w[1][0] = w[1][lim] = 1; int64 g = qpow(3, (P-1)/lim); for(int i = 1; i &lt; lim; ++i) w[1][lim-i] = w[0][i] = w[0][i-1]*g%P;&#125;void NTT(Poly &amp;A, int t)&#123; if(!t) A.set(lim-1); for(int i = 0, j = 0; i &lt; lim; ++i) &#123; if(i &gt; j) A[i] ^= A[j] ^= A[i] ^= A[j]; for(int k = lim&gt;&gt;1; (j ^= k) &lt; k; k &gt;&gt;= 1); &#125; for(int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) for(int len = mid&lt;&lt;1, j = 0; j &lt; lim; j += len) for(int k = 0, p = 0, q = lim/len; k &lt; mid; ++k, p += q) &#123; int64 x = A[j+k], y = w[t][p]*A[j+k+mid]%P; A[j+k] = x+y&lt;P?x+y:x+y-P; A[j+k+mid] = x-y&lt;0?x-y+P:x-y; &#125; if(!t) return; int64 v = inv[lim]; for(int i = 0; i &lt; lim; ++i) A[i] = A[i]*v%P;&#125;Poly operator * (Poly A, Poly B)&#123; int n = A.ti(), m = B.ti(); prepare(n+m); NTT(A, 0), NTT(B, 0); for(int i = 0; i &lt; lim; ++i) A[i] = 1ll*A[i]*B[i]%P; NTT(A, 1); A.set(n+m); return A;&#125;Poly operator - (Poly A, Poly B)&#123; int n = A.ti(), m = B.ti(); A.set(max(n, m)); for(int i = 0; i &lt;= m; ++i) A[i] = A[i]-B[i]&lt;0?A[i]-B[i]+P:A[i]-B[i]; return A;&#125;Poly polyInv(Poly A, int n)&#123; Poly B; B.set(n-1), A.set(n-1); if(n == 1) return B[0] = qpow(A[0], P-2), B; B = polyInv(A, (n+1)&gt;&gt;1), prepare(n&lt;&lt;1); NTT(B, 0), NTT(A, 0); for(int i = 0; i &lt; lim; ++i) B[i] = (2ll-1ll*A[i]*B[i]%P+P)%P*B[i]%P; NTT(B, 1), B.set(n-1); return B;&#125;Poly polyDer(Poly A, int n)&#123; for(int i = 0; i &lt; n-1; ++i) A[i] = 1ll*(i+1)*A[i+1]%P; A[n-1] = 0; return A;&#125;Poly polyInte(Poly A, int n)&#123; for(int i = n-1; i; --i) A[i] = inv[i]*A[i-1]%P; A[0] = 0; return A;&#125;Poly polyLn(Poly A, int n) &#123; return polyInte(polyDer(A, n)*polyInv(A, n), n); &#125;Poly polyExp(Poly A, int n)&#123; Poly B; B.set(n-1), A.set(n-1); if(n == 1) return B[0] = 1, B; B = polyExp(A, (n+1)&gt;&gt;1), B.set(n-1), ++A[0]; B = B*(A-polyLn(B, n)); B.set(n-1); return B;&#125;void sol()&#123; if(y == 1) return ans = qpow(1ll*n*n%P, n-2), void(0); fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1, k = y*qpow(P+1-y, P-2)%P*n%P*n%P, F.set(n); for(int i = 2; i &lt;= n&lt;&lt;3; ++i) inv[i] = P-(P/i)*inv[P%i]%P, fac[i] = fac[i-1]*i%P, ifac[i] = ifac[i-1]*inv[i]%P; for(int i = 1; i &lt;= n; ++i) F[i] = k*qpow(i, i)%P*ifac[i]%P; F = polyExp(F, n+1), ans = F[n]*qpow(P+1-y, n)%P*qpow(inv[n], 4)%P*fac[n]%P;&#125;&#125;int main()&#123; n = read(), y = read(), op = read(); if(op == 0) solve0::sol(); else if(op == 1) solve1::sol(); else solve2::sol(); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[50809102 NOIP模拟题]]></title>
    <url>%2F2019%2F08%2F05%2F50809102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[a 给定程序，求程序地期望运行结果 考虑一个长度为 $n$ 地排列，其逆序对数地期望为 $\frac{\binom{n}{2}}{2}$，由此，不妨设 $f_n$ 为长度为 $n$ 的排列期望运行结果，则有 $$f_n\ =\ \frac{n(n-1)}{4}+\frac{1}{2^n}\sum_{i=0}^n\binom{n}{i}f_i$$这时候可以移项得到一个 $O(n^2)$ 的 $DP$ 方程，但是我们考虑求出 $f_n$ 的通项，将组合数拆开有 $$\frac{f_n}{n!}\ =\ \frac{n(n-1)}{4}\times\frac{1}{n!}+\frac{1}{2^n}\sum_{i=0}^n\frac{1}{(n-i)!}\frac{f_i}{i!}$$ 不妨设 $&lt;f_0,f_1,f_2…&gt;$ 的 $egf$ 为 $f$，$&lt;0,0,2,6…&gt;$ 的 $egf$ 为 $g$ 则有 $$f(x)\ =\ \frac{1}{4}g(x)+e^{\frac{x}{2}}f(\frac{x}{2})$$ 根据 $EGF$ 性质 $$x^me^x\ =\ \sum_n[n\ge m]n^{\underline{m}}\frac{x^n}{n!}$$ 可以得到 $g\ =\ x^2e^x$ 盲猜一波如果方程成立，那么解一定为 $cx^2e^x$ 的形式，解出 $c=\frac{1}{3}$，则 $f_n=\frac{n(n-1)}{3}$ 那么答案为 $$\frac{1}{n}\sum_{i=1}^nf_i=\frac{1}{3n}\times[\frac{n(n+1)(2n+1)}{6}-\frac{n(n+1)}{2}]=\frac{n^2-1}{9}$$ 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;typedef long long int64;const int P = 998244353;int64 qpow(int64 a, int b)&#123; int64 ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%P) if(b&amp;1) ret = ret*a%P; return ret;&#125;int n;int main()&#123; freopen("a.in", "r", stdin); freopen("a.out", "w", stdout); scanf("%d", &amp;n); printf("%lld\n", (n*n-1)*qpow(9, P-2)%P); return 0;&#125; c 给定一颗树，已知 $s$ 和 $t$， 求 $s$ 到 $t$ 按题意要求游走的最坏情况下的最小花费 首先考虑 $s$ 和 $t$ 直接相连的情况，此时最坏的情况一定出现在以 $t$ 为根，$s$ 的子树内，先分类讨论，如果节点 $x$ 为叶子节点，那么它的代价为从 $s$ 到该节点再到 $t$ 的最小花费，最小花费由两部分组成，首先是保证可以到达该节点，并在该节点停在直到删边后满足 $x$ 到 $t$ 有唯一通路，即 $x$ 到 $t$ 除 $t$ 以外的路径上每个点的子节点数减 $1$，其次保证从这个节点可以回到 $s$节点，那么这一部分代价为 $dis(x,\ s)$，如果 $x$ 为非叶节点，那么在这个节点时，最优解一定为先删掉代价最大子节点对应的边，所以这个节点的代价为子节点中的次大代价，同时如果这个节点无次大值，那么可以额外耗费 $1$ 的花费使它变为叶子 之后考虑 $s$ 和 $t$ 不直接相连的情况，注意这是 $s$ 若一开始就向 $t$ 的方向随机游走可能情况会变得更差，所以我们最后的最小花费应不超过从 $s$ 向 $t$ 方向游走过程中的最坏情况的最优花费，答案具有单调性，考虑二分值为 $mid$，定义每个节点的代价 $f$ 为由离着个点最近的 $s$ 到 $t$ 的节点出发再走到 $t$ 的最小花费，判断 $mid$ 是否合法则模拟从 $s$ 向 $t$ 方向游走的过程，设当前枚举的路径上的点为 $u$，其不在路径上的子节点为 $v$，游走过程中由于需要满足最坏情况不超过 $mid$，则需要删除一些边，即枚举过程中删除的边为 $del$，则当 $f_v-[u=s]+del&gt;mid$ 时需要删除 $(u,\ v)$ 这条边，前面的减 $[u=s]$ 时由于这个点就是由 $s$ 向上游走来的，而在 $f_v$ 中计算了删边的贡献，所以要减去，最后设当前枚举的 $u$ 时 $s$ 到 $t$ 的第 $i$ 个点，则它有 $i$ 次删除额外边的机会，依此来判断 $mid$ 是否合法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e6+5;struct Edge&#123; int next, to, w; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N&lt;&lt;1];int tot, head[N];void _add(int x, int y) &#123; edge[++tot] = Edge(head[x], y), head[x] = tot; &#125;void add(int x, int y) &#123; _add(x, y), _add(y, x); &#125;int n, m, s, t, in[N], d[N], f[N], g[N], fa[N], c[N], ans;void dfs(int x)&#123; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(y == fa[x]) continue; fa[y] = x, d[y] = d[x]+1, dfs(y); &#125;&#125;void solve(int x, int topf, int c)&#123; if(in[x]) topf = x; int m = 0; for(int i = head[x]; i; i = edge[i].next) m += edge[i].to != fa[x]; c += m?m-1:0, m = 0; for(int i = head[x], y; i; i = edge[i].next) if((y = edge[i].to) != fa[x]) solve(y, topf, c); for(int i = head[x], y; i; i = edge[i].next) if((y = edge[i].to) != fa[x]) g[++m] = f[y]; sort(g+1, g+1+m), m &lt;= 1?f[x] = m+d[x]-d[topf]+c:f[x] = g[m-1];&#125;vector&lt;int&gt; val[N];bool valid(int mid)&#123; for(int i = 1, del = 0; i &lt;= m; ++i) &#123; vector&lt;int&gt; &amp;w = val[i]; for(int k = 0; k &lt; w.size(); ++k) del += w[k]-(i != 1)+del &gt; mid; if(del &gt; i) return false; &#125; return true;&#125;int main()&#123; freopen("c.in","r",stdin); freopen("c.out","w",stdout); n = read(), t = read(), s = read(); for(int i = 1, x, y; i &lt; n; ++i) x = read(), y = read(), add(x, y); dfs(t); for(int x = s; x != t; x = fa[x]) in[x] = 1; for(int i = head[t]; i; i = edge[i].next) solve(edge[i].to, t, 0); for(int x = s; x != t; x = fa[x]) &#123; vector&lt;int&gt; &amp;w = val[++m]; for(int i = head[x], y; i; i = edge[i].next) if(!in[y = edge[i].to]) w.push_back(f[y]); sort(w.begin(), w.end()); &#125; int l = f[s], r = n&lt;&lt;1; while(l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if(valid(mid)) ans = mid, r = mid-1; else l = mid+1; &#125; printf("%d\n", f[s]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>贪心</tag>
        <tag>思维</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10809102 AGC006]]></title>
    <url>%2F2019%2F08%2F02%2F10809102-AGC006%2F</url>
    <content type="text"><![CDATA[Median Pyramid Easy 给定一个数字三角形，最底下一层的值为一个长度为 $2n-1$ 排列，其余方格中填写的整数是方格正下方,左下方和右下方方格中所写整数的中位数，给定 $n$ 和 $x$ 求最终构造出三角形顶端为 $x$ 的方案 一开始想的是每一层的值比下一层的值少了下一层的最大值和最小值以及满足比周围 $4$ 个方格的树都小或都大的数，所以我们需要要计算好中位数偏移量，将左侧每 $3$ 个数将需要删除的数移进去即可，得到的结论是 $|n-x|\le\lfloor\frac{n}{3}\rfloor$ 时 $x$ 可以构造出来，这个构造意外的骗了很多分然而，正确的结论是 $x$ 可以为 $1$ 或 $2n-1$ 的任何数，我们可以发现当最倒数第二层出现两个相邻的相同数字时，这两个数字会一直向上沿伸，最后的答案为里对称轴最近的满足上述条件的数字 1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 2e5+5;int n, x, q, ans;int p[N], vis[N];int main()&#123; scanf("%d%d", &amp;n, &amp;x); if(x == 1||x == 2*n-1) return puts("No"), 0; puts("Yes"); p[n] = x, p[n-1] = x == 2?x+1:x-1, p[n+1] = x == 2?x-1:x+1, p[n+2] = x == 2?x+2:x-2; vis[x] = vis[x+1] = vis[x-1] = vis[x == 2?x+2:x-2] = 1; for(int i = 1, j = 1; i &lt;= 2*n-1; ++i) &#123; if(p[i]) continue; while(vis[j]) ++j; p[i] = j, vis[j] = 1; &#125; for(int i = 1; i &lt;= 2*n-1; ++i) printf("%d ", p[i]); return 0;&#125; Rabbit Exercise 有 $n$ 只兔子站在数轴上，第 $i$ 只兔子的初始位置为 $a_i$，现在这些兔子会按照下面的规则做若干次移动，每一次$m$ 次跳跃组成，在第 $j$次跳跃的时候，第 $c_j$ 只兔子会等概率随机选择第 $c_j-1$ 和 $c_j+1$ 只兔子中的一只跳到对称点，求 $k$ 次动作之后，每一只兔子最终位置坐标的期望值 首先暴力的 $DP$ 方程很好写，$f’_{c_i}=\frac{2f_{c_i-1}+2f_{c_i+1}-2f_{c_i}}{2}=f_{c_i-1}+f_{c_i+1}-f_{c_i}$ 然而，复杂度为 $O(mk)$，遇到转移问题发现难以转移就想一想差分，考虑 $d_i\ =\ f_i-f_{i-1}$ 那么差分后的转移就变为 $$d’_{c_i}=f’_{c_i}-f_{c_i-1}=f_{c_i+1}-f_{c_i}=d_{c_i+1}$$ $$d’_{c_i+1}=f_{c_i+1}-f’_{c_i}=f_{c_i}-f_{c_i-1}=d_{c_i}$$ 发现正好是两者交换了位置，那么我们只有扫一遍操作序列，求出循环节，就可以快速求了 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;typedef long long int64;using namespace std;inline int64 read(int f = 1, int64 x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e5+5;int n, m, a[N], f[N], s[N], top, vis[N];int64 ans[N], k;int main()&#123; n = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read(); for(int i = n; i; --i) a[i] -= a[i-1], f[i] = i; m = read(), k = read(); for(int i = 1, p; i &lt;= m; ++i) p = read(), swap(f[p], f[p+1]); for(int i = 1; i &lt;= n; ++i, top = 0) if(!vis[i]) &#123; for(int j = i; !vis[j]; j = f[j]) vis[j] = 1, s[++top] = j; for(int j = 1; j &lt;= top; ++j) ans[s[j]] = a[s[(j+k-1)%top+1]]; &#125; for(int i = 1; i &lt;= n; ++i) printf("%lld\n", ans[i] += ans[i-1]); return 0;&#125; Median Pyramid Hard 给定一个数字三角形，最底下一层的值为一个长度为 $2n-1$ 排列，其余方格中填写的整数是方格正下方,左下方和右下方方格中所写整数的中位数，给定 $n$ 和 最底下一层的排列，求第一层的值 直接求很难求，考虑像猜数字一样二分，每次得到顶端的数与二分值得大小，按照 $B$ 题的结论，里对称轴最近的长度至少为 $2$ 的连续段就是顶端的答案，特判不存在这样连续段的情况即可 12345678910111213141516171819202122232425262728293031323334#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e5+5;int n, p[N], ans = 2;bool valid(int mid)&#123; for(int i = 0; i &lt; n-1; ++i) if(max(p[n-i], p[n-i-1]) &lt;= mid||max(p[n+i], p[n+i+1]) &lt;= mid) return true; else if(min(p[n-i], p[n-i-1]) &gt; mid||min(p[n+i], p[n+i+1]) &gt; mid) return false; return p[1] &lt;= mid;&#125;int main()&#123; n = read(); for(int i = 2*n-1; i; --i) p[i] = read(); int l = 2, r = 2*n-2; while(l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if(valid(mid)) r = mid-1, ans = mid; else l = mid+1; &#125; printf("%d\n", ans); return 0;&#125; Rotate 3x3 我们有一个 $3$ 行 $N$ 列的初始矩阵，$(i,\ j)$ 位置的数为 $i+3j-3$，我们有一个这样的操作：选择一个 $3\times3$ 的子矩阵，将这个子矩阵旋转 $180^\circ$，给定 $3$ 行 $N$ 列的矩阵，矩阵内的数值互不相同，问能否通过若干次上述操作将初始矩阵变为给定的矩阵 先特判掉一定无解的情况 我们注意到每次以 $(i,\ 2)$ 为中心旋转实际上是将 $i-1$ 列和 $i+1$ 列交换，并且 $i$ 及相邻两列的上下颠倒，也就是说每次旋转操作除交换之外将区间 $[i-1,\ i+1]$ 的奇偶性改变，奇数时要上下颠倒，偶数时则不用，初始奇偶性序列为给定矩阵的上下颠倒状态，所以问题就转换为对于给定矩阵经过一系列操作后满足第 $2$ 层的数值顺序递增，且每个位置奇偶性是否满足要求 考虑我们已经使位置合法了，而现在奇偶性并不满足要求，则当 $n\ge 4$ 时有如下变化可以在不改边位置的情况下该边奇偶性，我们可以 $$abcd\to CBAd\to CDab\to Adcb\to ABCD$$ 可以发现每次我们可以改变相邻 $4$ 个状态的奇偶性，而我们还有变化 $$abcdef\to abcFED\to afCBED\to abcFED\to abcdef$$ 此外，上述两者结合，我们只需要把一对需要该边奇列或偶列该边它们的奇偶性，所以答案就变成最终状态的奇数和偶上下颠倒的列个数的奇偶性，若都为偶数则合法，否则不合法 对于最终状态而言，我们只需要求出任意一个方案即可，因为对于一系列操作序列来看，都可以由上述两个操作通过类似于线性组合得到，而每次都是成对变化，不会影响奇偶性 对于求出任意一种可以满足顺序正确的交换方案来说，每次交换会使奇偶性相反数列的列个数奇偶性改变 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e5+5;int n, w[3][N], f[N], h[2];int main()&#123; n = read(); for(int i = 0; i &lt; 3; ++i) for(int j = 1; j &lt;= n; ++j) w[i][j] = read(); for(int i = 1; i &lt;= n; ++i) &#123; int a = w[0][i], b = w[1][i], c = w[2][i]; if(abs(a-b) &gt; 1||abs(b-c) &gt; 1||b%3 != 2||(b%6&amp;i&amp;1)) return puts("No"), 0; f[i] = b/3+1, h[i&amp;1] ^= a &gt; c; &#125; for(int i = 1; i &lt;= n; ++i) while(f[i] != i) h[i&amp;1^1] ^= 1, swap(f[i], f[f[i]]); puts(h[0]||h[1]?"No":"Yes"); return 0;&#125; Blackout 给定 $n\times n$ 的网格，给定坐标序列，这些坐标序列的颜色为黑色，其余为白色，若存在 $(x,\ y)$ 和 $(y,\ z)$ 则会出现一个 $(z,\ x)$ 的黑点，求最终黑点数 很容易把题意转化为图论问题，一般图问题如果不知道怎么做就染色，我们把图染成 $3$ 种颜色，若染色成功我们会发现不同颜色之间会有边相连，若染色不成功则会成为完全图，若每种颜色不全存在，则为各部分图的边数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e5+5;struct Edge&#123; int next, to, w; Edge(int next = 0, int to = 0, int w = 0):next(next), to(to), w(w) &#123;&#125;;&#125;edge[N&lt;&lt;1];int tot, head[N];void add(int x, int y, int z) &#123; edge[++tot] = Edge(head[x], y, z); head[x] = tot; &#125;int n, m, c[N];int64 ans, f[3], s;bool color(int x, int col)&#123; if(c[x]) return c[x] == col+1; c[x] = col+1, ++f[col]; bool ret = true; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to, z = edge[i].w; s += z == 1; if(!color(y, col+z &gt;= 3?col+z-3:col+z)) ret = false; &#125; return ret;&#125;int main()&#123; n = read(), m = read(); for(int i = 1; i &lt;= m; ++i) &#123; int x = read(), y = read(); add(x, y, 1), add(y, x, 2); &#125; for(int x = 1; x &lt;= n; ++x) if(!c[x]) &#123; s = f[0] = f[1] = f[2] = 0; if(!color(x, 1)) s = f[0]+f[1]+f[2], ans += s*s; else if(f[0]&amp;&amp;f[1]&amp;&amp;f[2]) ans += f[0]*f[1]+f[1]*f[2]+f[0]*f[2]; else ans += s; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20809102 NOIP模拟题]]></title>
    <url>%2F2019%2F08%2F02%2F20809102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[card 给定 $n$ 张值为 $i$ 的卡牌，每次随机选择一个整数 $m$，将每 $m$ 张合成 $1$ 张卡牌值加 $1$，剩下的卡牌丢掉，直到最后只剩下一张牌，求值的期望 题意有些不清楚，首先 $m$ 张牌合并的意思是将 $n$ 张牌依次排列，依次把相邻的 $m$ 张牌只合并 $1$ 次，新的牌的值就是原来 $m$ 张牌的值的任意一张加 $1$ 剩下的丢掉，注意可以自己和自己合并 明确了意思就不难做出来了，显然任何局面下的每张牌面的牌面都一样，所以设 $E(n)$ 为有 $n$ 张牌时，每张牌值得期望，则有 $$E(n)\ =\ \frac{\sum_{i=1}^n[E(\lfloor\frac{n}{i}\rfloor)+1]}{n}$$化简得 $$E(n)\ =\ \frac{n+\sum_{i=2}^nE(\lfloor\frac{n}{i}\rfloor)}{n-1}$$ 除法分块即可 记忆化搜索时用数组记录状态会快一点 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int P = 998244353;const int N = 3e7+5;int h[N];int64 qpow(int64 a, int b)&#123; int64 ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%P) if(b&amp;1) ret = a*ret%P; return ret;&#125;int64 E(int n)&#123; if(n == 1) return 1; if(n &lt; N&amp;&amp;h[n]) return h[n]; int64 ret = n; for(int l = 2, r; l &lt;= n; l = r+1) r = n/(n/l), ret = (ret+E(n/l)*(r-l+1)%P)%P; if(n &lt; N) return h[n] = ret*qpow(n-1, P-2)%P; return ret*qpow(n-1, P-2)%P;&#125;int n;int main()&#123; freopen("card.in", "r", stdin); freopen("card.out", "w", stdout); printf("%lld\n", E(read())); return 0;&#125; gift 最初 $Kirin$ 手里拿着一张值为 $0$ 的卡牌，然后他从第 $1$ 张卡牌走到第 $n$ 张卡牌，每次他遇到一张比手里的卡牌等级大的卡牌，他就会交换手中的卡牌与这张卡牌，多次询问 $x$ 次操作后第 $y$ 张卡牌的值 当第 $k$ 次操作时，位于位置 $i$ 的卡牌若比 $[1,\ i]$ 的第 $k$ 大卡牌大的情况下位置 $i$ 的卡牌变为第 $k$ 大的卡牌，并且在之后操作下依次减小，否则，位置 $i$ 的卡牌不变，因此，$(x,\ y)$ 的答案为 $min(xthmax_{1\le k\le y}\lbrace a_k\rbrace,\ a_y)$ 还有一个疑问是，一开始审错题看成冒泡排序了，但是，如何求第 $k$ 次冒泡排序的第 $i$ 个位置的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e6+5;int n, q, a[N], _[N];vector&lt;pair&lt;int, int&gt; &gt; s[N];int val[N&lt;&lt;2], ans[N];void add(int x, int l, int r, int p)&#123; ++val[x]; if(l == r) return; int mid = (l+r)&gt;&gt;1; if(p &lt;= mid) return add(x&lt;&lt;1, l, mid, p); else return add(x&lt;&lt;1|1, mid+1, r, p);&#125;int query(int x, int l, int r, int k)&#123; if(l == r) return l; int mid = (l+r)&gt;&gt;1; if(val[x&lt;&lt;1|1] &gt;= k) return query(x&lt;&lt;1|1, mid+1, r, k); else return query(x&lt;&lt;1, l, mid, k-val[x&lt;&lt;1|1]);&#125;int main()&#123; freopen("gift.in", "r", stdin); freopen("gift.out", "w", stdout); n = read(), q = read(); for(int i = 1; i &lt;= n; ++i) _[i] = a[i] = read(); sort(_+1, _+1+n); for(int i = 1; i &lt;= q; ++i) &#123; int x = read(), y = read(); s[y].push_back(make_pair(x, i)); &#125; for(int i = 1, p; i &lt;= n; ++i) &#123; add(1, 1, n, p = lower_bound(_+1, _+1+n, a[i])-_); for(int k = 0; k &lt; s[i].size(); ++k) &#123; int x = s[i][k].first, d = s[i][k].second; ans[d] = min(x &lt;= i?_[query(1, 1, n, x)]:0, a[i]); &#125; &#125; for(int i = 1; i &lt;= q; ++i) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>期望概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10809102 NOIP模拟题]]></title>
    <url>%2F2019%2F08%2F01%2F10809102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[C (CF1178F Short Colorful Strip) 给定全 $0$ 序列，第 $i$ 次操作可以把值相同的区间的值赋值为 $i$，给定目标排列，求出操作方案数 有两个很明显的性质，首先，第 $i$ 次操作区间一定包括值为 $i$ 的位置，其次，当一个区间被操作后，这个区间与其他区间相互独立 后者是一个很好的性质，意味着对于每个区间只需要关注最小合法位置，枚举区间划分即可，最后区间相乘即可所以，考场上写了一个 $O(n^4)$ 的 $DP$ 设 $f_{p,l,r}$ 为区间 $[l,\ r]$ 第 $p$ 次操作的操作方案数，$g_{l,r,k}$ 为区间 $[l,\ r]$ 的不严格后继，不存在是为 $0$，$q_i$ 为值为 $i$ 的位置，则有 $$f_{p,\ l,\ r}\ =\ \sum_{i=l}^{q_p}\sum_{j=q_p}^rf_{g_{l,i-1,p+1},l,i-1}f_{g_{i,j,p+1},i,j}f_{g_{j+1,r,p+1},j+1,r}[min_{i\le k\le r}\lbrace s_k\rbrace\ge p]$$ 边界 $f_{0,l,r}=1$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e2+5, P = 998244353;int n, s[N], q[N];int64 f[N][N][N];int g[N][N][N];int64 dp(int p, int l, int r)&#123; int64 &amp;ret = f[p][l][r]; if(ret) return ret; if(p == 0) ret = 1; else &#123; for(int i = q[p]; i &gt;= l&amp;&amp;p &lt;= s[i]; --i) for(int j = q[p]; j &lt;= r&amp;&amp;p &lt;= s[j]; ++j) ret = (ret+dp(g[l][i-1][p+1], l, i-1)*dp(g[i][j][p+1], i, j)%P*dp(g[j+1][r][p+1], j+1, r)%P)%P; &#125; return ret;&#125;int main()&#123; n = read(); for(int i = 1; i &lt;= n; ++i) s[i] = read(), q[s[i]] = i; for(int k = 1; k &lt;= n; ++k) for(int l = 1; l &lt;= n; ++l) for(int r = l; r &lt;= n; ++r) if(s[r] &gt;= k) g[l][r][k] = min(s[r], g[l][r-1][k]?g[l][r-1][k]:n); else g[l][r][k] = g[l][r-1][k]; printf("%lld\n", dp(1, 1, n)); return 0;&#125; 期望 $70$ 分 实际上我们可以省略第一维状态，因为不管怎么样，$[l,\ r]$ 填的数一定是最小值，这样一个区间就确定了唯一一个对应的次序 设 $f_{l,r}$ 为 $[l,\ r]$ 的方案数，$g_{l,r}$ 为 $[l,\ r]$ 的最小值，不妨设为 $x$ 则有 $$f_{l,r}\ =\ \sum_{i=l}^{q_p}\sum_{j=q_p}^rf_{l,i-1}f_{i,q_p-1}f_{q_p+1,j}f_{j+1,r}$$ 当 $l\ge r$ 的 $f_{l,r}=1$ 观察上式，$i$ 和 $j$ 的枚举相互独立，可以优化为 $O(n^3)$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 5e2+5, P = 998244353;int n, m, p[N], q[N];int64 f[N][N];int g[N][N];int64 dp(int l, int r)&#123; int64 &amp;ret = f[l][r]; if(ret) return ret; if(l &gt;= r) ret = 1; else &#123; int x = g[l][r]; int64 fl = 0, fr = 0; for(int i = l; i &lt;= q[x]; ++i) fl = (fl+dp(l, i-1)*dp(i, q[x]-1)%P)%P; for(int i = q[x]; i &lt;= r; ++i) fr = (fr+dp(q[x]+1, i)*dp(i+1, r)%P)%P; ret = fl*fr%P; &#125; return ret;&#125;int main()&#123; n = read(), m = read(); for(int i = 1; i &lt;= n; ++i) p[i] = read(), q[p[i]] = i; for(int l = 1; l &lt;= n; ++l) for(int r = l; r &lt;= n; ++r) g[l][r] = min(p[r], g[l][r-1]?g[l][r-1]:n); printf("%lld\n", dp(1, n)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[肯定学不会的多项式基础操作]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%82%AF%E5%AE%9A%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[终于颓废了一天把多项式写的好看了 本文主要是一个模板库，对多项式进行了封装 基础约定在本文中，多项式的相关运算里面，只说次数不说项数，次数表述较灵活，但如果涉及多项式取模，通常以 $ti$ 表示一个多项式的次数，$n$ 表示这个多项式的是在模 $x^n$ 有意义，其中除多项式加减乘转置以外，其他或多或少都有多项式取模存在，其中包括多项式求导和多项式积分在本文中，代码里面的多项式为大写，推导过程的多项式通常为小写，参数的多项式以 A 和 B 为主，其他以 F 和 G 为主 在本文中，的多项式离散变换为 NTT，NTT 模数为 998244353 原根为 3 在本文中，所有多项式运算需要用到的自然数逆元已被预处理在 inv 数组里 在本文中，对于加减乘模运算以外的其他运算，会先给出数学证明 在本文中，多项式的次数包含零系数 Poly 类 与 加减运算1234567891011121314151617181920struct Poly&#123; vector&lt;int&gt; _; inline int&amp; operator [] (int i) &#123; return _[i]; &#125; inline int ti() &#123; return _.size()-1; &#125; inline void set(int ti) &#123; return _.resize(ti+1); &#125; inline void rev() &#123; return reverse(_.begin(), _.end()); &#125;&#125;;Poly operator - (Poly A, Poly B)&#123; A.set(max(A.ti(), B.ti())); for(int i = B.ti(); ~i; --i) A[i] = A[i]-B[i]&lt;0?A[i]-B[i]+P:A[i]-B[i]; return A;&#125;Poly operator + (Poly A, Poly B)&#123; A.set(max(A.ti(), B.ti())); for(int i = B.ti(); ~i; --i) A[i] = A[i]+B[i]&lt;P?A[i]+B[i]:A[i]+B[i]-P; return A;&#125; 假设已声明 Poly 类变量 F 和 G F[i]：返回 F._[i] 的值，并且支持直接对 F._[i] 的修改，需要注意保证你访问的下标不超过当前 F 的次数 F.ti()：返回 F 的次数 F.set(ti)：重新设置 F 的次数，若 ti 小于当前次数则多余部分舍弃，大于则不足部分补 0 F.rev()：将 F 转置，即 F[i] 变为 F[n-i] F+G：返回 F 与 G 的和，新的多项式的次数为两者中的较大值 F-G：返回 F 与 G 的差，新的多项式的次数为两者中的较大值 多项式离散变化1234567891011121314151617181920212223242526272829int64 w[2][N&lt;&lt;2], inv[N&lt;&lt;2];int lim;void prepare(int ti)&#123; for(lim = 1; lim &lt;= ti; lim &lt;&lt;= 1); w[0][0] = w[0][lim] = w[1][0] = w[1][lim] = 1; int64 g = qpow(3, (P-1)/lim); for(int i = 1; i &lt; lim; ++i) w[1][lim-i] = w[0][i] = w[0][i-1]*g%P; &#125;void NTT(Poly &amp;A, int t)&#123; if(!t) A.set(lim-1); for(int i = 0, j = 0; i &lt; lim; ++i) &#123; if(i &gt; j) A[i] ^= A[j] ^= A[i] ^= A[j]; for(int k = lim&gt;&gt;1; (j ^= k) &lt; k; k &gt;&gt;= 1); &#125; for(int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) for(int len = mid&lt;&lt;1, j = 0; j &lt; lim; j += len) for(int k = 0, p = 0, q = lim/len; k &lt; mid; ++k, p += q) &#123; int64 x = A[j+k], y = A[j+k+mid]*w[t][p]%P; A[j+k] = x+y&lt;P?x+y:x+y-P; A[j+k+mid] = x-y&lt;0?x-y+P:x-y; &#125; if(!t) return; int64 v = inv[lim]; for(int i = 0; i &lt; lim; ++i) A[i] = A[i]*v%P;&#125; prepare(ti)：对即将变换的 ti 次多项式项数扩展为后继 2 的整数次幂 lim ，并且对即将使用的单位根进行预处理，其中 w[0][i] 访问到的是 $3^{\frac{P-1}{lim}i}$，而 w[1][i] 访问到的是其逆元，两者关系可以由欧拉定理得出互为转置 假设已声明 Poly 类变量 F NTT(F, t)：当 t 为 0 时，进行 NTT，这时需要一开始将 F 的次数设置为 lim-1；当 t 为 1 时，进行 INTT；此外在交换下标阶段省略 rev 数组，改用异或模拟加法，均摊 O(n)， NTT 的过程中通过累加循环变量 p，代替 lim/len*k 意外优化了很大的常数 多项式乘运算1234567891011121314151617181920Poly operator * (Poly A, Poly B)&#123; int n = A.ti(), m = B.ti(); if(n &lt;= 128||m &lt;= 128) &#123; Poly C; C.set(n+m); int *c = &amp;C[0], *a = &amp;A[0], *b = &amp;B[0]; for(int i = 0; i &lt;= n; ++i) &#123; int *f = c+i; int64 x = a[i]; for(int j = 0; j &lt;= m; ++j) f[j] = (f[j]+x*b[j]%P)%P; &#125; return C; &#125; prepare(n+m), NTT(A, 0), NTT(B, 0); for(int i = 0; i &lt; lim; ++i) A[i] = 1ll*A[i]*B[i]%P; NTT(A, 1), A.set(n+m); return A;&#125; 假设已声明 Poly 类变量 F 和 G F*G：返回 F 与 G 的积，新的多项式的次数为两者次数之和，其中 F 与 G 次数较小是采取朴素做法优化常数 多项式求逆给定多项式 $f$ 我们要求出 $g$ 满足$$f\times g\equiv 1\ mod\ x^n$$ 考虑倍增，假设我们已求出$$f\times g_{i-1}\equiv 1\ mod\ x^{\lceil\frac{n}{2}\rceil}$$现在要求出$$f\times g_i\equiv 1\ mod\ x^n$$显然$$f\times g_i\equiv 1\ mod\ x^{\lceil\frac{n}{2}\rceil}$$所以$$g_i-g_{i-1}\equiv 0\ mod\ x^{\lceil\frac{n}{2}\rceil}$$$$(g_i-g_{i-1})^2\equiv 0\ mod\ x^n$$$$f(g_i^2-2g_ig_{i-1}+g_{i-1}^2)\equiv 0\ mod\ x^n$$得到$$g_i\equiv 2g_{i-1}-fg_{i-1}^2\ mod\ x^n$$倍增求解即可 12345678910Poly polyInv(Poly A, int n)&#123; Poly B; A.set(n-1), B.set(n-1); if(n == 1) return B[0] = qpow(A[0], P-2), B; B = polyInv(A, (n+1)&gt;&gt;1), prepare(n&lt;&lt;1); NTT(A, 0), NTT(B, 0); for(int i = 0; i &lt; lim; ++i) B[i] = (2ll-1ll*B[i]*A[i]%P+P)%P*B[i]%P; NTT(B, 1), B.set(n-1); return B;&#125; 假设已声明 Poly 类变量 F polyInv(F, n)：返回 F 在模意义下的逆元，需注意，每次 A 在运算时同样也需要先取模 多项式带余除法给定 $n$ 次多项式 $f$ 和 $m$ 次多项式 $g$ 求出 $n-m$ 多项式 $q$ 和 $m-1$ 次多项式 $r$，满足 $$f\ =\ q\times g+r$$ 将式子代换成 $$x^nf(\frac{1}{x})\ =\ x^{n-m}q(\frac{1}{x})\times x^{m}g(\frac{1}{x})+x^{n-m+1}x^{m-1}r(\frac{1}{x})$$ 考虑 $f$ 的转置多项式 $f_r$ 满足 $[x^i]\ f_r\ =\ [x^{n-i}]\ f$ 的另外一种表述为 $f_r\ =\ x^n\ f(\frac{1}{x})$ $$f_r\ =\ q_r\times g_r+x^{n-m+1}r_r$$ 发现在模 $x^{n-m+1}$ 的意义下余项的转置被消去，则有 $$f_r\ =\ q_r\times g_r\ mod\ x^{n-m+1}$$ 所以 $$q_r\ =\ f_r\times g_r^{-1}\ mod\ x^{n-m+1}$$ 求出 $q$ 之后 $r$ 就很容易求出 1234567891011121314Poly operator / (Poly A, Poly B)&#123; if(A.ti() &lt; B.ti()) return A.set(0), A; int n = A.ti(), m = B.ti(); A.rev(), B.rev(); A = A*polyInv(B, n-m+1), A.set(n-m), A.rev(); return A;&#125;Poly operator % (Poly A, Poly B)&#123; if(A.ti() &lt; B.ti()) return A; A = A-(A/B)*B; A.set(B.ti()-1); return A;&#125; F/G：返回 F 与 G 的商，新的多项式的次数为两者中的较大值 F-G：返回 F 与 G 的yu，新的多项式的次数为两者中的较大值 多项式求导和积分给定多项式 $f$ 我们要求出 $g$ 和 $h$ 满足$$g\equiv f’\ mod\ x^n$$$$h\equiv \int f dx\ mod\ x^n$$ 由幂函数求导法则 $x^n\to nx^{n-1}$ 和求导四则运算得 $$[x^n]\ g\ =\ [x^{n+1}]\ f\times n$$ 由微分和积分互为逆运算得到 $$[x^n]\ h\ =\ [x^{n-1}]\ f\times \frac{1}{n}$$ 123456789101112Poly polyDer(Poly A, int n)&#123; A.set(n-1); for(int i = 0; i &lt; n-1; ++i) A[i] = 1ll*(i+1)*A[i+1]%P; A[n-1] = 0; return A;&#125;Poly polyInte(Poly A, int n)&#123; A.set(n-1); for(int i = n-1; i; --i) A[i] = inv[i]*A[i-1]%P; A[0] = 0; return A;&#125; 假设已声明 Poly 类变量 F polyDer(F, n)：返回 F 在模意义下的导数，其次数由模数决定，特别地，只需要正常求导时，n 应该为 F.ti()+1，返回的仍是 F.ti() 次多项式 polyInte(F, n)：返回 F 在模意义下的积分，其次数由模数决定，特别地，只需要正常积分时，n 应该为 F.ti()+2，返回的是 F.ti()+1 次多项式 多项式对数函数给定多项式 $f$ 我们要求出 $g$ 满足$$g\equiv ln\ f\ mod\ x^n$$ 两边同时求导再积回来就好了 $$g\equiv \int\frac{f’}{f}dx\ mod\ x^n$$ 1Poly polyLn(Poly A, int n) &#123; return polyInte(polyDer(A, n)*polyInv(A, n), n); &#125; 假设已声明 Poly 类变量 F polyLn(F, n)：返回 F 在模意义下的自然对数，其次数由模数决定 多项式指数函数 (牛顿迭代) 给定多项式 $f$ 我们要求出 $g$ 满足$$g\equiv e^f\ mod\ x^n$$ 首先，我们把牛顿迭代推广到多项式中，考虑 给定多项式 $f$ 我们要求出 $g$ 满足$$f(g)\equiv 0\ mod\ x^n$$ 那么就有 $$g_i\equiv g_{i-1}-\frac{f(g_{i-1})}{f’(g_{i-1})}\ mod\ x^n$$ 倍增迭代即可 另外，注意求导是 $g$ 关于 $f$ 求导，而不是 $x$ 关于 $f$ 求导 在这指数函数中两边取对数移项得 $$ln\ g - f\equiv 0\ mod\ x^n$$ 不妨把左侧看作关于 $g$ 得函数，那么我们实际上就是求出该多项式得零点，带入牛顿迭代式得 $$g_i\equiv g_{i-1}(1-ln\ g_{i-1}+f)\ mod\ x^n$$ 12345678Poly polyExp(Poly A, int n)&#123; Poly B; B.set(n-1), A.set(n-1); if(n == 1) return B[0] = 1, B; B = polyExp(A, (n+1)&gt;&gt;1), B.set(n-1), ++A[0]; B = B*(A-polyLn(B, n)); B.set(n-1); return B;&#125; 假设已声明 Poly 类变量 F polyLn(F, n)：返回 F 在模意义下的 Exp ，其次数由模数决定]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[72709102 AGC005]]></title>
    <url>%2F2019%2F07%2F27%2F72709102-AGC005%2F</url>
    <content type="text"><![CDATA[~K Perm Counting 如果一个排列 $P$ 满足对于所有的i都有 $|p_i-i|\ne k$，则称排列P为合法的，求合法排列数 考虑错排问题就是 $k\ = 0$ 的特殊情况，这道题用同样做法来做，设 $f_i$ 为恰好有 $i$ 个满足 $|p_i-i|\ne k$ 的方案数，$g_i$ 为至少有 $i$ 个满足 $|p_i-i|\ne k$ 的方案数，则有 $$g_i\ =\ \sum_{i\le j}f_j$$根据广义容斥 $$f_i\ =\ \sum_{i\le j}(-1)^{j-i}g_j$$ 考虑如何求出 $g_i$，我们利用下标和键值的关系不难看出这是一个二分图匹配问题，那么问题就转化为在一个二分图中选出 $i$ 条匹配边的方案数，注意到每个点的度数不超过 $2$，我们可以把这些链抽出来并在一起，不妨设 $h_{i,j,k}$ 表示前 $i$ 个点选出 $j$ 条匹配边，第 $i$ 个点与前一个点连边状态为 $k$ 时的的方案数，转移很简单，不多赘述，最后答案即为 $g_i\ =\ (h_{2n,i,0}+h_{2n,i,1})(n-i)!$ 关于解决二分图匹配问题很具有启发性，说不定下次会碰见一道题满足树的特殊性质的二分图匹配 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 4e3+5, P = 924844033;int n, m;int cut[N], h[N][N][2], g[N], f[N], fac[N];int main()&#123; n = read(), m = read(); fac[0] = 1; for(int i = 1; i &lt;= n; ++i) fac[i] = 1ll*fac[i-1]*i%P; for(int i = 1, p = 1; i &lt;= m; ++i) &#123; cut[p] = 1; p += (n-i)/m+1; cut[p] = 1; p += (n-i)/m+1; &#125; for(int i = 0; i &lt;= n&lt;&lt;1; ++i) h[i][0][0] = 1; for(int i = 1; i &lt;= n&lt;&lt;1; ++i) for(int j = 1; j &lt;= n; ++j) &#123; h[i][j][0] = (h[i-1][j][0]+h[i-1][j][1])%P; if(!cut[i]) h[i][j][1] = h[i-1][j-1][0]; &#125; for(int i = 0; i &lt;= n; ++i) g[i] = 1ll*(h[n&lt;&lt;1][i][0]+h[n&lt;&lt;1][i][1])*fac[n-i]%P; for(int i = 0, w = 1; i &lt;= n; ++i, w = P-w) f[0] = (f[0]+1ll*w*g[i]%P)%P; printf("%d\n", f[0]); return 0;&#125; Sugigma: The Showdown 给定两棵树和起点，两人分别在两棵树上交替移动，相遇后游戏结束，现在 $A$ 想最大化游戏轮数，$B$ 想最小化游戏轮数，求游戏轮数 很明显，最终如果游戏不能无限进行则 $A$ 会最终不移动，那么问题关键就是求出 $A$ 能移动到点集，我们发现有个很明显的充分条件是起点到这些点的经过点到 $A$ 的距离小于 $B$ 到这些点的距离，通过搜索判断可达性即可 如果游戏可以无限进行，则 $A$ 一定可以达到一条边 $(u,\ v)$ 满足在 $B$ 上 $d_{u,v}&gt;2$，达到这条边后左右跳即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e5+5;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N&lt;&lt;2];int ha[N], hb[N], tot;void _add(int *h, int x, int y) &#123; edge[++tot] = Edge(h[x], y); h[x] = tot; &#125;void add(int *h, int x, int y) &#123; _add(h, x, y); _add(h, y, x); &#125;int fa[N], son[N], size[N], top[N], d[N];int ans, cir;void dfs(int x)&#123; size[x] = 1; for(int i = hb[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(y == fa[x]) continue; d[y] = d[x]+1, fa[y] = x, dfs(y), size[x] += size[y], son[x] = size[son[x]]&gt;size[y]?son[x]:y; &#125;&#125;int lca(int x, int y)&#123; while(top[x] != top[y]) &#123; if(d[top[x]] &lt; d[top[y]]) swap(x, y); x = fa[top[x]]; &#125; return d[x]&lt;d[y]?x:y;&#125;int dis(int x, int y) &#123; return d[x]+d[y]-2*d[lca(x, y)]; &#125;void dfs(int x, int topf)&#123; top[x] = topf; if(son[x]) dfs(son[x], topf); for(int i = hb[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(y != fa[x]&amp;&amp;y != son[x]) dfs(y, y); &#125;&#125;void escape(int x, int fa, int dep)&#123; ans = max(ans, d[x]&lt;&lt;1); for(int i = ha[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(dis(x, y) &gt; 2) cir = 1; if(y == fa||dep+1 &gt;= d[y]) continue; escape(y, x, dep+1); &#125;&#125;int n, a, b;int main()&#123; n = read(), a = read(), b = read(); for(int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); add(ha, x, y); &#125; for(int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); add(hb, x, y); &#125; dfs(b); dfs(b, b); escape(a, 0, 0); printf("%d\n", cir?-1:ans); return 0;&#125; Many Easy Problems 给定一棵无根树，定义 $f(i)$，对于所有大小为 $i$ 的点集，求出能够包含它的最小连通块大小之和。对于 $i=1 \to n$ 的所有 $i$，求出 $f(i)$ 想这道题的过程收获挺多的，首先这道题问的点集，按照套路就是思考每个点对于 $f(i)$ 的贡献，但没想出来，所以看到联通块，又想到 $dfs$ 序与联通块的联系，得到一个的做法，简单来说就是枚举每个点对，考虑点对在 $dfs$ 序的子序列的位置用组合数算下贡献就好了，这个思路想到 $O(n^3)$ 就想不下去了 再考虑每个点的贡献，其实很好算，设 $s_i$ 为定根后节点 $i$ 的子树大小，考虑节点 $i$ 会被多少个点集算到，得到 $$f(k)\ =\ \sum_{i=1}^n\binom{n}{k}-\binom{n-s_i}{k}-\sum_{j\in son_i}\binom{s_j}{k}$$ 化简得到 $$f(k)\ =\ n\binom{n}{k}-\sum_{i=2}^n\binom{n-s_i}{k}+\binom{s_i}{k}$$ 主要问题是求出后面的式子，设它的生成函数为 $h$ 则有 $$h\ =\ \sum_{k}\sum_{i=2}^n[\binom{n-s_i}{k}+\binom{s_i}{k}]x^k$$ 这时候我就被降智了，考虑交换求和序，有 $$\begin{aligned}h\ &amp;=\ \sum_{i=2}^n\sum_{k}\binom{n-s_i}{k}x^k+\binom{s_i}{k}x^k\\&amp;=\ \sum_{i=2}^n(1+x)^{s_i}+(1+x)^{n-s_i}\end{aligned}$$ 开一个桶 $c$ 记录一下相同的指数，则 $$h\ =\ \sum_{i=0}^nc_i(1+x)^i$$ 这不就是一个裸的多项式复合函数吗，结果一看多项式复合函数的复杂度，溜了，溜了 接着我发现这就是多项式的平移吗，那就求值完平移再插回去就好了呀，学了半天求值和插值，一发交上去只拿了暴力分 稍微优化一下，改用原根求值，最后直接 $INTT$ 即可，还是只拿了暴力分 翻了具体数学提高知识水平，发现下降幂可做，但求下降幂又要多点求值自闭 最后重新看这个式子，好像就是一个裸的卷积 $$\begin{aligned}h\ &amp;=\ \sum_{k}\sum_{i=0}^nc_i\binom{i}{k}x^k\\&amp;=\ \sum_{k}\frac{1}{k!}\sum_{i=0}^n(c_i\times i!)(\frac{1}{(i-k)!})x^k\end{aligned}$$ 后面稍微转置一下就是卷积了 同时，我们惊喜地发现多项式线性变换同样是一个简单的卷积 常数巨大的 $AC$ 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e5+5, P = 924844033;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;; &#125;edge[N&lt;&lt;1];int tot, head[N];void _add(int x, int y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;void add(int x, int y) &#123; _add(x, y), _add(y, x); &#125;int n, s[N];void dfs(int x, int fa)&#123; s[x] = 1; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(y == fa) continue; dfs(y, x); s[x] += s[y]; &#125;&#125;int64 qpow(int64 a, int b)&#123; int64 ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%P) if(b&amp;1) ret = a*ret%P; return ret;&#125;int64 fac[N], inv[N&lt;&lt;2], ifac[N];int64 C(int n, int m) &#123; return n &lt; m?0:fac[n]*ifac[m]%P*ifac[n-m]%P; &#125;struct Poly&#123; vector&lt;int&gt; _; inline int&amp; operator [] (int i) &#123; return _[i]; &#125; inline int ti() &#123; return _.size()-1; &#125; inline void set(int ti) &#123; _.resize(ti+1); &#125; inline void rev() &#123; reverse(_.begin(), _.end()); &#125;&#125;;int lim;int64 w[2][N&lt;&lt;2];void prepare(int ti)&#123; for(lim = 1; lim &lt;= ti; lim &lt;&lt;= 1); w[0][0] = w[1][0] = w[0][lim] = w[1][lim] = 1; int64 g = qpow(5, (P-1)/lim); for(int i = 1; i &lt; lim; ++i) w[1][lim-i] = w[0][i] = w[0][i-1]*g%P;&#125;void NTT(Poly &amp;A, int t)&#123; if(!t) A.set(lim-1); for(int i = 0, j = 0; i &lt; lim; ++i) &#123; if(i &gt; j) A[i] ^= A[j] ^= A[i] ^= A[j]; for(int k = lim&gt;&gt;1; (j ^= k) &lt; k; k &gt;&gt;= 1); &#125; for(int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) for(int len = mid&lt;&lt;1, j = 0; j &lt; lim; j += len) for(int k = 0, p = 0, q = lim/len; k &lt; mid; ++k, p += q) &#123; int64 x = A[j+k], y = w[t][p]*A[j+k+mid]%P; A[j+k] = x+y&lt;P?x+y:x+y-P; A[j+k+mid] = x-y&lt;0?x-y+P:x-y; &#125; if(!t) return; int64 v = inv[lim]; for(int i = 0; i &lt; lim; ++i) A[i] = A[i]*v%P;&#125;Poly operator * (Poly A, Poly B)&#123; int n = A.ti(), m = B.ti(); if(n &lt;= 128||m &lt;= 128) &#123; Poly C; C.set(n+m); int *c = &amp;C[0], *a = &amp;A[0], *b = &amp;B[0]; for(int i = 0; i &lt;= n; ++i) &#123; int *f = c+i; int64 x = a[i]; for(int j = 0; j &lt;= m; ++j) f[j] = (f[j]+x*b[j]%P)%P; &#125; return C; &#125; prepare(n+m), NTT(A, 0), NTT(B, 0); for(int i = 0; i &lt; lim; ++i) A[i] = 1ll*A[i]*B[i]%P; NTT(A, 1); A.set(n+m); return A;&#125;Poly F, G;int px[N&lt;&lt;1], py[N&lt;&lt;1];int main()&#123; for(int i = 1; i &lt;= N&lt;&lt;2; i &lt;&lt;= 1) inv[i] = qpow(i, P-2); n = read(), fac[0] = fac[1] = ifac[0] = ifac[1] = 1; for(int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); add(x, y); &#125; dfs(1, 0); F.set(n), G.set(n); for(int i = 2; i &lt;= n; ++i) &#123; inv[i] = (P-P/i)*inv[P%i]%P, fac[i] = i*fac[i-1]%P, ifac[i] = inv[i]*ifac[i-1]%P; ++F[s[i]], ++F[n-s[i]]; &#125; for(int i = 0; i &lt;= n; ++i) F[i] = F[i]*fac[i]%P, G[i] = ifac[i]%P; F.rev(), F = F*G, F.set(n), F.rev(); for(int i = 1; i &lt;= n; ++i) printf("%lld\n", (n*C(n, i)%P-F[i]*ifac[i]%P+P)%P); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>生成函数</tag>
        <tag>容斥</tag>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>博弈论</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[52709102 AGC004]]></title>
    <url>%2F2019%2F07%2F25%2F52709102-AGC004%2F</url>
    <content type="text"><![CDATA[Colorful Slimes 有 $2$ 种操作，花费 $a_i$ 秒，直接获得颜色 $i$ 和花费 $x$ 秒，使得之前获得的颜色 $i$ 全部变为颜色 $(i + 1)\ mod\ n$，求收集到 $0$ 到 $n-1$ 所有颜色的最短时间 了解题意后，我们发现，每种方案的 $2$ 操作一定取决于作用二操作次数最多的颜色，所以枚举 $2$ 操作，滑动窗口最小值查询即可1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 4e3+5;int n, x, a[N], q[N], l, r;int64 ans;int main()&#123; n = read(), x = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read(), a[i+n] = a[i]; for(int k = 0; k &lt; n; ++k) &#123; int64 s = 1ll*k*x; l = 1, r = 0; for(int i = 1; i &lt;= k; ++i) &#123; while(l &lt;= r&amp;&amp;a[q[r]] &gt;= a[i]) --r; q[++r] = i; &#125; for(int i = k+1; i &lt;= n+k; ++i) &#123; while(l &lt;= r&amp;&amp;i-k &gt; q[l]) ++l; while(l &lt;= r&amp;&amp;a[q[r]] &gt;= a[i]) --r; q[++r] = i; s += a[q[l]]; &#125; ans = k?min(s, ans):s; &#125; printf("%lld\n", ans); return 0;&#125; AND Grid 给定一个网格图，有些位置已经被涂色，要求构造两个相同大小的网格图，并且在上面涂色，需要保证颜色四联通，满足这两个网格的涂色部分的重合位置恰好是给定的网格图的涂色位置 这道题保证边界无颜色，所以只需要行按照奇偶染色，最后一边染开始的一列，一边染结束的一列保证联通即可 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 5e2+5;int n, m;char s[N][N], a[N][N], b[N][N];int main()&#123; n = read(), m = read(); for(int i = 1; i &lt;= n; ++i) scanf("%s", s[i]+1); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) a[i][j] = b[i][j] = s[i][j]; for(int i = 1; i &lt;= n; ++i) a[i][1] = b[i][m] = '#'; for(int i = 1; i &lt;= n; ++i) for(int j = 2; j &lt; m; ++j) i&amp;1?a[i][j] = '#':b[i][j] = '#'; for(int i = 1; i &lt;= n; ++i) printf("%s\n", a[i]+1); puts(""); for(int i = 1; i &lt;= n; ++i) printf("%s\n", b[i]+1); return 0;&#125; Teleporter 给定一个基环内向树，修改尽可能少的出边，使得每个点到 $1$ 号节点都可以经过 $k$ 条边到达 显然，我们需要 $1$ 号点自身连自环，之后就变成了 [HNOI2003]消防局的设立 随便做一下就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e5+5;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N];int tot, head[N];void add(int x, int y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;int n, m;int ac[20][N], d[N], cov[N], ans, fa[N];void dfs(int x)&#123; d[x] = d[fa[x]]+1; for(int i = 1; i &lt; 20; ++i) ac[i][x] = ac[i-1][ac[i-1][x]]; for(int i = head[x]; i; i = edge[i].next) dfs(edge[i].to);&#125;void cover(int x)&#123; if(cov[x]) return; cov[x] = 1; for(int i = head[x]; i; i = edge[i].next) cover(edge[i].to); &#125;priority_queue&lt;pair&lt;int, int&gt; &gt; q;int main()&#123; n = read(), m = read(); for(int x = 1; x &lt;= n; ++x) fa[x] = read(); for(int x = 2; x &lt;= n; ++x) add(ac[0][x] = fa[x], x); ans += fa[1] != 1; dfs(1); for(int x = 1; x &lt;= n; ++x) q.push(make_pair(d[x], x)); while(q.size()) &#123; int x = q.top().second, p = x; q.pop(); if(cov[x]||d[x]-d[1] &lt;= m) continue; for(int i = 19; ~i; --i) if(d[x]-d[ac[i][p]] &lt; m&amp;&amp;ac[i][p]) p = ac[i][p]; cover(p); ++ans; &#125; printf("%d\n", ans); return 0;&#125; Salvage Robots 有一个棋盘，每个格子有机器人，空格和出口三者之一 ，每次可以命令所有机器人向上下左右中的某个方向移动一格，如果它超出了棋盘的边界或到了出口的位置就会消失，求机器人到出口的最多数量 很自然地想到把出口和其可以移动的范围替代移动机器人，然而设计的 $DP$ 具有会算重，之后就看了官方题解 不妨设 $f_{l,r,d,u}$ 表示出口曾经向左走了 $l$ 格，向右走了 $r$ 格，向上走 $d$ 格，向下走了 $u$ 格，这个范围内遇到的机器人的最大数量，如图 图中的黄色区域就是机器人曾经的移动范围，在这个移动范围内的机器人取舍情况已经被计算好了 接着，我们标注一下曾经有过这个移动范围的前提下，它不能走的网格 我们发现只要向白色部分转移即可，而对于红黄相间的部分的取舍之前已经取舍过了，只有红色的部分就是走不到的部分 转移如下 移动范围扩大，在加上相应颜色区域的机器人数量即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e2+5;int max(int a, int b) &#123; return a&gt;b?a:b; &#125;int min(int a, int b) &#123; return a&lt;b?a:b; &#125;short f[N][N][N][N], g[N][N], h[N][N];char s[N][N];int n, m, ans, px, py;int main()&#123; n = read(), m = read(); memset(f, -1, sizeof(f)); for(int i = 1; i &lt;= n; ++i) scanf("%s", s[i]+1); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) &#123; if(s[i][j] == 'E') px = i, py = j; g[i][j] = g[i][j-1]+(s[i][j] == 'o'); h[i][j] = h[i-1][j]+(s[i][j] == 'o'); &#125; f[0][0][0][0] = 0; int pl = py-1, pr = m-py, pd = px-1, pu = n-px, p; for(int l = 0; l &lt;= pl; ++l) for(int r = 0; r &lt;= pr; ++r) for(int d = 0; d &lt;= pd; ++d) for(int u = 0; u &lt;= pu; ++u) &#123; if(!(~f[l][r][d][u])) continue; int cl = max(r+1, py-l), cr = min(m-l, py+r); int cd = max(u+1, px-d), cu = min(n-d, px+u); if((p = py+r+1) &lt;= m-l) f[l][r+1][d][u] = max(f[l][r+1][d][u], f[l][r][d][u]+h[cu][p]-h[cd-1][p]); if((p = py-l-1) &gt;= r+1) f[l+1][r][d][u] = max(f[l+1][r][d][u], f[l][r][d][u]+h[cu][p]-h[cd-1][p]); if((p = px+u+1) &lt;= n-d) f[l][r][d][u+1] = max(f[l][r][d][u+1], f[l][r][d][u]+g[p][cr]-g[p][cl-1]); if((p = px-d-1) &gt;= u+1) f[l][r][d+1][u] = max(f[l][r][d+1][u], f[l][r][d][u]+g[p][cr]-g[p][cl-1]); ans = max(ans, f[l][r][d][u]); &#125; printf("%d\n", ans); return 0;&#125; Namori 给定一个树或基环树，每个点初始是白色，每次操作可以处理一条边，其两个点如果颜色相同则都变成相反的颜色，询问能否将每个点都变为黑色 首先考虑树的情况，考虑对树黑白染色，那么题中的操作就变成了把黑白交换位置，最终黑点变为原来的白点，白点变为原来的黑点，不妨将黑点的权值置为 $-1$，白点的权值置为 $1$，$s_x$ 为以 $x$ 为根的子树的点权和，$p$ 为根，显然 $s_p$ 不为 $0$ 时无解 考虑答案的下界，对于 $s_x$ 不为 $0$，那么 $x$ 要向父边交换 $|s_x|$ 个点，则下界为 $\sum|s_x|$，这个下界一定可以达到，因为考虑从叶子节点向上按照这样贪心，我们在对 $x$ 操作前，$x$ 的子树尽可能满足，即可以找到一个合适的顺序使父边只交换 $|s_x|$ 个点 再讨论基环树，我们把环上任意一边 $(p,\ q)$ 删掉，首先是奇环，奇环不满足二分图性质，所以断掉的那条边意义与其他边不同，手模几组样例后发现，对这条边的操作可以使得黑白点的差减少 $2$，所以当 $s_p$ 为奇数时问题无解，否则，答案加上 $|\frac{s_p}{2}|$，环上所有 $s_x$ 减 $\frac{s_p}{2}$ 且 $s_p$ 自身变为 $0$，其次是偶环，偶环满足二分图性质，边的的意义与其他边相同，对环上的交换单独考虑，发现就是一个均分纸牌，求个中位数即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e5+5;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N&lt;&lt;1];int tot, head[N];void _add(int x, int y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;void add(int x, int y) &#123; _add(x, y); _add(y, x); &#125;int n, m, cn, w[N], f[N], fa[N], s[N], p, q, ans;int find(int x) &#123; return f[x] == x?x:f[x] = find(f[x]); &#125;void dfs(int x, int f, int c)&#123; fa[x] = f, s[x] = c; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(y == f) continue; dfs(y, x, -c); s[x] += s[y]; &#125;&#125;int main()&#123; n = read(), m = read(), p = 1; for(int x = 1; x &lt;= n; ++x) f[x] = x; for(int i = 1; i &lt;= m; ++i) &#123; int x = read(), y = read(); if(find(x) == find(y)) p = x, q = y; else f[find(y)] = find(x), add(x, y); &#125; dfs(p, 0, 1); if(n == m) &#123; for(int x = q; x; x = fa[x]) w[++cn] = s[x]; if(cn&amp;1) &#123; if(s[p]&amp;1) return puts("-1"), 0; for(int x = q; x; x = fa[x]) s[x] -= s[p]&gt;&gt;1; &#125; else &#123; if(s[p]) return puts("-1"), 0; sort(w+1, w+1+cn); for(int x = q; x; x = fa[x]) s[x] -= w[cn&gt;&gt;1]; &#125; &#125; else if(s[p]) return puts("-1"), 0; for(int x = 1; x &lt;= n; ++x) ans += abs(s[x]); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>思维</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[42709102 AGC003]]></title>
    <url>%2F2019%2F07%2F24%2F42709102-AGC003%2F</url>
    <content type="text"><![CDATA[Anticube 给定 $n$ 个数 $s_i$，要求从中选出最多的数，满足任意两个数之积都不是完全立方数 对于一个数 $x$ 进行唯一分解，把每个质因子的指数对 $3$ 取模构造出数 $a$，再把 $a$ 的每个质因子指数相反数对 $3$ 取模得到 $b$，我们发现 $a$ 和 $b$ 是一一对应的，贪心取较大的那一个即可，特判 $x$ 是完全平方数的情况 进行质因数分解时，可以筛到 $10^{\frac{10}{3}}$ 以内的质数，对于分解后剩下的数，要么是一个质数的完全平方数，要么是质数，判断一下即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;typedef long long int64;inline int64 read(int f = 1, int64 x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int p[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;, S = 127;const int N = 1e5+5;int64 qpow(int64 a, int64 b, int64 n)&#123; int64 ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%n) if(b&amp;1) ret = a*ret%n; return ret;&#125;int64 gcd(int64 a, int64 b) &#123; return b?gcd(b, a%b):a; &#125;bool miller_rabin(int64 n)&#123; if(n == 1) return false; for(int i = 0; i &lt; 12; ++i) if(n%p[i] == 0) return n == p[i]; int64 r; int t; for(r = n-1, t = 0; ~r&amp;1; r &gt;&gt;= 1, ++t); for(int i = 0; i &lt; 12; ++i) &#123; int64 x = qpow(p[i], r, n), xs; for(int j = 1; j &lt;= t; ++j) &#123; xs = x*x%n; if(xs == 1&amp;&amp;x != 1&amp;&amp;x != n-1) return false; x = xs; &#125; if(x != 1) return false; &#125; return true;&#125;vector&lt;int64&gt; pd;int n, c[N], ans;int64 a[N], b[N];map&lt;int64, int&gt; h, vis;int main()&#123; n = read(); for(int i = 1; i &lt;= 2200; ++i) if(miller_rabin(i)) pd.push_back(i); for(int i = 1; i &lt;= n; ++i) &#123; int64 x = read(), t; a[i] = b[i] = 1; for(int k = 0; k &lt; pd.size(); ++k) &#123; c[k] = 0; while(x%pd[k] == 0) ++c[k], x /= pd[k]; c[k] %= 3; if(c[k] == 2) a[i] *= pd[k]*pd[k], b[i] *= pd[k]; else if(c[k] == 1) a[i] *= pd[k], b[i] *= pd[k]*pd[k]; &#125; t = sqrt(x); if(t*t == x) a[i] *= t*t, b[i] *= t; else a[i] *= x, b[i] *= x*x; ++h[a[i]]; &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(vis[a[i]]||vis[b[i]]||a[i] == 1) continue; vis[a[i]] = 1; ans += max(h[a[i]], h[b[i]]); &#125; printf("%d\n", ans+(h[1] != 0)); return 0;&#125; Sequential operations on Sequence 初始为 $1$ 到 $n$ 的数列，每次操作把数组长度变为$m$，新增的数为上一个操作后的数组的重复，问最终数出现的次数 首先，对最终答案有贡献的一定是单调递增的操作序列，用单调栈维护，其次这个问题的实质是要维护出每个操作对应的序列在最终答案的出现次数，便于处理每次操作后对于的那些部分，那么需要从最后一个序列倒推，中间递归维护即可，最后中间涉及的区间加的操作差分就好了 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int64 read(int f = 1, int64 x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e5+5;int n, q, top;int64 d[N], s[N], f[N];void solve(int64 p, int64 q)&#123; if(!p) return; int r = upper_bound(s+1, s+1+top, p)-s-1; if(!r) d[1] += q, d[p+1] -= q; else f[r] += p/s[r]*q, solve(p%s[r], q);&#125;int main()&#123; s[++top] = n = read(), q = read(); while(q--) &#123; int64 m = read(); while(top&amp;&amp;s[top] &gt;= m) --top; s[++top] = m; &#125; f[top] = 1; for(int i = top; i &gt;= 2; --i) f[i-1] += s[i]/s[i-1]*f[i], solve(s[i]%s[i-1], f[i]); d[1] += f[1], d[s[1]+1] -= f[1]; for(int i = 1; i &lt;= n; ++i) printf("%lld\n", d[i] += d[i-1]); return 0;&#125; Fraction of Fractal 给定一个$n\times m$的黑白网格，保证黑格四连通且至少有一个黑格，求 $k$ 级分形的四联通数量 首先，我们定义对于一个图形定义上下联通为上下对应的位置都为黑色，左右联通同理 那么若 $1$ 级分形若左右联通和上下联通同时存在，答案一定为 $1$，若不是，我们只需要考虑一方面即可，以上下为例 当我们把 $1$ 级分形当作节点，节点与节点之间若联通则有边，则建出的图是若干条链组成的森林，那么 $k$ 级分形的联通块的个数即可用 $v_k-e_k$ 快速计算，$v_k$ 是点数，$e_k$ 是边数，此外还有几个变量 $f_k$ 为 $k$ 级分形上下联通节点个数，$c$ 为 $1$ 级分形黑色方块个数，$a$ 为 $1$ 级分形上下都为黑色的分界线个数，$b$ 为 $1$ 级分形上下联通方块个数 所以我们有 $$f_k\ =\ f_{k-1}\times b，\ v_k\ =\ v_{k-1}\times c\\e_k\ =\ e_{k-1}\times c\ +\ f_{k-1}\times a$$ 边界条件 $f_1=1,\ v_1=1,\ e_1=0$ 通过手模样例即可理解 构造出矩阵转移即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e3+5, P = 1e9+7;struct Matrix&#123; int __[2][2]; Matrix() &#123; memset(__, 0, sizeof(__)); &#125; int* operator [] (const int i) &#123; return __[i]; &#125; Matrix operator * (Matrix &amp;_) const &#123; Matrix ret; for(int i = 0; i &lt; 2; ++i) for(int j = 0; j &lt; 2; ++j) for(int k = 0; k &lt; 2; ++k) ret[i][j] = (ret[i][j]+1ll*__[i][k]*_[k][j]%P)%P; return ret; &#125; void set() &#123; for(int i = 0; i &lt; 2; ++i) __[i][i] = 1; &#125;&#125;f;Matrix qpow(Matrix a, int64 b)&#123; Matrix ret; ret.set(); for( ; b; b &gt;&gt;= 1, a = a*a) if(b&amp;1) ret = ret*a; return ret;&#125;int n, m;int64 k;char s[N][N];int p, q, a, b, c;int main()&#123; n = read(), m = read(); scanf("%lld", &amp;k); for(int i = 1; i &lt;= n; ++i) scanf("%s", s[i]+1); for(int i = 1; i &lt;= n; ++i) p += s[i][1]=='#'&amp;&amp;s[i][m]=='#'; for(int i = 1; i &lt;= m; ++i) q += s[1][i]=='#'&amp;&amp;s[n][i]=='#'; if((p&amp;&amp;q)||k &lt; 2) return puts("1"), 0; b = p|q; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) &#123; c += s[i][j] == '#'; a += s[i][j] == '#'&amp;&amp;s[i][j+1] == '#'&amp;&amp;p; a += s[i][j] == '#'&amp;&amp;s[i+1][j] == '#'&amp;&amp;q; &#125; f[0][0] = c, f[1][0] = a, f[1][1] = b; f = qpow(f, k-1); printf("%d\n", (f[0][0]-f[1][0]+P)%P); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>贪心</tag>
        <tag>思维</tag>
        <tag>素数相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32709102 AGC002]]></title>
    <url>%2F2019%2F07%2F23%2F32709102-AGC002%2F</url>
    <content type="text"><![CDATA[Stamp Rally 一张连通图，$q$ 次询问从两个点 $x$ 和 $y$ 出发，希望经过的不重复点数量等于 $z$，经过的边最大编号最小是多少 在 $Kruskal$ 重构树上倍增二分即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;tuple&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = - 1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 3e5+5;int n, m, q, root;tuple&lt;int, int, int&gt; edge[N];int f[N], w[N], ac[20][N], size[N];int find(int x) &#123; return x == f[x]?x:f[x] = find(f[x]); &#125;int find(int x, int d)&#123; for(int i = 19; ~i; --i) if(w[ac[i][x]] &lt;= d) x = ac[i][x]; return x;&#125;bool valid(int x, int y, int z, int mid)&#123; x = find(x, mid), y = find(y, mid); if(x == y) return size[x] &gt;= z; else return size[x]+size[y] &gt;= z;&#125;int main()&#123; n = read(), m = read(), root = n, w[0] = m+1; for(int i = 1; i &lt;= m; ++i) &#123; int x = read(), y = read(); edge[i] = make_tuple(i, x, y); &#125; for(int x = 1; x &lt;= n; ++x) f[x] = x, size[x] = 1; sort(edge+1, edge+1+m); for(int i = 1; i &lt;= m; ++i) &#123; int x = get&lt;1&gt;(edge[i]), y = get&lt;2&gt;(edge[i]), z = get&lt;0&gt;(edge[i]); x = find(x), y = find(y); if(x == y) continue; f[x] = f[y] = ++root, f[root] = root, w[root] = z; size[root] = size[x]+size[y]; ac[0][x] = root, ac[0][y] = root; &#125; for(int x = root; x; --x) for(int i = 1; i &lt; 20; ++i) ac[i][x] = ac[i-1][ac[i-1][x]]; q = read(); while(q--) &#123; int x = read(), y = read(), z = read(); int l = 1, r = m, ans = 0; while(l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if(valid(x, y, z, mid)) ans = mid, r = mid-1; else l = mid+1; &#125; printf("%d\n", ans); &#125; return 0;&#125; Candy Piles 两人在玩游戏，轮流进行，每次进行将当前最大的那堆糖果全部吃完或将每堆糖果吃掉一个，吃完的人输,假设两人足够聪明，问谁能必胜 将糖果从大到小排列，以下标作为横轴，个数作为数轴，那么这个游戏就转化为从 $(0,\ 0)$，每个人可以向上或向右走，不能走的人输 对于这类博弈问题，有一个结论是对角线上的局面相同，简单证明一下，若 $(x,\ y)$ 必输，那么处在 $(x-1,\ y-1)$ 的人不管怎么走，依旧可以到达 $SG(x,\ y)$，反之亦然 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e5+5;int n, a[N];int main()&#123; n = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read(); sort(a+1, a+1+n); reverse(a+1, a+1+n); for(int i = 1; i &lt;= n; ++i) if(i+1 &gt; a[i+1]) &#123; int ans = 0; for(int j = i+1; a[j] == i; ++j) ans ^= 1; ans |= (a[i]-i)&amp;1; puts(ans?"First":"Second"); return 0; &#125; return 0;&#125; Leftmost Ball 给你 $n$ 种不含白色颜色的球，每个球有 $m$ 个，把这 $n\times m$ 个球排成一排，把每一种颜色的最左边出现的球涂成白色，求有多少种不同的颜色序列 问题转换，有 $n+1$ 种颜色，其中白色有 $n$ 个，其他有 $m-1$ 个，求颜色序列满足任何前缀白色的个数不少于其他颜色的种数的方案数 序列计数 $DP$ 一般可以考虑枚举位置和枚举元素，这里用到后者，考虑状态 $f_{i,\ j}$ 为在 $n\times m$ 个位置上已填了 $i$ 个白球和 $j$ 种其他颜色的球 则有转移方程 $$f_{i,j}\ =\ f_{i-1,j}+f_{i,j-1}\times(n-j+1)\times\binom{n\times m-i-(m-1)\times (j-1)-1}{m-2}$$ 为了不重不漏，我们每次强制让球填在第一个空的位置上，所以 $f_{i,\ j}$ 可以由 $f_{i-1,\ j}$ 多填一个白球转移，也可以由 $f_{i,\ j-1}$ 从剩下 $n-j+1$ 个颜色选择一种颜色填完转移 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e3+5, M = 4e6+5, P = 1e9+7;int n, m, f[N][N], fac[M], ifac[M], inv[M], ans;int C(int n, int m) &#123; return 1ll*fac[n]*ifac[n-m]%P*ifac[m]%P; &#125;int main()&#123; n = read(), m = read(); inv[1] = ifac[0] = fac[0] = 1; for(int i = 2; i &lt;= n*m; ++i) inv[i] = 1ll*(P-P/i)*inv[P%i]%P; for(int i = 1; i &lt;= n*m; ++i) fac[i] = 1ll*i*fac[i-1]%P, ifac[i] = 1ll*inv[i]*ifac[i-1]%P; f[0][0] = 1; for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= i; ++j) &#123; f[i][j] = f[i-1][j]; if(j) f[i][j] = (f[i][j]+1ll*f[i][j-1]*(n-j+1)%P*C(n*m-i-(j-1)*(m-1)-1, m-2)%P)%P; &#125; printf("%d\n", m == 1?1:f[n][n]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
        <tag>思维</tag>
        <tag>最小生成树</tag>
        <tag>构造</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[91709102 AGC001]]></title>
    <url>%2F2019%2F07%2F19%2F91709102-AGC001%2F</url>
    <content type="text"><![CDATA[Mysterious Light 给定光源，求按照题意规则反射的总距离 很容易观察出该题的重复子结构，每次可以看作从一个平行四边形的右下角向外发射，不妨设 $(a,\ b)$ 来表示平行四边形的两边即初始状态有 $(n-x,\ x)$ 我们尝试用 $(a,\ b)$ 推出下一个平行四边形的状态，显然$$(a,\ b)\rightarrow\begin{cases}\ (a-b,\ b),\ a &gt; b\\\ (a,\ b-a),\ b &gt; a\end{cases}$$ 显然终止状态为二元组其中一个变为 $0$ 时 设 $f(a,\ b)$ 为 $(a,\ b)$ 到达终止状态的路径则有 $$f(a,\ b)\ =\\begin{cases}2b+f(a-b,\ b),\ a &gt; b\\2a+f(a,\ b-a),\ b &gt; a\\a,\ a\ = b\end{cases}$$ 很容易观察到这是一个更相减损的过程并用辗转相除优化 进一步的，我们观察最后路径会发现，不重不漏的走过所有轨迹三角形下面的边的路径总长度为 $n-(n,\ x)$，这样即可快速的出答案 12345678910111213141516171819#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;inline int64 read(int64 f = 1, int64 x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;int64 n, x;int main()&#123; n = read(), x = read(); printf("%lld\n", 3*(n-__gcd(n, x))); return 0;&#125; Shorten Diameter 删除一些点，使树的直径小于等于K，当且仅当删除某点不会对树的联通性产生影响时才可以删除，求最少点数 我们注意到 $n$ 的范围，这道题一定是一道枚举，观察到最终的树一定存在一个中心，且当 $n$ 是奇数时，最终中心是一条边，$n$ 是偶数时，最终中心是一条边，枚举中心即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e3+5;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N&lt;&lt;1];int head[N], tot;void _add(int x, int y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;void add(int x, int y) &#123; _add(x, y); _add(y, x); &#125;int n, k;void dfs(int x, int fa, int *d)&#123; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(y == fa) continue; d[y] = d[x]+1; dfs(y, x, d); &#125;&#125;int d[N][N], ans;int main()&#123; n = read(), k = read(), ans = n; for(int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); add(x, y); &#125; for(int x = 1; x &lt;= n; ++x) dfs(x, 0, d[x]); if(k&amp;1) &#123; for(int i = 1; i &lt;= tot; i += 2) &#123; int u = edge[i].to, v = edge[i+1].to, c = 0; for(int y = 1; y &lt;= n; ++y) c += d[u][y] &gt; k/2&amp;&amp;d[v][y] &gt; k/2; ans = min(ans, c); &#125; &#125; else &#123; for(int x = 1; x &lt;= n; ++x) &#123; int c = 0; for(int y = 1; y &lt;= n; ++y) c += d[x][y] &gt; k/2; ans = min(ans, c); &#125; &#125; printf("%d\n", ans); return 0;&#125; Arrays and Palindrome 给定数列 $A$ 并给 $A$ 进行重排序，并构造数列 $B$，满足 $\sum_A=\sum_B$ 并确定两种字符串的回文串划分使得字符串只能由同种字符构造 通过手算样例过程中的推理建成图论模型，注意到这是一个一笔画问题，且 $A$ 中奇数个数不超过 $2$，模拟构造即可 1234567891011121314151617181920212223242526272829#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e5+5;int n, m;int a[N], b[N], cnt, ans;int main()&#123; n = read(), m = read(); for(int i = 1; i &lt;= m; ++i) a[i] = read(), cnt += (a[i]&amp;1); if(cnt &gt; 2) return puts("Impossible"), 0; for(int i = 1; i &lt;= m; ++i) if(a[i]&amp;1) swap(a[i], a[1]), i = m; for(int i = 2; i &lt;= m; ++i) if(a[i]&amp;1) swap(a[i], a[m]); if(a[1] != 1) b[++ans] = a[1]-1; for(int i = 2; i &lt; m; ++i) b[++ans] = a[i]; b[++ans] = n; for(int i = 1; i &lt; ans; ++i) b[ans] -= b[i]; for(int i = 1; i &lt;= m; ++i) printf("%d ", a[i]); puts(""); printf("%d\n", ans); for(int i = 1; i &lt;= ans; ++i) printf("%d ", b[i]); puts(""); return 0;&#125; BBQ Hard 给定数对 $(a,\ b)$ 求 $\sum_{i=1}^n\sum_{j=i+1}^n\binom{a_i+b_i+a_j+b_j}{a_i+a_j}$ 考虑 $\binom{a_i+b_i+a_j+b_j}{a_i+a_j}$ 的几何意义，即从 $(0,\ 0)$ 向上或向左到达 $(a_i+a_j,\ b_i+b_j)$ 的方案数，所以不妨平移一下即有 $(-a_i,\ -b_i)$ 到 $(a_j,\ b_j)$ 的方案数， $O(n^2)$ 的 $DP$ 即可 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e5+5, M = 4000+5, B = 2001, P = 1e9+7;int n, a[N], b[N], fac[N], inv[N], ifac[N];int f[M][M], ans;int C(int n, int m) &#123; return 1ll*fac[n]*ifac[n-m]%P*ifac[m]%P; &#125;int main()&#123; n = N-5, inv[1] = fac[0] = ifac[0] = 1; for(int i = 2; i &lt;= n; ++i) inv[i] = 1ll*(P-P/i)*inv[P%i]%P; for(int i = 1; i &lt;= n; ++i) fac[i] = 1ll*fac[i-1]*i%P, ifac[i] = 1ll*ifac[i-1]*inv[i]%P; n = read(); for(int i = 1; i &lt;= n; ++i) a[i] = read(), b[i] = read(), ++f[B-a[i]][B-b[i]]; for(int i = 1; i &lt; M; ++i) for(int j = 1; j &lt; M; ++j) f[i][j] = (f[i][j]+(f[i-1][j]+f[i][j-1])%P)%P; for(int i = 1; i &lt;= n; ++i) ans = (ans+f[B+a[i]][B+b[i]])%P, ans = (1ll*ans+P-C(2*(a[i]+b[i]), 2*a[i]))%P; ans = 1ll*ans*inv[2]%P; printf("%d\n", ans); return 0;&#125; Wide Swap 给定排列 $P$，当且仅当 $i,\ j$ 满足 $|p_i-p_j|=1$ 且 $|i-j|\ge k$ 是可以交换 $p_i$ 和 $p_j$ 求最终字典序最小的排列 直接用题干的条件做极其困难，所以有一种十分启发性的想法 我们把下标和权值交换位置，即构造序列 $q_{p_i}\ =\ i$ 我们发现这样构造拥有十分好的性质 首先交换就变成当 $|q_i-q_{i+1}|\ge k$ 时交换 $q_i$ 和 $q_{i+1}$ 所以对于 $q_i$ 而言，$q_j\in\ [q_i-k+1,\ q_i+k-1]$ 永远不会在它前面 其次，最终要求的字典序最小可以理解为下标尽量小，权值尽量小，拓扑排序过程贪心即可 同时我们手算样例的过程中发现建图可以优化边数，用线段树维护偏序即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 5e5+5, INF = 0x3f3f3f3f;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N&lt;&lt;1];int tot, head[N], in[N];void add(int x, int y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; ++in[y]; &#125;int val[N&lt;&lt;2];void change(int x, int l, int r, int pos, int d)&#123; val[x] = min(val[x], d); if(l == r) return; int mid = (l+r)&gt;&gt;1; if(pos &lt;= mid) return change(x&lt;&lt;1, l, mid, pos, d); else return change(x&lt;&lt;1|1, mid+1, r, pos, d);&#125;int query(int x, int l, int r, int ql, int qr)&#123; if(ql &gt; qr) return INF; if(ql &lt;= l&amp;&amp;r &lt;= qr) return val[x]; int ret = INF, mid = (l+r)&gt;&gt;1; if(ql &lt;= mid) ret = min(ret, query(x&lt;&lt;1, l, mid, ql, qr)); if(qr &gt; mid) ret = min(ret, query(x&lt;&lt;1|1, mid+1, r, ql, qr)); return ret;&#125;int n, m, k, ans[N], p[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;int main()&#123; memset(val, 0x3f, sizeof(val)); n = read(), k = read(); for(int i = 1; i &lt;= n; ++i) p[read()] = i; for(int x = n, y; x; --x) &#123; y = query(1, 1, n, max(p[x]-k+1, 1), p[x]-1); if(y != INF) add(x, y); y = query(1, 1, n, p[x]+1, min(p[x]+k-1, n)); if(y != INF) add(x, y); change(1, 1, n, p[x], x); &#125; for(int x = 1; x &lt;= n; ++x) if(!in[x]) q.push(make_pair(-p[x], x)); while(q.size()) &#123; int x = q.top().second; q.pop(); ++m; ans[p[x]] = m; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(--in[y] == 0) q.push(make_pair(-p[y], y)); &#125; &#125; for(int i = 1; i &lt;= n; ++i) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>思维</tag>
        <tag>数论</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LGR-059]缩小社交圈]]></title>
    <url>%2F2019%2F07%2F15%2FLGR-059-%E7%BC%A9%E5%B0%8F%E7%A4%BE%E4%BA%A4%E5%9C%88%2F</url>
    <content type="text"><![CDATA[题面描述给定区间集合，交集不为空的互相连边，求所有生成树数量 题解看见生成树就想到了矩阵树定理骗分，结果发现审错题了，就自闭了 智商什么时候可以练上去啊 根据题意，最后树的形态一定是有区间可以向只有相交关系的区间连边，且后者连的区间不能与其相交，向自己子区间连边时，子区间不能相交并且从中我们可以看到一个区间能被正常计算，只有当其子区间已被计算过了，所以我们需要排序，按右端点为第一关键字，左端点为第二关键字排序即可 最后用前缀和优化即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f =-1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x; &#125;const int N = 4e3+5, P = 1e9+7;int n;pair&lt;int, int&gt; p[N];int pl[N], pr[N], f[N][N], g[N][N], h[N][N], ans;int main()&#123; n = read(); for(int i = 1; i &lt;= n; ++i) &#123; int l = read(), r = read(); p[i] = make_pair(r, l); &#125; sort(p+1, p+1+n); for(int i = 1; i &lt;= n; ++i) pl[i] = p[i].second, pr[i] = p[i].first; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= i; ++j) &#123; if(pl[j] &lt; pl[i]&amp;&amp;pl[i] &lt;= pr[j]) &#123; int k = lower_bound(pr+1, pr+1+n, pl[i])-pr-1; f[i][j] = (1+g[j][k])%P; &#125; else if(pl[i] &lt;= pl[j]&amp;&amp;pr[j] &lt;= pr[i]) &#123; int k = lower_bound(pr+1, pr+1+n, pl[j])-pr-1; f[i][j] = (1+g[i][k])%P; &#125; ans = (ans+f[i][j])%P, g[i][j] = (g[i][j-1]+f[i][j])%P; &#125; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LUOGU4859]已经没有什么好害怕的了]]></title>
    <url>%2F2019%2F07%2F15%2FLUOGU4859-%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86%2F</url>
    <content type="text"><![CDATA[题面描述给定集合 $A$ 和 $B$，求完全匹配满足 $\sum[a_i&gt;b_i]-[a_i\le b_i]=k$ 的方案数 题解首先，题意即是要求匹配满足 $\sum[a_i&gt;b_i]=\frac{n+k}{2}$ 的方案数，假设状态 $h_{i,j}$ 表示前 $i$ 个 匹配满足 $\sum[a_k&gt;b_k]=j$ 的方案数 考虑转移的顺序，发现对于当前决策$a_k&gt;b_k$而言，必须考虑当前状态下有多少满足的 $b_k$，这就要求我们一开始把两者排序，则当前符合决策的 $b_k$ 必定有 $j$ 个已选，即有转移 $$h_{i,j}\ =\ h_{i-1,j}+h_{i-1,j-1}\times(less_i-(j-1))$$我们发现对于 $h_{n,k}$ 而言，我们得出并不是合法方案，因为中间放弃匹配的 $a$ 最后必须匹配，所以 $h_{n,k}\times(n-k)!$ 就是至少选出 $k$ 个匹配的方案数 不妨设 $f_k$ 为恰好为 $k$ 组的方案数，$g_k$ 为至少为 $k$ 组的方案数，注意到 $f_i$ 与 $f_j$ 表示的集合无交集，发现 $f$ 和 $g$ 正好满足 $$g_k\ =\ \sum_{i=k}^n\binom{i}{k}f_k$$ 根据二项式反演 $$f_k\ =\ \sum_{i=k}^n(-1)^{i-k}\binom{i}{k}g_k$$ 最后求解即可 实际上这就是广义容斥的至少到恰好的运用 若有集合 $S_1$，$S_2$，$S_3$， … $S_n$ 和指标集 $\mathcal{I}$，和作用于指标集的函数 $f$ 和 $g$ 有 $$f(I)\ =\ |\bigcap_{\alpha\in I}S_{\alpha}-\bigcup_{\alpha\notin I}S_{\alpha}|$$ 即 $f(I)$ 满足元素恰好在指标集 $I$ 所代表的集合的交中，而不在其他不属于 $I$ 的集合中 $$g(I)\ =\ |\bigcap_{\alpha\in I}S_{\alpha}|$$ 即 $g(I)$ 满足至少在指标集 $I$ 的元素个数 $$g(I)\ =\ \sum_{I\subseteq J}f(J)$$ 则有 $$f(I)\ =\ \sum_{I\subseteq J}(-1)^{|J|-|I|}g(J)$$ 而在这道题的对于我们就是把 $S_i$ 表示 $a_i$ 的所配对的 $b_i$ 有 $a_i&gt;b_i$，在这个意义下使用广义容斥罢了 特别的，假如说对于 $|I|$ 一定的子集的贡献可以统一起来用组合数计算贡献时，广义容斥即派生出组合广义容斥 此外，对于 $$g(I)\ =\ |\bigcup_{\alpha\in I}S_{\alpha}-\bigcup_{\alpha\notin I}S_{\alpha}|$$ $g(I)$ 表示至多在指标集 $I$ 的元素个数，有 $$g(I)\ =\ \sum_{J\subseteq I}f(J)$$$$f(I)\ =\ \sum_{J\subseteq I}(-1)^{|I|-|J|}g(J)$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e3+5, P = 1e9+9;int qpow(int a, int b) &#123; int ret = 1; for( ; b; b &gt;&gt;= 1, a = 1ll*a*a%P) if(b&amp;1) ret = 1ll*ret*a%P; return ret; &#125;int n, k, a[N], b[N];int h[N][N], f[N], g[N], res[N];int fac[N], ifac[N];int C(int n, int m) &#123; return 1ll*fac[n]*ifac[n-m]%P*ifac[m]%P; &#125;int main()&#123; n = read(), k = read(); fac[0] = ifac[0] = 1; if((n+k)&amp;1) return puts("0"), 0; k = (n+k)/2; for(int i = 1; i &lt;= n; ++i) a[i] = read(); for(int i = 1; i &lt;= n; ++i) b[i] = read(); for(int i = 1; i &lt;= n; ++i) fac[i] = 1ll*fac[i-1]*i%P; ifac[n] = qpow(fac[n], P-2); for(int i = n-1; i; --i) ifac[i] = 1ll*ifac[i+1]*(i+1)%P; sort(a+1, a+1+n); sort(b+1, b+1+n); for(int i = 1, p = 0; i &lt;= n; ++i) &#123; for( ; p &lt; n&amp;&amp;b[p+1] &lt; a[i]; ++p); res[i] = p; &#125; h[0][0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; h[i][0] = h[i-1][0]; for(int j = 1; j &lt;= i; ++j) h[i][j] = (h[i-1][j]+1ll*h[i-1][j-1]*max(0, res[i]-j+1)%P)%P; &#125; for(int i = 0; i &lt;= n; ++i) g[i] = 1ll*h[n][i]*fac[n-i]%P; for(int i = k; i &lt;= n; ++i) if((i-k)&amp;1) f[k] = (f[k]+P-1ll*C(i, k)*g[i]%P)%P; else f[k] = (f[k]+1ll*C(i, k)*g[i]%P)%P; printf("%d\n", f[k]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2013]游走]]></title>
    <url>%2F2019%2F07%2F13%2FHNOI2013-%E6%B8%B8%E8%B5%B0%2F</url>
    <content type="text"><![CDATA[题面描述在图上随机游走，有一个终止节点，每次经过获得该边权的分数，构造边权赋值方案，使获得的边数期望次数最小。 题解首先，初步转换为算出每条边的期望经过次数，期望经过次数小的边权大 之后，我们发现直接求边的期望不好求，即转化为点的期望，列出等式$$E(U)=[u=1]+\sum_{(u,v)\in E}\frac{E(V)}{d_v}[\ v \ne n]$$ 意义是每次可以由四周过来，$n$ 是终止节点不能再过来，$1$ 一开始出现了一次 高斯消元即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;const int N = 500+5;const double EPS = 1e-6;struct Matrix&#123; int n, m; double __mat[N][N]; Matrix(int n = 0, int m = 0):n(n), m(m) &#123; memset(__mat, 0, sizeof(__mat)); &#125; double* operator[] (const int i) &#123; return __mat[i]; &#125; void change(int i, double r, int j) &#123; for(int k = 1; k &lt;= m; ++k) __mat[j][k] += __mat[i][k]*r; &#125; void exchange(int i, int j) &#123; for(int k = 1; k &lt;= m; ++k) swap(__mat[i][k], __mat[j][k]); &#125;&#125;A, B;int n, m, deg[N];int u[N*N], v[N*N];double f[N*N], ans;void Gauss(Matrix &amp;A, Matrix &amp;B)&#123; int n = A.n, p; for(int i = 1, c = 1; i &lt;= n; ++i) &#123; for(p = c; p &lt;= n&amp;&amp;fabs(A[c][i]) &lt; EPS; ++p); if(p == n+1) continue; A.exchange(p, c); B.exchange(p, c); for(int j = c+1; j &lt;= n; ++j) B.change(c, -A[j][i]/A[c][i], j), A.change(c, -A[j][i]/A[c][i], j); ++c; &#125; for(int i = n; i; --i) &#123; B[i][1] /= A[i][i], A[i][i] = 1; for(int j = i-1; j; --j) B[j][1] -= A[j][i]*B[i][1], A[j][i] = 0; &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); A = Matrix(n-1, n-1); B = Matrix(n-1, 1); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u[i], &amp;v[i]); ++deg[u[i]], ++deg[v[i]]; &#125; for(int i = 1; i &lt; n; ++i) A[i][i] = 1; B[1][1] = 1; for(int i = 1; i &lt;= m; ++i) &#123; if(deg[v[i]]&amp;&amp;v[i] != n) A[u[i]][v[i]] += -1.0/deg[v[i]]; if(deg[u[i]]&amp;&amp;u[i] != n) A[v[i]][u[i]] += -1.0/deg[u[i]]; &#125; Gauss(A, B); for(int i = 1; i &lt;= m; ++i) &#123; if(u[i] != n) f[i] += B[u[i]][1]/deg[u[i]]; if(v[i] != n) f[i] += B[v[i]][1]/deg[v[i]]; &#125; sort(f+1, f+1+m); for(int i = 1; i &lt;= m; ++i) ans += (m-i+1)*f[i]; printf("%.3lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2164]采矿]]></title>
    <url>%2F2019%2F07%2F11%2FBZOJ2164-%E9%87%87%E7%9F%BF%2F</url>
    <content type="text"><![CDATA[题面描述支持修改点权，维护子树内和链上的的背包。 题解用线段树维护一下背包就好了，但不管怎么 $O(m^2)$ 常数的更新的复杂度避免不了读入过于毒瘤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;typedef long long int64;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e4+5, M = 50+5;const int X = 1&lt;&lt;16, Y = ~0u&gt;&gt;1;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N];int tot, head[N];inline void add(int x, int y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;int n, m, A, B, Q, T;int64 tab[N][M];inline int getint()&#123; A=((A^B)+(B/X)+(B*X))&amp;Y; B=((A^B)+(A/X)+(A*X))&amp;Y; return (A^B)%Q;&#125;int fa[N], top[N], size[N], d[N], dfn[N], nfd[N], son[N], t;void dfs(int x)&#123; size[x] = 1, d[x] = d[fa[x]]+1; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; dfs(y); size[x] += size[y]; son[x] = size[son[x]]&gt;size[y]?son[x]:y; &#125;&#125;void dfs(int x, int topf)&#123; dfn[x] = ++t, top[x] = topf, nfd[t] = x; if(son[x]) dfs(son[x], topf); for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(son[x] != y) dfs(y, y); &#125;&#125;struct Bag&#123; int64 f[M]; Bag() &#123; for(int i = 0; i &lt;= m; ++i) f[i] = 0; &#125; Bag operator + (const Bag &amp;_) const &#123; Bag ret; for(int i = 0; i &lt;= m; ++i) ret.f[i] = max(f[i], _.f[i]); return ret; &#125; Bag operator * (const Bag &amp;_) const &#123; Bag ret; for(int i = 0; i &lt;= m; ++i) for(int j = 0; j &lt;= m-i; ++j) ret.f[i+j] = max(ret.f[i+j], f[i]+_.f[j]); return ret; &#125;&#125;b1[N&lt;&lt;2], b2[N&lt;&lt;2];void pushup(int x) &#123; b1[x] = b1[x&lt;&lt;1]+b1[x&lt;&lt;1|1]; b2[x] = b2[x&lt;&lt;1]*b2[x&lt;&lt;1|1]; &#125;void build(int x, int l, int r)&#123; if(l == r) return (void)(memcpy(b1[x].f, tab[nfd[l]], sizeof(b1[x].f)), b2[x] = b1[x]); int mid = (l+r)&gt;&gt;1; build(x&lt;&lt;1, l, mid); build(x&lt;&lt;1|1, mid+1, r); pushup(x);&#125;void change(int x, int l, int r, int pos)&#123; if(l == r) return (void)(memcpy(b1[x].f, tab[nfd[l]], sizeof(b1[x].f)), b2[x] = b1[x]); int mid = (l+r)&gt;&gt;1; if(pos &lt;= mid) change(x&lt;&lt;1, l, mid, pos); else change(x&lt;&lt;1|1, mid+1, r, pos); pushup(x);&#125;Bag query1(int x, int l, int r, int ql, int qr)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return b1[x]; int mid = (l+r)&gt;&gt;1; Bag ret; if(ql &lt;= mid) ret = ret+query1(x&lt;&lt;1, l, mid, ql, qr); if(qr &gt; mid) ret = ret+query1(x&lt;&lt;1|1, mid+1, r, ql, qr); return ret;&#125;Bag query2(int x, int l, int r, int ql, int qr)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return b2[x]; int mid = (l+r)&gt;&gt;1; Bag ret; if(ql &lt;= mid) ret = ret*query2(x&lt;&lt;1, l, mid, ql, qr); if(qr &gt; mid) ret = ret*query2(x&lt;&lt;1|1, mid+1, r, ql, qr); return ret;&#125;Bag query(int x, int y)&#123; Bag ret; if(x == y) return ret; x = fa[x]; while(top[x] != top[y]) ret = ret+query1(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]; ret = ret+query1(1, 1, n, dfn[y], dfn[x]); return ret;&#125;int main()&#123; n = read(), m = read(), A = read(), B = read(), Q = read(); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= m; ++j) tab[i][j] = getint(); sort(tab[i]+1, tab[i]+m+1); &#125; for(int x = 2; x &lt;= n; ++x) add(fa[x] = read(), x); dfs(1); dfs(1, 1); build(1, 1, n); T = read(); while(T--) &#123; int opt = read(), x = read(), y; if(opt == 0) &#123; for(int i = 1; i &lt;= m; ++i) tab[x][i] = getint(); sort(tab[x]+1, tab[x]+m+1); change(1, 1, n, dfn[x]); &#125; else &#123; y = read(); Bag ans = query(x, y)*query2(1, 1, n, dfn[x], dfn[x]+size[x]-1); printf("%lld\n", ans.f[m]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3589]动态树]]></title>
    <url>%2F2019%2F07%2F11%2FBZOJ3589-%E5%8A%A8%E6%80%81%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题面描述求若干条树链的并 题解做法有很多，首先是用容斥把树链的并转化为树链的交，或者是建出虚树，利用 $dfs$ 序虚树求值，但两者细节较多，所以直接用线段树的区间覆盖标记了虚树的性质挺巧妙的，可能之后会整理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e5+5;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N&lt;&lt;2];int tot, head[N];void _add(int x, int y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;void add(int x, int y) &#123; _add(x, y); _add(y, x); &#125;int n, T;int size[N], son[N], top[N], fa[N], dfn[N], nfd[N], d[N], t;void dfs1(int x, int f)&#123; fa[x] = f, d[x] = d[f]+1, size[x] = 1; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(y == f) continue; dfs1(y, x); size[x] += size[y]; son[x] = size[son[x]]&gt;size[y]?son[x]:y; &#125;&#125;void dfs2(int x, int topf)&#123; top[x] = topf, dfn[x] = ++t, nfd[t] = x; if(son[x]) dfs2(son[x], topf); for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(fa[x] == y||son[x] == y) continue; dfs2(y, y); &#125;&#125;int v[N&lt;&lt;2], a[N&lt;&lt;2], val[N&lt;&lt;2], cov[N&lt;&lt;2];void pusha(int x, int l, int r, int d) &#123; v[x] += d*(r-l+1), a[x] += d; &#125;void pushup(int x) &#123; v[x] = v[x&lt;&lt;1]+v[x&lt;&lt;1|1]; val[x] = val[x&lt;&lt;1]+val[x&lt;&lt;1|1]; &#125;void pushc(int x, int d) &#123; val[x] = v[x]*(d-1), cov[x] = d; &#125;void pushdown(int x, int l, int r)&#123; int mid = (l+r)&gt;&gt;1, d = a[x]; a[x] = 0; pusha(x&lt;&lt;1, l ,mid, d); pusha(x&lt;&lt;1|1, mid+1, r, d); if(cov[x]) pushc(x&lt;&lt;1, cov[x]), pushc(x&lt;&lt;1|1, cov[x]), cov[x] = 0;&#125;int query(int x, int l, int r, int ql, int qr)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return val[x]; int mid = (l+r)&gt;&gt;1; int ret = 0; pushdown(x, l, r); if(ql &lt;= mid) ret += query(x&lt;&lt;1, l, mid, ql, qr); if(qr &gt; mid) ret += query(x&lt;&lt;1|1, mid+1, r, ql, qr); return ret;&#125;void add(int x, int l, int r, int ql, int qr, int d)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return pusha(x, l, r, d); int mid = (l+r)&gt;&gt;1; pushdown(x, l, r); if(ql &lt;= mid) add(x&lt;&lt;1, l, mid, ql, qr, d); if(qr &gt; mid) add(x&lt;&lt;1|1, mid+1, r, ql, qr, d); pushup(x);&#125;void change(int x, int l, int r, int ql, int qr, int d)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return pushc(x, d); int mid = (l+r)&gt;&gt;1; pushdown(x, l, r); if(ql &lt;= mid) change(x&lt;&lt;1, l, mid, ql, qr, d); if(qr &gt; mid) change(x&lt;&lt;1|1, mid+1, r, ql, qr, d); pushup(x); &#125;void color(int x, int y)&#123; while(top[x] != top[y]) &#123; if(d[top[x]] &lt; d[top[y]]) swap(x, y); change(1, 1, n, dfn[top[x]], dfn[x], 2); x = fa[top[x]]; &#125; if(d[x] &lt; d[y]) swap(x, y); change(1, 1, n, dfn[y], dfn[x], 2);&#125;int p[N];bool cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;int main()&#123; n = read(); pushc(1, 1); for(int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); add(x, y); &#125; dfs1(1, 0); dfs2(1, 1); T = read(); while(T--) &#123; int opt = read(), x, y, k, ans = 0; if(opt == 0) x = read(), k = read(), add(1, 1, n, dfn[x], dfn[x]+size[x]-1, k); else &#123; k = read(); for(int i = 1; i &lt;= k; ++i) x = read(), y = read(), color(x, y); printf("%d\n", val[1]&amp;0x7fffffff); pushc(1, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF997E Good Subsegments]]></title>
    <url>%2F2019%2F07%2F10%2FCF997E-Good-Subsegments%2F</url>
    <content type="text"><![CDATA[题面描述询问区间内所有满足重排后连续的区间个数 题解第一道真正利用线段树历史标记的题 终于知道线段树统计子区间问题的一种方法了 结合 [CERC2017]Intrinsic Interval 食用更佳 考虑把操作离线，枚举每个右端点 $r$，对于左端点 $l$ 记录 $cnt+l-r$，$cnt$ 为区间 $[l,\ r]$ 的满足 $|a-b|&lt;1$ 的无序数对 $(a,\ b)$ 的数量，当一个区间合法当且仅当 $cnt+l-r=0$，其余情况 $cnt+l-r\le r$，在线段树上维护最大值和最大值出现次数，每次右端点移动时用合法的相邻的数统计一下即可下面就是如何维护子区间的问题了，我们引入一个新的标记 $ti$，用于累计历史最大值及其次数的贡献，每次下传时，当且仅当 $maxv_{fa}\ =\ maxv_{son}$ 是下传 $ti$，并累计贡献，同时注意 $add$ 和 $ti$ 的顺序，应下传 $add$ 再下传 $ti$，子节点有还未更新到合法状态 细节见注释 本来以为比单调栈的做法常数小，但其实差的也不多 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 12e4+5;int64 val[N&lt;&lt;2];int c[N&lt;&lt;2], v[N&lt;&lt;2], ti[N&lt;&lt;2], a[N&lt;&lt;2];void pusha(int x, int d) &#123; v[x] += d, a[x] += d; &#125;void pushti(int x, int d) &#123; val[x] += d*c[x], ti[x] += d; &#125;void pushdown(int x)&#123; if(a[x]) pusha(x&lt;&lt;1, a[x]), pusha(x&lt;&lt;1|1, a[x]), a[x] = 0; if(ti[x]) &#123; if(v[x] == v[x&lt;&lt;1]) pushti(x&lt;&lt;1, ti[x]); if(v[x] == v[x&lt;&lt;1|1]) pushti(x&lt;&lt;1|1, ti[x]); ti[x] = 0; &#125;&#125;void pushup(int x)&#123; v[x] = max(v[x&lt;&lt;1], v[x&lt;&lt;1|1]); c[x] = 0; if(v[x] == v[x&lt;&lt;1]) c[x] += c[x&lt;&lt;1]; if(v[x] == v[x&lt;&lt;1|1]) c[x] += c[x&lt;&lt;1|1]; val[x] = val[x&lt;&lt;1]+val[x&lt;&lt;1|1];&#125;void build(int x, int l, int r)&#123; if(l == r) return void(c[x] = 1); int mid = (l+r)&gt;&gt;1; build(x&lt;&lt;1, l, mid); build(x&lt;&lt;1|1, mid+1, r);&#125;void change(int x, int l, int r, int ql, int qr, int d)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return pusha(x, d); int mid = (l+r)&gt;&gt;1; pushdown(x); if(ql &lt;= mid) change(x&lt;&lt;1, l, mid, ql, qr, d); if(qr &gt; mid) change(x&lt;&lt;1|1, mid+1, r, ql, qr, d); pushup(x);&#125;int64 query(int x, int l, int r, int ql, int qr)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return val[x]; int mid = (l+r)&gt;&gt;1; int64 ret = 0; pushdown(x); if(ql &lt;= mid) ret += query(x&lt;&lt;1, l, mid, ql, qr); if(qr &gt; mid) ret += query(x&lt;&lt;1|1, mid+1, r, ql, qr); return ret;&#125;int n, m, f[N], g[N];vector&lt;pair&lt;int, int&gt; &gt; s[N];int64 ans[N];int main()&#123; n = read(); build(1, 1, n); for(int i = 1; i &lt;= n; ++i) f[i] = read(), g[f[i]] = i; m = read(); for(int i = 1; i &lt;= m; ++i) &#123; int l = read(), r = read(); s[r].push_back(make_pair(l, i)); &#125; for(int i = 1; i &lt;= n; ++i) &#123; pusha(1, -1); change(1, 1, n, i, i, i); // 只能依次加，否则 cnt+l-r &lt;= 0 性质不满足 if(f[i] != 1&amp;&amp;g[f[i]-1] &lt; i) change(1, 1, n, 1, g[f[i]-1], 1); if(f[i] != n&amp;&amp;g[f[i]+1] &lt; i) change(1, 1, n, 1, g[f[i]+1], 1); pushti(1, 1); for(int k = 0; k &lt; s[i].size(); ++k) ans[s[i][k].second] = query(1, 1, n, s[i][k].first, i); &#125; for(int i = 1; i &lt;= m; ++i) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CERC2017]Intrinsic Interval]]></title>
    <url>%2F2019%2F07%2F10%2FCERC2017-Intrinsic-Interval%2F</url>
    <content type="text"><![CDATA[题面描述求一个区间被包含的最短重排后连续区间。 题解判断区间是否连续有一个十分显然的做法，即判断 $max-min=r-l$，但是这样的做法并不能很好维护 但我们发现该区间重排后为等差数列，所以我们可以认为一个区间满足 $|a-b|\le 1$ 的无序数对 $(a,\ b)$ 个数为 $r-l$，那么这个区间合法这就十分容易维护了，把询问离线，考虑枚举右端点 $r$，首先每次移动只会因为前面有没有和 $p_r$ 绝对值相差超过 $1$ 而产生贡献，对于每个 $l$ 维护 $cnt+l$ 的值，由于 $cnt\le r-l$ 那么在相应区间查最大值即可，在用一个堆维护合法询问，这个题就解决了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e5+5;int n, m;int val[N&lt;&lt;2], add[N&lt;&lt;2], p[N&lt;&lt;2];void pusha(int x, int d) &#123; add[x] += d, val[x] += d; &#125;void pushdown(int x) &#123; if(add[x]) pusha(x&lt;&lt;1, add[x]), pusha(x&lt;&lt;1|1, add[x]), add[x] = 0; &#125;void pushup(int x) &#123; if(val[x&lt;&lt;1] &gt; val[x&lt;&lt;1|1]) p[x] = p[x&lt;&lt;1], val[x] = val[x&lt;&lt;1]; else val[x] = val[x&lt;&lt;1|1], p[x] = p[x&lt;&lt;1|1];&#125;void build(int x, int l, int r)&#123; if(l == r) return void(val[x] = p[x] = l); int mid = (l+r)&gt;&gt;1; build(x&lt;&lt;1, l, mid), build(x&lt;&lt;1|1, mid+1, r); pushup(x);&#125;void change(int x, int l, int r, int ql, int qr, int d)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return pusha(x, d); int mid = (l+r)&gt;&gt;1; pushdown(x); if(ql &lt;= mid) change(x&lt;&lt;1, l, mid, ql, qr, d); if(qr &gt; mid) change(x&lt;&lt;1|1, mid+1, r, ql, qr, d); pushup(x);&#125;int ansl, ansr;void query(int x, int l, int r, int ql, int qr)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return (void)(ansl = ansr&lt;=val[x]?p[x]:ansl, ansr = max(ansr, val[x])); int mid = (l+r)&gt;&gt;1; pushdown(x); if(ql &lt;= mid) query(x&lt;&lt;1, l, mid, ql, qr); if(qr &gt; mid) query(x&lt;&lt;1|1, mid+1, r, ql, qr);&#125;pair&lt;int, int&gt; ans[N];bool valid(pair&lt;int, int&gt; p, int r)&#123; ansr = -1; query(1, 1, n, 1, p.first); if(ansr == r) return ans[p.second] = make_pair(ansl, ansr), true; else return false;&#125;int f[N], g[N];vector&lt;pair&lt;int, int&gt; &gt; s[N];priority_queue&lt;pair&lt;int, int&gt; &gt; q;int main()&#123; n = read(); build(1, 1, n); for(int i = 1; i &lt;= n; ++i) f[i] = read(), g[f[i]] = i; m = read(); for(int i = 1; i &lt;= m; ++i) &#123; int l = read(), r = read(); s[r].push_back(make_pair(l, i)); &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(f[i] != 1&amp;&amp;g[f[i]-1] &lt; i) change(1, 1, n, 1, g[f[i]-1], 1); if(f[i] != n&amp;&amp;g[f[i]+1] &lt; i) change(1, 1, n, 1, g[f[i]+1], 1); for(int k = 0; k &lt; s[i].size(); ++k) q.push(s[i][k]); while(q.size()&amp;&amp;valid(q.top(), i)) q.pop(); &#125; for(int i = 1; i &lt;= m; ++i) printf("%d %d\n", ans[i].first, ans[i].second); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>构造</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LUOGU4299]首都]]></title>
    <url>%2F2019%2F07%2F06%2FLUOGU4299-%E9%A6%96%E9%83%BD%2F</url>
    <content type="text"><![CDATA[题面描述动态维护树的重心 题解树的重心就是满足以重心为根时子节点所在最大子树最小的点 树的重心的性质 树的重心为根是子节点所在最大子树大小不超过整体的一半 树的所有点到重心的简单路径和最小 两个联通块合并时，新的树的重心必定在原来两个联通块树的重心的简单路径上 简单证明一下对于性质 $1$，假如说树的重心所在子树大小超过一半，那么除去这个子树剩下的部分大小小于一半，所以一定可以向这个子树方向上调整使最大的子树大小减小 对于性质 $2$，考虑最优决策点为 $x$，所有到 $x$ 的简单路径长度之和为 $f$，则与它相邻的节点 $y$ 到其的长度之和为 $f+S-2size_y$那么 $x$ 比周围节点优的条件为 $S-2size_y\ge0$ 即 $size_y\le\frac{1}{2}S$，满足重心的性质 对于性质 $3$，在连线上的点的最大子树一定是重心方向上，假设不在重心方向，那么原来两个子树重心就不合法了，可以向该点调整，对于不在子树上的点，它的最大子树，方向在连线上，如果不在，那么原来没有前者优 这道题关键在于如何处理这条树链，我们单独把这个树链抽出来，在对应 $splay$ 上二分，求出每个节点向两个方向的最大子树，每次向更大子树移动即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e5+5;int n, q;int c[N][2], fa[N], s[N], si[N], rev[N];bool nroot(int x) &#123; return c[fa[x]][0] == x||c[fa[x]][1] == x; &#125;void pushup(int x) &#123; if(x) s[x] = s[c[x][0]]+s[c[x][1]]+si[x]+1; &#125;void pushr(int x) &#123; if(x) rev[x] ^= 1, swap(c[x][0], c[x][1]); &#125;void pushdown(int x) &#123; if(rev[x]) pushr(c[x][0]), pushr(c[x][1]), rev[x] = 0; &#125;void pushall(int x) &#123; if(nroot(x)) pushall(fa[x]); pushdown(x); &#125;void rotate(int x)&#123; int y = fa[x], z = fa[y], k = c[y][1] == x, w = c[x][!k]; if(nroot(y)) c[z][c[z][1] == y] = x; c[x][!k] = y; c[y][k] = w; if(w) fa[w] = y; fa[y] = x; fa[x] = z; pushup(y);&#125;void splay(int x)&#123; pushall(x); while(nroot(x)) &#123; int y = fa[x], z = fa[y]; if(nroot(y)) rotate(c[y][1] == x^c[z][1] == y?x:y); rotate(x); &#125; pushup(x);&#125;void access(int x)&#123; for(int y = 0; x; x = fa[y = x]) splay(x), si[x] += s[c[x][1]], si[x] -= s[c[x][1] = y], pushup(x);&#125;void makeroot(int x) &#123; access(x); splay(x); pushr(x); &#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y); &#125;void link(int x, int y)&#123; split(x, y); si[fa[x] = y] += s[x]; pushup(y);&#125;int f[N];int find(int x) &#123; return x == f[x]?x:f[x] = find(f[x]); &#125;int update(int x)&#123; int is_odd, hal, sil, sir, p; is_odd = s[x]&amp;1, hal = s[x]&gt;&gt;1, sil = sir = 0, p = n+1; while(x) &#123; pushdown(x); int sl = sil+s[c[x][0]], sr = sir+s[c[x][1]]; if(sl &lt;= hal&amp;&amp;sr &lt;= hal&amp;&amp;(is_odd||p &gt; x)) p = x; if(sl &lt; sr) sil = sl+si[x]+1, x = c[x][1]; else sir = sr+si[x]+1, x = c[x][0]; &#125; splay(p); return p;&#125;int ans;int main()&#123; n = read(), q = read(); for(int x = 1; x &lt;= n; ++x) f[x] = x, s[x] = 1, ans ^= x; while(q--) &#123; char op[7]; int x, y, z; scanf("%s", op); if(op[0] == 'A') &#123; x = read(), y = read(); link(x, y); split(x = find(x), y = find(y)); z = update(y); ans ^= x^y^z; f[x] = f[y] = f[z] = z; &#125; else if(op[0] == 'Q') x = read(), printf("%d\n", find(x)); else printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ1396]识别子串]]></title>
    <url>%2F2019%2F07%2F05%2FBZOJ1396-%E8%AF%86%E5%88%AB%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述求字符串每个位置被包含且出现只有一次的最短子串长度。 题解$SAM$ 部分很好想，关键是如何用线段树维护，我们假设当前位置为 $r$，对应的 $np$ 节点为 $x$，则有左端点 $l\ =\ r-maxlen(parent(x))$ 在区间 $[l,\ r]$ 内最小值为 $maxlen(parent(x))+1$ 并且对于区间 $[1,\ l-1]$ 每个位置 $i$ 来说，答案更新为 $r-i+1$，前面的信息很好维护，对于后面的位置来说，我们只需要做到单点查询，所以可以把 $i$ 挪到外面，用另外一颗线段树维护即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6+5;int last = 1, tot = 1, ch[N][26], fa[N], len[N], pos[N], size[N];int n, tax[N], p[N];char s[N];void insert(int c)&#123; int cur = ++tot, pre = last; last = tot; len[cur] = len[pre]+1; pos[len[cur]] = cur; size[cur] = 1; while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[pre]+1 == len[x]) return void(fa[cur] = x); int y = ++tot; len[y] = len[pre]+1; fa[y] = fa[x]; fa[x] = fa[cur] = y; memcpy(ch[y], ch[x], sizeof(ch[x])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];&#125;struct Segment&#123; int val[N&lt;&lt;1]; Segment() &#123; memset(val, 0x3f, sizeof(val)); &#125; void update(int x, int l, int r, int ql, int qr, int d) &#123; if(ql &gt; qr) return; if(ql &lt;= l&amp;&amp;r &lt;= qr) return void(val[x] = min(val[x], d)); int mid = (l+r)&gt;&gt;1; if(ql &lt;= mid) update(x&lt;&lt;1, l, mid, ql, qr, d); if(qr &gt; mid) update(x&lt;&lt;1|1, mid+1, r, ql, qr, d); &#125; int query(int x, int l, int r, int pos) &#123; if(l == r) return val[x]; int mid = (l+r)&gt;&gt;1; if(pos &lt;= mid) return min(val[x], query(x&lt;&lt;1, l, mid, pos)); else return min(val[x], query(x&lt;&lt;1|1, mid+1, r, pos)); &#125;&#125;a, b;int main()&#123; scanf("%s", s+1); n = strlen(s+1); for(int i = 1; i &lt;= n; ++i) insert(s[i]-'a'); for(int i = 1; i &lt;= tot; ++i) ++tax[len[i]]; for(int i = 1; i &lt;= tot; ++i) tax[i] += tax[i-1]; for(int i = 1; i &lt;= tot; ++i) p[tax[len[i]]--] = i; for(int i = tot; i; --i) size[fa[p[i]]] += size[p[i]]; for(int i = 1; i &lt;= n; ++i) &#123; int x = pos[i]; if(size[x] &gt; 1) continue; a.update(1, 1, n, i-len[fa[x]], i, len[fa[x]]+1); b.update(1, 1, n, 1, i-len[fa[x]]-1, i+1); &#125; for(int i = 1; i &lt;= n; ++i) printf("%d\n", min(a.query(1, 1, n, i), b.query(1, 1, n, i)-i)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SP8093 JZPGYZ - Sevenk Love Oimaster]]></title>
    <url>%2F2019%2F07%2F05%2FSP8093-JZPGYZ-Sevenk-Love-Oimaster%2F</url>
    <content type="text"><![CDATA[题面描述给定n个模板串，以及m个查询串，查询每一个查询串是多少个模板串的子串 题解广义后缀自动机匹配和子树数颜色，后者用启发式合并即可 广义后缀自动机的拓扑序又双叒叕挂掉了，上次口胡的解决方法错了，我不想建树啊，谁来救救蒟蒻啊啊啊啊123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;const int N = 2e5+5;int n, q;char s[N];int ch[N][26], tot = 1, last = 1, fa[N], len[N], size[N];int tax[N], p[N];set&lt;int&gt; f[N];vector&lt;int&gt; son[N];inline void insert(int c)&#123; int cur = ++tot, pre = last; last = cur; len[cur] = len[pre]+1; while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[pre]+1 == len[x]) return void(fa[cur] = x); int y = ++tot; fa[y] = fa[x]; fa[x] = fa[cur] = y; len[y] = len[pre]+1; memcpy(ch[y], ch[x], sizeof(ch[x])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];&#125;void dfs(int x)&#123; for(int i = 0; i &lt; son[x].size(); ++i) &#123; int y = son[x][i]; dfs(y); if(f[x].size() &lt; f[y].size()) swap(f[x], f[y]); f[x].insert(f[y].begin(), f[y].end()); f[y].clear(); &#125; size[x] = f[x].size();&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;q); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s); last = 1; for(int k = 0; s[k]; ++k) insert(s[k]-'a'), f[last].insert(i); &#125; for(int i = 2; i &lt;= tot; ++i) son[fa[i]].push_back(i); dfs(1); while(q--) &#123; scanf("%s", s); int x = 1, lcs = 0, strl = 0; for(int i = 0; s[i]; ++i) &#123; while(x&amp;&amp;!ch[x][s[i]-'a']) x = fa[x], lcs = len[x]; if(!x) x = 1, lcs = 0; else x = ch[x][s[i]-'a'], ++lcs; ++strl; &#125; printf("%d\n", size[x]*(lcs == strl)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HEOI2015]最短不公共子串]]></title>
    <url>%2F2019%2F07%2F05%2FHEOI2015-%E6%9C%80%E7%9F%AD%E4%B8%8D%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题面描述求两个字符串最短不公共子序列和子串 题解我们需要两个自动机，一个可以接受所有子串，另一个可以接受所有子序列，前者我们可以使用 $SAM$，后者我们要构造一个叫做序列自动机的东西 序列自动机的构造不难理解，记录每个字符上一个出现位置，连转移边即可，构造复杂度为 $O(n|S|)$，感性理解下就是每一次加入的复杂度等价为从这一次加入到上一加入之间有多少字符，单看每个字符这个整体求和后是 $O(n)$，字符集大小为 $|S|$，所以复杂度为 $O(n|S|)$12345678910111213struct Sqam&#123; int root, tot, last[26], pre[N], ch[N][26]; Sqam() &#123; root = tot = 1; for(int i = 0; i &lt; 26; ++i) last[i] = 1; &#125; void insert(int c) &#123; int cur = ++tot; pre[cur] = last[c]; for(int i = 0; i &lt; 26; ++i) for(int k = last[i]; k&amp;&amp;!ch[k][c]; k = pre[k]) ch[k][c] = cur; last[c] = cur; &#125;&#125; 那么这题就用 $BFS$ 暴力匹配即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;tuple&gt;#include &lt;queue&gt;using namespace std;const int N = 4e3+5;struct Sam&#123; int tot = 1, last = 1, ch[N][26], len[N], fa[N]; void insert(int c) &#123; int cur = ++tot, pre = last; last = tot; len[cur] = len[pre]+1; while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[x] == len[pre]+1) return void(fa[cur] = x); int y = ++tot; fa[y] = fa[x]; fa[cur] = fa[x] = y; len[y] = len[pre]+1; memcpy(ch[y], ch[x], sizeof(ch[x])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre]; &#125;&#125;sama, samb;struct Sqam&#123; int root, tot, last[26], pre[N], ch[N][26]; Sqam() &#123; root = tot = 1; for(int i = 0; i &lt; 26; ++i) last[i] = 1; &#125; void insert(int c) &#123; int cur = ++tot; pre[cur] = last[c]; for(int i = 0; i &lt; 26; ++i) for(int k = last[i]; k&amp;&amp;!ch[k][c]; k = pre[k]) ch[k][c] = cur; last[c] = cur; &#125;&#125;sqama, sqamb;char s[N];int d[N][N];int bfs1()&#123; queue&lt;pair&lt;int, int&gt; &gt; q; memset(d, 0, sizeof(d)); d[1][1] = 1; q.push(make_pair(1, 1)); while(q.size()) &#123; int xa = q.front().first, xb = q.front().second; q.pop(); for(int i = 0; i &lt; 26; ++i) &#123; int ya = sama.ch[xa][i], yb = samb.ch[xb][i]; if(ya&amp;&amp;yb&amp;&amp;!d[ya][yb]) d[ya][yb] = d[xa][xb]+1, q.push(make_pair(ya, yb)); if(ya&amp;&amp;!yb) return d[xa][xb]; &#125; &#125; return -1;&#125;int bfs2()&#123; queue&lt;pair&lt;int, int&gt; &gt; q; memset(d, 0, sizeof(d)); d[1][1] = 1; q.push(make_pair(1, 1)); while(q.size()) &#123; int xa = q.front().first, xb = q.front().second; q.pop(); for(int i = 0; i &lt; 26; ++i) &#123; int ya = sama.ch[xa][i], yb = sqamb.ch[xb][i]; if(ya&amp;&amp;yb&amp;&amp;!d[ya][yb]) d[ya][yb] = d[xa][xb]+1, q.push(make_pair(ya, yb)); if(ya&amp;&amp;!yb) return d[xa][xb]; &#125; &#125; return -1;&#125;int bfs3()&#123; queue&lt;pair&lt;int, int&gt; &gt; q; memset(d, 0, sizeof(d)); d[1][1] = 1; q.push(make_pair(1, 1)); while(q.size()) &#123; int xa = q.front().first, xb = q.front().second; q.pop(); for(int i = 0; i &lt; 26; ++i) &#123; int ya = sqama.ch[xa][i], yb = samb.ch[xb][i]; if(ya&amp;&amp;yb&amp;&amp;!d[ya][yb]) d[ya][yb] = d[xa][xb]+1, q.push(make_pair(ya, yb)); if(ya&amp;&amp;!yb) return d[xa][xb]; &#125; &#125; return -1;&#125;int bfs4()&#123; queue&lt;pair&lt;int, int&gt; &gt; q; memset(d, 0, sizeof(d)); d[1][1] = 1; q.push(make_pair(1, 1)); while(q.size()) &#123; int xa = q.front().first, xb = q.front().second; q.pop(); for(int i = 0; i &lt; 26; ++i) &#123; int ya = sqama.ch[xa][i], yb = sqamb.ch[xb][i]; if(ya&amp;&amp;yb&amp;&amp;!d[ya][yb]) d[ya][yb] = d[xa][xb]+1, q.push(make_pair(ya, yb)); if(ya&amp;&amp;!yb) return d[xa][xb]; &#125; &#125; return -1;&#125;int main()&#123; scanf("%s", s); for(int i = 0; s[i]; ++i) sama.insert(s[i]-'a'), sqama.insert(s[i]-'a'); scanf("%s", s); for(int i = 0; s[i]; ++i) samb.insert(s[i]-'a'), sqamb.insert(s[i]-'a'); printf("%d\n%d\n%d\n%d\n", bfs1(), bfs2(), bfs3(), bfs4()); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[十二省联考2019]字符串问题]]></title>
    <url>%2F2019%2F07%2F04%2F%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述给定子串集合 $A$ 和 $B$，和支配关系，构造最长目标串满足由 $A$ 构成，对于相邻 $A$，后一个存在前缀为 $B$，且被 $A$ 支配 题解很明显，这道题的目的是优化建图，由于在练习 $SAM$，所以就不考虑 $SA$ 了 对于原串建一颗后缀树，发现题目中的建边正好是对于后缀树子树的连边，直接 $DFS$ 序搞一下线段树优化建图跑个拓扑就行了 但注意，对于倍增向上跳的节点对于后 $20$ 分不完全合法，只向部分连边，所以当时口胡的做法是每个节点按长度在排个序，再搞一次线段树优化建图就行了但嫌麻烦直接打了个暴力交了，居然水过去了 一定要算好空间，两次死在空间上 最后注意 $long\ long$ 神仙数据构造 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 4e6+5;int T;int ns, na, nb, n, m;int last = 1, tot = 1, ch[N][26], fa[N], len[N], pos[N];char s[N];int p[N], tax[N];void insert(int c)&#123; int cur = ++tot, pre = last; last = cur; len[cur] = len[pre]+1; pos[ns-len[cur]+1] = cur; while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[pre]+1 == len[x]) return void(fa[cur] = x); int y = ++tot; fa[y] = fa[x]; fa[x] = fa[cur] = y; len[y] = len[pre]+1; memcpy(ch[y], ch[x], sizeof(ch[y])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];&#125;vector&lt;pair&lt;int, int&gt; &gt; sub[N];vector&lt;int&gt; edge[N];pair&lt;int, int&gt; b[N];int seg[N], in[N], out[N], ac[20][N], w[N], deg[N], dfn[N], t;void add(int x, int y) &#123; edge[x].push_back(y); ++deg[y]; &#125;int find(int x, int d)&#123; for(int i = 19; ~i; --i) if(len[ac[i][x]] &gt;= d) x = ac[i][x]; return x;&#125;void dfs(int x)&#123; in[x] = ++t; dfn[t] = x; for(int i = 0; i &lt; edge[x].size(); ++i) dfs(edge[x][i]); out[x] = t;&#125;void build(int x, int l, int r)&#123; seg[x] = ++n; if(l == r) &#123; for(int i = 0; i &lt; sub[dfn[l]].size(); ++i) add(seg[x], sub[dfn[l]][i].second); &#125; else &#123; int mid = (l+r)&gt;&gt;1; build(x&lt;&lt;1, l, mid); build(x&lt;&lt;1|1, mid+1, r); add(seg[x], seg[x&lt;&lt;1]); add(seg[x], seg[x&lt;&lt;1|1]); &#125;&#125;void update(int x, int l, int r, int ql, int qr, int d)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return add(d, seg[x]); int mid = (l+r)&gt;&gt;1; if(ql &lt;= mid) update(x&lt;&lt;1, l, mid, ql, qr, d); if(qr &gt; mid) update(x&lt;&lt;1|1, mid+1, r, ql, qr, d);&#125;queue&lt;int&gt; q;int64 f[N];int64 topo()&#123; int64 ret = 0; int cnt = 0; memset(f, 0, sizeof(f)); for(int x = 1; x &lt;= n; ++x) if(!deg[x]) q.push(x); while(q.size()) &#123; int x = q.front(); q.pop(); f[x] += w[x]; ++cnt; for(int i = 0; i &lt; edge[x].size(); ++i) &#123; int y = edge[x][i]; f[y] = max(f[x], f[y]); if(--deg[y] == 0) q.push(y); &#125; ret = max(f[x], ret); &#125; return cnt == n?ret:-1;&#125;int main()&#123; T = read(); while(T--) &#123; scanf("%s", s+1); ns = strlen(s+1); for(int i = ns; i; --i) insert(s[i]-'a'); for(int i = 1; i &lt;= tot; ++i) ++tax[len[i]]; for(int i = 1; i &lt;= tot; ++i) tax[i] += tax[i-1]; for(int i = tot; i; --i) p[tax[len[i]]--] = i; for(int i = 2; i &lt;= tot; ++i) &#123; int x = p[i]; ac[0][x] = fa[x]; edge[fa[x]].push_back(x); for(int k = 1; k &lt; 20; ++k) ac[k][x] = ac[k-1][ac[k-1][x]]; &#125; dfs(1); for(int i = 1; i &lt;= tot; ++i) edge[i].clear(); na = read(); n = na; for(int i = 1; i &lt;= n; ++i) &#123; int l = read(), r = read(); w[i] = r-l+1; sub[find(pos[l], r-l+1)].push_back(make_pair(r-l+1, i)); &#125; build(1, 1, tot); nb = read(); for(int i = 1; i &lt;= nb; ++i) &#123; int l = read(), r = read(); b[i] = make_pair(find(pos[l], r-l+1), r-l+1); &#125; m = read(); for(int i = 1; i &lt;= m; ++i) &#123; int u = read(), v = read(), x = b[v].first; if(in[x] &lt; out[x]) update(1, 1, tot, in[x]+1, out[x], u); for(int k = 0; k &lt; sub[x].size(); ++k) if(b[v].second &lt;= sub[x][k].first) add(u, sub[x][k].second); &#125; printf("%lld\n", topo()); for(int i = 1; i &lt;= tot; ++i) memset(ch[i], 0, sizeof(ch[i])), sub[i].clear(), fa[i] = len[i] = pos[i] = p[i] = tax[i] = 0; tot = last = 1; t = 0; for(int i = 1; i &lt;= n; ++i) edge[i].clear(), w[i] = 0, deg[i] = 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF786B Legacy]]></title>
    <url>%2F2019%2F07%2F04%2FCF786B-Legacy%2F</url>
    <content type="text"><![CDATA[题面描述支持区间向单点连边的单源最短路问题。 题解线段树优化建图模板题，建立两个线段树，一个由内向外连，一个由外向内连即可，具体细节就按照线段树区间操作口胡一下就好了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 3e6+5;struct Edge&#123; int next, to, w; Edge(int next = 0, int to = 0, int w = 0):next(next), to(to), w(w) &#123;&#125;;&#125;edge[N];int tot, head[N];void add(int x, int y, int z) &#123; edge[++tot] = Edge(head[x], y, z); head[x] = tot; &#125;int n, m, q, s;int64 d[N];int in[N], out[N];void build(int x, int l, int r)&#123; if(l == r) return void(in[x] = out[x] = l); int mid = (l+r)&gt;&gt;1; in[x] = ++m; out[x] = ++m; build(x&lt;&lt;1, l, mid); build(x&lt;&lt;1|1, mid+1, r); add(in[x], in[x&lt;&lt;1], 0); add(in[x], in[x&lt;&lt;1|1], 0); add(out[x&lt;&lt;1], out[x], 0); add(out[x&lt;&lt;1|1], out[x], 0);&#125;void outUpdate(int x, int l, int r, int ql, int qr, int d, int w)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return add(out[x], d, w); int mid = (l+r)&gt;&gt;1; if(ql &lt;= mid) outUpdate(x&lt;&lt;1, l, mid, ql, qr, d, w); if(qr &gt; mid) outUpdate(x&lt;&lt;1|1, mid+1, r, ql, qr, d, w);&#125;void inUpdate(int x, int l, int r, int ql, int qr, int d, int w)&#123; if(ql &lt;= l&amp;&amp;r &lt;= qr) return add(d, in[x], w); int mid = (l+r)&gt;&gt;1; if(ql &lt;= mid) inUpdate(x&lt;&lt;1, l, mid, ql, qr, d, w); if(qr &gt; mid) inUpdate(x&lt;&lt;1|1, mid+1, r, ql, qr, d, w);&#125;int main()&#123; n = read(), q = read(), s = read(); m = n; build(1, 1, n); for(int i = 1; i &lt;= q; ++i) &#123; int op = read(), v = read(), u, l, r, w; if(op == 1) u = read(), w = read(), add(v, u, w); else if(op == 2) l = read(), r = read(), w = read(), inUpdate(1, 1, n, l, r, v, w); else l = read(), r = read(), w = read(), outUpdate(1, 1, n, l, r, v, w); &#125; memset(d, 0x3f, sizeof(d)); d[s] = 0; priority_queue&lt;pair&lt;int64, int&gt; &gt; q; q.push(make_pair(0, s)); while(q.size()) &#123; int x = q.top().second; int64 dx = -q.top().first; q.pop(); if(dx != d[x]) continue; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to, z = edge[i].w; if(d[y] &gt; d[x]+z) d[y] = d[x]+z, q.push(make_pair(-d[y], y)); &#125; &#125; for(int x = 1; x &lt;= n; ++x) printf("%lld ", d[x]^d[0]?d[x]:-1); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2018]你的名字]]></title>
    <url>%2F2019%2F07%2F02%2FNOI2018-%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题面描述求一个字符串的连续非空子串与询问串本质不同的非公共子串个数 题解一开始没看到本质不同，第二个下发数据完全不一致才发现 如果我们要求一个字符串的本质不同子串个数，那么我们只需要对于 $Parent$ 树上的每一个节点 $x$ 累计求和 $maxlen(x)-maxlen(parent(x))$ 现在，又多了一个字符串，导致每个节点产生和原来不一致的贡献，考虑每个节点表示的子串是相应 $endpos$ 前缀的后缀，也就是说对于每个位置，我们处理下以该位置结尾的前缀与另一个字符串某一子串 $LCS$ 的最大值 $L$，处理一下 $(0,\ L]$ 和 $(maxlen(parent(x)), maxlen(x)]$ 的区间交算下贡献即可，$L$ 可以通过后缀自动机上的匹配解决之后题目又加上区间的限制，那么我们匹配到一个节点 $x$ 后需要不停判断该节点是否符合条件，二分 $L$，找到 $L$ 对应的 $x$ 的祖先，判断在 $[l+L-1,\ r]$ 有没有 $endpos$ 即可 因为倍增顺序写反调了一下午的蒟蒻的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e6+5;int n, q;int root[N], val[N&lt;&lt;6], tot, ls[N&lt;&lt;6], rs[N&lt;&lt;6];void add(int &amp;x, int l, int r, int pos)&#123; if(!x) x = ++tot; val[x] |= 1; if(l == r) return; int mid = (l+r)&gt;&gt;1; if(pos &lt;= mid) return add(ls[x], l, mid, pos); else return add(rs[x], mid+1, r, pos);&#125;bool query(int x, int l, int r, int ql, int qr)&#123; if(ql &gt; qr) return false; if(!x||(ql &lt;= l&amp;&amp;r &lt;= qr)) return val[x]; int mid = (l+r)&gt;&gt;1; if(ql &lt;= mid&amp;&amp;query(ls[x], l, mid, ql, qr)) return true; if(qr &gt; mid&amp;&amp;query(rs[x], mid+1, r, ql, qr)) return true; return false;&#125;int merge(int x, int y)&#123; if(!x||!y) return x|y; int z = ++tot; val[z] = val[x]|val[y]; ls[z] = merge(ls[x], ls[y]); rs[z] = merge(rs[x], rs[y]); return z;&#125;char s[N];struct Sam&#123; int tot = 1, last = 1, ch[N][26], fa[N], len[N], ac[20][N], w[N]; int64 ans; int tax[N], p[N]; void clear() &#123; for(int i = 1; i &lt;= tot; ++i) memset(ch[i], 0, sizeof(ch[i])), fa[i] = w[i] = tax[i] = 0; tot = 1, last = 1, ans = 0; &#125; void insert(int c, int val = -1) &#123; int cur = ++tot, pre = last; last = cur; len[cur] = len[pre]+1; if(val == -1) add(root[cur], 1, n, len[cur]); else w[cur] = val; while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[pre]+1 == len[x]) return void(fa[cur] = x); int y = ++tot; len[y] = len[pre]+1; fa[y] = fa[x]; fa[x] = fa[cur] = y; memcpy(ch[y], ch[x], sizeof(ch[x])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre]; &#125; void build(int type = 1) &#123; for(int i = 1; i &lt;= tot; ++i) ++tax[len[i]]; for(int i = 1; i &lt;= tot; ++i) tax[i] += tax[i-1]; for(int i = 1; i &lt;= tot; ++i) p[tax[len[i]]--] = i; for(int i = tot; i &gt; 1; --i) &#123; int x = p[i]; if(type) root[fa[x]] = merge(root[fa[x]], root[x]); else &#123; w[fa[x]] = max(w[x], w[fa[x]]); ans += max(0, len[x]-max(w[x], len[fa[x]])); &#125; &#125; if(type) &#123; for(int i = 1; i &lt;= tot; ++i) &#123; int x = p[i]; ac[0][x] = fa[x]; for(int k = 1; k &lt; 20; ++k) ac[k][x] = ac[k-1][ac[k-1][x]]; &#125; &#125; &#125; int find(int x, int d) &#123; for(int i = 19; ~i; --i) if(len[ac[i][x]] &gt;= d) x = ac[i][x]; return x; &#125; int get(int x, int ql, int qr, int lcs) &#123; if(query(root[x], 1, n, ql+lcs-1, qr)) return lcs; int ret = 0, l = 1, r = lcs-1; while(l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if(query(root[find(x, mid)], 1, n, ql+mid-1, qr)) ret = mid, l = mid+1; else r = mid-1; &#125; return ret; &#125;&#125;sam, buf;int main()&#123; scanf("%s", s); q = read(); n = strlen(s); for(int i = 0; s[i]; ++i) sam.insert(s[i]-'a'); sam.build(); while(q--) &#123; scanf("%s", s); int l = read(), r = read(); int x = 1, lcs = 0; buf.clear(); for(int i = 0; s[i]; ++i) &#123; while(x&amp;&amp;!sam.ch[x][s[i]-'a']) x = sam.fa[x], lcs = sam.len[x]; if(!x) x = 1, lcs = 0; else x = sam.ch[x][s[i]-'a'], ++lcs; buf.insert(s[i]-'a', sam.get(x, l, r, lcs)); &#125; buf.build(0); printf("%lld\n", buf.ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[雅礼集训2017Day7]事情的相似度]]></title>
    <url>%2F2019%2F07%2F02%2F%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD2017Day7-%E4%BA%8B%E6%83%85%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述给定前缀结束位置区间，求其两两间 $LCS$ 的最大值 题解一个人学 $SAM$，也需要考虑历史的进程 这道题在一开始有一个口胡的后缀数组和莫队的 $O(n\sqrt{nlogn})$ 做法，但觉得常数有点大，就放弃了 之后又错误估计了预处理的点对数量，以为是 $O(n^2)$，然后就看了题解，发现是 $O(nlogn)$ 任意两前缀的 $LCS$ 一定是相应 $np$ 节点在 $Parent$ 树上的 $LCA$ 的 $maxlen$，我们预处理一些点对即可，具体来说，两个子节点合并到父节点时，我们找最接近的合并一定不会差，这样和启发式合并复杂度一致之后把操作离线，用后缀树状数组搞一下扫描线即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;set&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e5+5;int last = 1, tot = 1, ch[N][2], fa[N], len[N];int m, p[N], tax[N];set&lt;int&gt; t[N];char s[N];void insert(int c)&#123; int cur = ++tot, pre = last; last = cur; len[cur] = len[pre]+1; t[cur].insert(len[cur]); while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[pre]+1 == len[x]) return void(fa[cur] = x); int y = ++tot; fa[y] = fa[x]; fa[x] = fa[cur] = y; len[y] = len[pre]+1; memcpy(ch[y], ch[x], sizeof(ch[x])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];&#125;int n, q;int ans[N];struct Tup&#123; int w[3]; Tup(int x = 0, int y = 0, int z = 0)&#123; w[0] = x; w[1] = y; w[2] = z; &#125; int operator [] (const int x) &#123; return w[x]; &#125; bool operator &lt; (const Tup &amp;_) const &#123; for(int i = 0; i &lt; 3; ++i) if(w[i] != _.w[i]) return w[i] &lt; _.w[i]; return true; &#125;&#125;tup[N&lt;&lt;6], par[N]; int val[N];void change(int x, int d) &#123; for( ; x; x -= x&amp;-x) val[x] = max(val[x], d); &#125;int query(int x) &#123; int ret = 0; for( ; x &lt;= n; x += x&amp;-x) ret = max(ret, val[x]); return ret; &#125;int main()&#123; scanf("%d%d", &amp;n, &amp;q); scanf("%s", s+1); for(int i = 1; i &lt;= n; ++i) insert(s[i]-'0'); for(int i = 1; i &lt;= tot; ++i) ++tax[len[i]]; for(int i = 1; i &lt;= tot; ++i) tax[i] += tax[i-1]; for(int i = 1; i &lt;= tot; ++i) p[tax[len[i]]--] = i; for(int i = tot; i &gt; 1; --i) &#123; int x = p[i]; if(t[x].size() &gt; t[fa[x]].size()) swap(t[x], t[fa[x]]); set&lt;int&gt;::iterator it, a, b, c; for(it = t[x].begin(); it != t[x].end(); ++it) &#123; t[fa[x]].insert(*it); a = b = c = t[fa[x]].find(*it); ++c; if(a != t[fa[x]].begin()) --a, tup[++m] = Tup(*b, *a, len[fa[x]]); if(c != t[fa[x]].end()) tup[++m] = Tup(*c, *b, len[fa[x]]); t[fa[x]].erase(*it); &#125; for(it = t[x].begin(); it != t[x].end(); ++it) t[fa[x]].insert(*it); &#125; sort(tup+1, tup+1+m); for(int i = 1; i &lt;= q; ++i) &#123; int l = read(), r = read(); par[i] = Tup(r, l, i); &#125; sort(par+1, par+1+q); for(int i = 1, ptr = 1; i &lt;= q; ++i) &#123; while(ptr &lt;= m&amp;&amp;tup[ptr][0] &lt;= par[i][0]) change(tup[ptr][1], tup[ptr][2]), ++ptr; ans[par[i][2]] = query(par[i][1]); &#125; for(int i = 1; i &lt;= q; ++i) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3413]匹配]]></title>
    <url>%2F2019%2F07%2F01%2FBZOJ3413-%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题面描述求 $A$ 串对 $B$ 串朴素匹配的比较次数 题解一道综合性和思维性很好的题 解决的关键在于把匹配的复杂度转移到 $A$ 上 起初没什么思路，只知道这道题一定是在 $B$ 的 $Parent$ 树上乱搞 对着样例和 $Parent$ 树找了快半个小时的规律才知道怎么做 首先分两种情况讨论第一种，$A$ 可以匹配上 $B$，记匹配位置为 $pos$ 那么答案即为 $$\sum_{i=1}^{pos-1}[LCP(A,\ B[1,i])+1]+len(B)$$ 我们在 $B$ 的 $SAM$ 上匹配 $A$，匹配上时的节点为 $x$，不难发现，$pos\ =\ min\lbrace k\rbrace,k\in endpos(x)$ 考虑前面的式子如何求出，我们会发现正串的 $Parent$ 树向上跳时方便求出的是 $LCS$ 与该题结合十分不自然，所以不妨在反串上建 $SAM$，得出后缀树 在后缀树上向上跳，$A$和$B$前缀不断缩小，具有相同前缀的位置越来越多，正好与匹配过程相一致，具体来说，$LCP$即为相应位置第一次在向上跳相遇时 $endpos$ 集合的最长长度，前面的式子用后缀树改写即为 $$\sum_{i=1}^{pos-1}[maxlen(p_i)+1],\ \forall i\in p_k\ maxlen(p_i) \ge maxlen(p_k),\ p_i\in path(x,S)$$ 所以我们只需要向上跳后缀树，每次加上该节点小于 $pos$ 的 $endpos$ 个数乘上该节点所表示字符串的长度区间长度即可，每个位置的贡献恰好按照上式不重不漏统计了一次，最后再加上 $pos-1$ 即可，用线段树合并即可 第二种，$A$ 匹配不上 $B$那么答案即为 $$\sum_{i=1}^{len(B)}[LCP(A,\ B[1,i])+1]$$ 记匹配最后节点为 $x$，按照上述讨论，答案变为 $$\sum_{i=1}^{len(B)}[maxlen(p_i)+1],\ \forall i\in p_k\ maxlen(p_i) \ge maxlen(p_k),\ p_i\in path(x,S)$$ 然而答案错误，是由于 $x$ 的贡献不一定是 $maxlen(x)$，有可能只是一部分，所以特殊统计一下就好了，与 [HAOI2016]找相同字符 类似 此题空间严格，需要仔细计算空间大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 2e5+5;typedef long long int64;int n, m, q;char s[N];namespace sam&#123;int tot = 1, last = 1, ch[N][10], fa[N], len[N], pos[N];void insert(int c)&#123; int cur = ++tot, pre = last; last = cur; len[cur] = len[pre]+1; pos[cur] = len[cur]; while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[pre]+1 == len[x]) return (void)(fa[cur] = x); int y = ++tot; fa[y] = fa[x]; fa[x] = fa[cur] = y; pos[y] = pos[cur]; len[y] = len[pre]+1; memcpy(ch[y], ch[x], sizeof(ch[y])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];&#125;&#125;int tot, root[N], val[N&lt;&lt;5], ls[N&lt;&lt;5], rs[N&lt;&lt;5];void add(int &amp;x, int l, int r, int pos)&#123; if(!x) x = ++tot; ++val[x]; if(l == r) return; int mid = (l+r)&gt;&gt;1; if(pos &lt;= mid) add(ls[x], l, mid, pos); else add(rs[x], mid+1, r, pos);&#125;int merge(int x, int y)&#123; if(!x||!y) return x|y; int z = ++tot; val[z] = val[x]+val[y]; ls[z] = merge(ls[x], ls[y]); rs[z] = merge(rs[x], rs[y]); return z;&#125;int query(int x, int l, int r, int ql, int qr)&#123; if(!x||(ql &lt;= l&amp;&amp;r &lt;= qr)) return val[x]; int mid = (l+r)&gt;&gt;1, ret = 0; if(ql &lt;= mid) ret += query(ls[x], l, mid, ql, qr); if(qr &gt; mid) ret += query(rs[x], mid+1, r, ql, qr); return ret;&#125;int tax[N], p[N];int main()&#123; scanf("%d%s%d", &amp;n, s+1, &amp;q); reverse(s+1, s+1+n); for(int i = 1; i &lt;= n; ++i) sam::insert(s[i]-'0'), add(root[sam::last], 1, n, i); for(int i = 1; i &lt;= sam::tot; ++i) ++tax[sam::len[i]]; for(int i = 1; i &lt;= sam::tot; ++i) tax[i] += tax[i-1]; for(int i = 1; i &lt;= sam::tot; ++i) p[tax[sam::len[i]]--] = i; for(int i = sam::tot; i &gt; 1; --i) sam::pos[sam::fa[p[i]]] = max(sam::pos[sam::fa[p[i]]], sam::pos[p[i]]), root[sam::fa[p[i]]] = merge(root[sam::fa[p[i]]], root[p[i]]); while(q--) &#123; scanf("%s", s+1); m = strlen(s+1); reverse(s+1, s+1+m); int x = 1, lcs = 0, p = 1; int64 ans = 0; for(int i = 1; i &lt;= m; ++i) &#123; while(x&amp;&amp;!sam::ch[x][s[i]-'0']) x = sam::fa[x], lcs = sam::len[x]; if(!x) x = 1, lcs = 0; else x = sam::ch[x][s[i]-'0'], ++lcs; if(lcs == m) break; &#125; if(lcs == m) p = sam::pos[x]+1, ans += m, x = sam::fa[x]; else if(x != 1) ans += 1ll*(lcs-sam::len[sam::fa[x]])*query(root[x], 1, n, p, n), x = sam::fa[x]; while(x != 1) ans += 1ll*(sam::len[x]-sam::len[sam::fa[x]])*query(root[x], 1, n, p, n), x = sam::fa[x]; ans += query(root[x], 1, n, p, n); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3879]Svt]]></title>
    <url>%2F2019%2F07%2F01%2FBZOJ3879-Svt%2F</url>
    <content type="text"><![CDATA[题面描述给定后缀集合 $S$ , 求 $\sum_{s_i,s_j\in S}LCP(s_i,\ s_j)$ 题解很套路的一道题，在反串构造后缀自动机建后缀树 在后缀树上 $DP$ 统计以当前节点为 $LCA$ 的路径数即可 多组询问就用虚树搞一下就好了此题轻微卡常，最好用树剖 $LCA$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = 0)&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e6+5;struct Edge&#123; int next, to; Edge(int next = 0, int to = 0):next(next), to(to) &#123;&#125;;&#125;edge[N];int tot, head[N];void add(int x, int y) &#123; edge[++tot] = Edge(head[x], y); head[x] = tot; &#125;namespace sam&#123;int last = 1, tot = 1, ch[N][26], fa[N], len[N], pos[N];void insert(int c)&#123; int cur = ++tot, pre = last; last = cur; len[cur] = len[pre]+1; pos[len[cur]] = cur; while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[pre]+1 == len[x]) return void(fa[cur] = x); int y = ++tot; fa[y] = fa[x]; len[y] = len[pre]+1; fa[x] = fa[cur] = y; memcpy(ch[y], ch[x], sizeof(ch[x])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre]; &#125;&#125;int n, m, q;char s[N];int d[N], dfn[N], t, son[N], top[N], size[N], pos[N];void dfs(int x)&#123; dfn[x] = ++t; d[x] = d[sam::fa[x]]+1; size[x] = 1; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; dfs(y); size[x] += size[y]; son[x] = size[son[x]]&gt;size[y]?son[x]:y; &#125;&#125;void dfs(int x, int topf)&#123; top[x] = topf; if(son[x]) dfs(son[x], topf); for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to; if(y^son[x]) dfs(y, y); &#125;&#125;int LCA(int x, int y)&#123; while(top[x] != top[y]) &#123; if(d[top[x]] &lt; d[top[y]]) swap(x, y); x = sam::fa[top[x]]; &#125; return d[x]&lt;d[y]?x:y;&#125;int p[N];bool cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;namespace vtree&#123;int top, s[N], col[N], f[N];vector&lt;int&gt; edge[N];void add(int x, int y) &#123; edge[x].push_back(y); &#125;void insert(int x)&#123; int lca = LCA(x, s[top]); if(s[top] == lca) return void(s[++top] = x); while(top &gt; 1&amp;&amp;dfn[s[top-1]] &gt;= dfn[lca]) add(s[top-1], s[top]), --top; if(s[top] != lca) add(lca, s[top]), s[top] = lca; s[++top] = x;&#125; void build()&#123; s[top = 1] = 1; for(int i = 1; i &lt;= m; ++i) insert(p[i]), col[p[i]] = 1; while(top &gt; 1) add(s[top-1], s[top]), --top;&#125;int64 dp(int x)&#123; int64 ret = 0; f[x] = col[x]; col[x] = 0; for(int i = 0; i &lt; edge[x].size(); ++i) &#123; int y = edge[x][i]; ret += dp(y); ret += 1ll*f[x]*f[y]*sam::len[x]; f[x] += f[y]; &#125; edge[x].clear(); return ret;&#125;&#125;int main()&#123; n = read(), q = read(); scanf("%s", s+1); reverse(s+1, s+1+n); for(int i = 1; i &lt;= n; ++i) sam::insert(s[i]-'a'); for(int x = 2; x &lt;= sam::tot; ++x) add(sam::fa[x], x); dfs(1); dfs(1, 1); while(q--) &#123; m = read(); for(int i = 1; i &lt;= m; ++i) p[i] = sam::pos[n-read()+1]; sort(p+1, p+1+m); m = unique(p+1, p+1+m)-p-1; sort(p+1, p+1+m, cmp); vtree::build(); printf("%lld\n", vtree::dp(1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2011]消耗战]]></title>
    <url>%2F2019%2F07%2F01%2FSDOI2011-%E6%B6%88%E8%80%97%E6%88%98%2F</url>
    <content type="text"><![CDATA[题面描述给定关键点，求树的最小割 题解虚树模板题，虚树是用来解决多次询问，但关键点总数有限的优化方法，就是将关键点及其 $LCA$ 提取出来在进行 $DP$ 具体来说，我们先将关键点按 $dfn$ 排序，依次加入一个栈中，这个栈维护了从根到栈顶的一条链 设加入节点为 $p$ 则分如下情况讨论 若 $LCA(p,\ S_{top})\ =\ S_{top}$ 说明 $p$ 仍在链上，直接入栈 反之，则说明已经到另外一颗子树上了不断弹出栈顶直到 $dfn_{S_{top-1}}&lt;dfn_{lca}$ 并且 连边 $(S_{top-1},\ S_{top})$ 把 $S_{top}$ 到 $lca$ 的点提取出来 如果 $S_{top}\ne lca$ 则连边 $(lca,\ S_{top})$ 将栈顶变为 $lca$ 然后，$p$ 再入栈 最后在处理下栈中剩下的链即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 5e5+5;struct Edge&#123; int next, to, w; Edge(int next = 0, int to = 0, int w = 0):next(next), to(to), w(w) &#123;&#125;;&#125;edge[N&lt;&lt;1];int head[N], tot;void _add(int x, int y, int z) &#123; edge[++tot] = Edge(head[x], y, z); head[x] = tot; &#125;void add(int x, int y, int z) &#123; _add(x, y, z); _add(y, x, z); &#125;int n, m, q, ac[20][N], d[N], nfd[N], dfn[N], t, p[N];int64 f[N];void dfs(int x, int fa)&#123; ac[0][x] = fa; dfn[++t] = x; nfd[x] = t; d[x] = d[fa]+1; for(int i = 1; i &lt; 20; ++i) ac[i][x] = ac[i-1][ac[i-1][x]]; for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to, z = edge[i].w; if(y == fa) continue; f[y] = min(f[x], 1ll*z); dfs(y, x); &#125;&#125;int LCA(int x, int y)&#123; if(d[x] &gt; d[y]) swap(x, y); for(int i = 19; ~i; --i) if(d[ac[i][y]] &gt;= d[x]) y = ac[i][y]; if(x == y) return x; for(int i = 19; ~i; --i) if(ac[i][x] != ac[i][y]) x = ac[i][x], y = ac[i][y]; return ac[0][x]; &#125;bool cmp(int x, int y) &#123; return nfd[x] &lt; nfd[y]; &#125;namespace vtree&#123;int s[N], top, cov[N];vector&lt;int&gt; edge[N];void add(int x, int y) &#123; edge[x].push_back(y); &#125;void insert(int x)&#123; int lca = LCA(x, s[top]); if(lca == s[top]) return void(s[++top] = x); while(top &gt; 1&amp;&amp;nfd[s[top-1]] &gt;= nfd[lca]) add(s[top-1], s[top]), --top; if(s[top] != lca) add(lca, s[top]), s[top] = lca; s[++top] = x; &#125;void build()&#123; s[top = 1] = 1; for(int k = 1; k &lt;= m; ++k) cov[p[k]] = 1, insert(p[k]); while(top &gt; 1) add(s[top-1], s[top]), --top;&#125;int64 dp(int x)&#123; int64 ret = 0; for(int i = 0; i &lt; edge[x].size(); ++i) ret += dp(edge[x][i]); edge[x].clear(); if(!cov[x]) return min(ret, f[x]); cov[x] = 0; return f[x];&#125;&#125;int main()&#123; n = read(); for(int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(), z = read(); add(x, y, z); &#125; q = read(); memset(f, 0x3f, sizeof(f)); dfs(1, 0); while(q--) &#123; m = read(); for(int k = 1; k &lt;= m; ++k) p[k] = read(); sort(p+1, p+1+m, cmp); vtree::build(); printf("%lld\n", vtree::dp(1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO17DEC]Standing Out from the Herd]]></title>
    <url>%2F2019%2F07%2F01%2FUSACO17DEC-Standing-Out-from-the-Herd%2F</url>
    <content type="text"><![CDATA[题面描述给定字符串集合，求只属于该字符串的本质不同的非空子串的个数 题解难度一般，建一个广义 $SAM$ 在 $Parent$ 树上对 $endpos$ 全部属于同一个字符串的统计即可 关键是下面的错误和解决方法 大部分直接按照 $maxlen$ 拓扑序会 $WA$，是因为如果字符串具有相同前缀则在广义 $SAM$ 中会出现 $maxlen(parent(A))= maxlen(A)$ 主要是因为大部分广义 $SAM$ 的写法每次都必须新建一个 $np$ 节点，但实际上这个 $np$ 节点所表示的原串的前缀有可能在 $SAM$ 上出现了，但由于 $Parent$ 树的性质两者间有边相连，导致了 $maxlen$ 非严格单调递增的父子关系，可以通过 $\lbrace ab, abc\ \rbrace$ 体会一下所以当 $maxlen$ 相同时，后加入的节点要靠后 但是按照我这种写法又 $WA$ 第 $2$ 个点，是由于新建的 $nq$ 节点应该继承 $np$ 节点的某一个 $endpos$ 而不是 $q$ 节点的 $endpos$ 原因是我们会认为在某次加入操作时 $nq$ 的加入顺序晚于 $np$，导致 $np$ 最后不能及时更新 $nq$，那么一开始我们就应该将更晚的 $np$ 的某一个 $endpos$ 赋值给 $nq$1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int N = 2e5+5;typedef long long int64;int last = 1, tot = 1, pre, pos[N], len[N], fa[N], ch[N][26];int tax[N], p[N];int64 ans[N];inline void insert(int c, int p)&#123; int cur = ++tot, pre = last; last = cur; len[cur] = len[pre]+1; pos[cur] = p; while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[pre]+1 == len[x]) return void(fa[cur] = x); int y = ++tot; fa[y] = fa[x]; pos[y] = p; fa[x] = fa[cur] = y; len[y] = len[pre]+1; memcpy(ch[y], ch[x], sizeof(ch[x])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre]; &#125;int n;char s[N];int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) &#123; last = 1; scanf("%s", s); for(int k = 0; s[k]; ++k) insert(s[k]-'a', i); &#125; for(int i = 1; i &lt;= tot; ++i) ++tax[len[i]]; for(int i = 1; i &lt;= tot; ++i) tax[i] += tax[i-1]; for(int i = tot; i; --i) p[tax[len[i]]--] = i; for(int i = tot; i; --i) if(pos[fa[p[i]]] != pos[p[i]]) pos[fa[p[i]]] = 0; for(int i = 1; i &lt;= tot; ++i) ans[pos[i]] += len[i]-len[fa[i]]; for(int i = 1; i &lt;= n; ++i) printf("%lld\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF700E Cool Slogans]]></title>
    <url>%2F2019%2F06%2F30%2FCF700E-Cool-Slogans%2F</url>
    <content type="text"><![CDATA[题面描述求最长子串序列使得后一个在前一个出现至少 $2$ 次 题解子串序列显然属于 $Parent$ 树从根节点到叶子节点的链上，考虑 $Parent$ 树上 $DP$ 但是，答案是最长的一条链吗？ 自己多试几组发现并不是如此，比如 $abababb$ 中 $parent(ab) = a$ 但并没有出现两次 本题的关键在于此 首先，不难证明一个结论 $A$ 的最长串 $S$ 被$Parent$ 树上的祖先 $B$ 的任意 $S’$ 匹配状态相同，所以选最长串作为序列即可对于一个 $endpos$ 集合，只要其中 $1$ 个合法，其他都合法，所以只需判断一次即可，具体来说，设 $parent(A) = B$，若 $p\in endpos(B)\cap [pos(A)-len(A)+len(B),\ pos(B)-1]$ 则出现两次 线段树合并搞一下就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 4e5+5;int last = 1, sam_tot = 1, fa[N], ch[N][26], size[N], len[N], pos[N];int tax[N], p[N];void samAdd(int c)&#123; int cur = ++sam_tot, pre = last; last = sam_tot; len[cur] = len[pre]+1; pos[cur] = len[cur]; while(pre&amp;&amp;!ch[pre][c]) ch[pre][c] = cur, pre = fa[pre]; if(!pre) return void(fa[cur] = 1); int x = ch[pre][c]; if(len[pre]+1 == len[x]) return void(fa[cur] = x); int y = ++sam_tot; fa[y] = fa[x]; pos[y] = pos[x]; len[y] = len[pre]+1; fa[x] = fa[cur] = y; memcpy(ch[y], ch[x], sizeof(ch[x])); while(pre&amp;&amp;ch[pre][c] == x) ch[pre][c] = y, pre = fa[pre];&#125;int n, f[N], top[N];char s[N];int seg_tot, root[N], ls[N&lt;&lt;6], rs[N&lt;&lt;6], val[N&lt;&lt;6], ans;int merge(int x, int y)&#123; if(!x||!y) return x|y; int z = ++seg_tot; val[z] = val[x]+val[y]; ls[z] = merge(ls[x], ls[y]); rs[z] = merge(rs[x], rs[y]); return z;&#125;void add(int &amp;x, int l, int r, int pos)&#123; if(!x) x = ++seg_tot; ++val[x]; if(l == r) return; int mid = (l+r)&gt;&gt;1; if(pos &lt;= mid) add(ls[x], l, mid, pos); else add(rs[x], mid+1, r, pos);&#125;bool query(int x, int l, int r, int ql, int qr)&#123; if(!x||(ql &lt;= l&amp;&amp;r &lt;= qr)) return val[x]; int mid = (l+r)&gt;&gt;1; bool ret = false; if(ql &lt;= mid) ret |= query(ls[x], l, mid, ql, qr); if(qr &gt; mid) ret |= query(rs[x], mid+1, r, ql, qr); return ret; &#125;int main()&#123; scanf("%d%s", &amp;n, s+1); for(int i = 1; i &lt;= n; ++i) add(root[sam_tot+1], 1, n, i), samAdd(s[i]-'a'); for(int i = 1; i &lt;= sam_tot; ++i) ++tax[len[i]]; for(int i = 1; i &lt;= sam_tot; ++i) tax[i] += tax[i-1]; for(int i = 1; i &lt;= sam_tot; ++i) p[tax[len[i]]--] = i; for(int i = sam_tot; i &gt; 1; --i) root[fa[p[i]]] = merge(root[fa[p[i]]], root[p[i]]); for(int i = 2; i &lt;= sam_tot; ++i) &#123; int x = p[i]; if(fa[x] == 1) f[x] = 1, top[x] = x; else &#123; if(query(root[top[fa[x]]], 1, n, pos[x]-len[x]+len[top[fa[x]]], pos[x]-1)) f[x] = f[top[fa[x]]]+1, top[x] = x; else f[x] = f[top[fa[x]]], top[x] = top[fa[x]]; &#125; ans = max(ans, f[x]); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[29609102 NOIP模拟题]]></title>
    <url>%2F2019%2F06%2F30%2F29609102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[GardenP3160 [CQOI2012]局部极小值 对 $n\times m$ 的矩阵进行不重复的 $[1,\ n\times m]$ 整数填数，定义局部最小值为比其八连通块都小的位置，给定局部最小值，求合法方案数 如果罗兹瓦尔说的像这样清晰该有多好 还是我语文太差了 先不讨论非局部最小值的合法性，显然这是一个拓扑排序计数问题，对于一般图的拓扑排序计数问题，通常使用状压$DP$，把已排序好的集合作为状态，在转移时判断加入集合的点的前驱是否都已排序，而顺序性体现已排序集合的扩大的过程中，这也是排序问题的核心思想在这道题里还有一个比较明显的性质，局部最小值的数量不超过 $8$ 所以考场上直接写了一个裸的拓扑排序计数和一个小小的剪枝 然后，果断便会白给 没有生成一组极限数据测状态数 正解首先是对 $DP$ 的优化 设局部最小值的填数状态为 $S$ 已填 $i$ 个数的方案数 $f_{i,S}$ 和在状态 $S$ 下不受局部最小值限制的位置个数为 $g_S$ 则有转移 $$f_{i,S}\ =\ f_{i-1,S}\times (g_S-(i-1))+\sum_{p\in S}f_{i-1,S-p}$$ 前一部是当前的数不给局部最小值，后一部分是给局部最小值 时间复杂度 $O(nm2^k)$ 其中 $k\le8$ 接下来讨论非局部最小值的合法性，考虑直接按上述式子 $DP$ 求出的是至少有$0$个非局部最小值成为局部最小值，而题意要求恰好有$0$个非局部最小值成为局部最小值，直接组合容斥即可 具体来说，设 $h_k$ 为至少有$k$个非局部最小值成为局部最小值，那么就有 $$ans\ =\ \sum(-1)^kh_k$$ 其中 $h_k$ 不需要具体求出，$DFS$ 枚举合法的转化数量即可 时间大概 $O(tnm2^k)$ 其中 $t\in [\Pi(nm-9i-9k),\Pi(nm-4i-4k)]$ $t$ 离上界相差很远，总之很优秀 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;map&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 4+5, M = 7+5, P = 12345678;const int dx[8] = &#123;0, 0, 1, 1, -1, -1, 1, -1&#125;;const int dy[8] = &#123;1, -1, 1, -1, 1, -1, 0, 0&#125;; int t, n, m, d;char w[N][M];int f[N*M][1&lt;&lt;8], ans, g[1&lt;&lt;8];int bit(int i, int j) &#123; return (i-1)*m+j-1; &#125;pair&lt;int, int&gt; dbit(int p) &#123; return make_pair(p/m+1, p%m+1); &#125;pair&lt;int, int&gt; c[N];int hateMathers()&#123; memset(f, 0, sizeof(f)); d = 0; memset(g, 0, sizeof(g)); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(w[i][j] == 'X') c[d++] = make_pair(i, j); for(int s = 0; s &lt; 1&lt;&lt;d; ++s) &#123; for(int i = 0; i &lt; d; ++i) w[c[i].first][c[i].second] = (s&gt;&gt;i&amp;1)?'.':'X'; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) &#123; if(w[i][j] == 'X') continue; int q = 1; for(int k = 0; k &lt; 8; ++k) if(w[i+dx[k]][j+dy[k]] == 'X') q = 0; g[s] += q; &#125; &#125; for(int i = 0; i &lt; d; ++i) w[c[i].first][c[i].second] = 'X'; f[0][0] = 1; for(int i = 1; i &lt;= n*m; ++i) for(int s = 0; s &lt; 1&lt;&lt;d; ++s) &#123; f[i][s] = 1ll*f[i-1][s]*(g[s]-i+1)%P; for(int p = 0; p &lt; d; ++p) if(s&gt;&gt;p&amp;1) f[i][s] = (f[i][s]+f[i-1][s^(1&lt;&lt;p)])%P; &#125; return f[n*m][(1&lt;&lt;d)-1];&#125;void hateRoswaal(int p, int k)&#123; if(p == n*m) return void(ans = (ans+k*hateMathers()+P)%P); pair&lt;int, int&gt; par = dbit(p); int x = par.first, y = par.second; if(w[x][y] == 'X') hateRoswaal(p+1, k); else &#123; hateRoswaal(p+1, k); for(int i = 0; i &lt; 8; ++i) if(w[x+dx[i]][y+dy[i]] == 'X') return; w[x][y] = 'X'; hateRoswaal(p+1, -k); w[x][y] = '.'; &#125;&#125;int main()&#123; freopen("garden.in", "r", stdin); freopen("garden.out", "w", stdout); t = read(); while(t--) &#123; n = read(), m = read(); ans = 0; memset(w, 0, sizeof(w)); for(int i = 1; i &lt;= n; ++i) scanf("%s", w[i]+1); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) &#123; bool is_emp = true; for(int k = 0; k &lt; 8&amp;&amp;is_emp; ++k) if(w[i+dx[k]][j+dy[k]] == 'X') is_emp = false; if(!is_emp&amp;&amp;w[i][j] == 'X') ans = -1; &#125; if(ans == -1) printf("0\n"); else hateRoswaal(0, 1), printf("%d\n", ans); &#125; return 0;&#125; Throw 求 $(a,\ b,\ c)$ 经过 $f(a,\ b,\ c)$ 变为 $(a’,\ b’,\ c’)$ 的最小操作个数 很好的思维题 考试时写搜索时，想到双向搜索，想到双向搜索又想到建树，但没继续像，转而想 $exgcd$ 和毒瘤贪心 首先题目中的丢你拉姆过于花哨，与三元素中每一个元素等价这一条件显得十分不自然，我们结合 P1007 独木桥 的想法，我们把调换顺序看作平移相同距离，这样每个元素在变化上与等价的条件相应，即 $$f_(a,\ b,\ c)\rightarrow\begin{cases}(a+(b-a),\ b+(b-a),\ c),\ b-a&lt;c-b\\(a-(b-a),\ b-(b-a),\ c)\\(a,\ b-(c-b),\ c-(c-b)),\ b-a&gt;c-b\\(a,\ b+(c-b),\ c+(c-b))\end{cases}$$ 显然 $(a,\ b,\ c)$ 的变化不超过 $3$ 我们考虑按照这种关系建树，发现以 $(A,\ B,\ C)$ 其中 $B-A=C-B$ 时恰好为树的形态且还是一颗二叉树，那么答案就是树上两点的距离 其次答案具有单调性，所以先调整到同一高度，在二分向上跳的距离判断是否相等即可 在向上跳的过程中可以一下跳多步，用距离除一下贪心即可 或者按照这样理解 设 $g(n,\ m)$ 其中 $n=b-a,\ m=c-b$ 那么向上跳是一个更相减损的过程，用辗转相除优化即可，这也是 [CQOI2017] 小Q的表格 最关键的一步 还有一些细节，在注释里标注 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;queue&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int INF = 0x3f3f3f3f;struct Node&#123; int p[3]; int operator [] (const int x) &#123; return p[x]; &#125; bool operator == (const Node &amp;_) const &#123; return p[0]==_.p[0]&amp;&amp;p[1]==_.p[1]&amp;&amp;p[2]==_.p[2]; &#125; bool operator != (const Node &amp;_) const &#123; return !(p[0]==_.p[0]&amp;&amp;p[1]==_.p[1]&amp;&amp;p[2]==_.p[2]); &#125; Node(int x = 0, int y = 0, int z = 0) &#123; p[0] = x, p[1] = y, p[2] = z; sort(p, p+3); &#125;&#125;s, t;int ds, dt, ans, buf;Node get(Node p, int up, int &amp;d)&#123; int a = p[1]-p[0], b = p[2]-p[1], c; if(!up||a == b) return p; if(a &lt; b) c = min(up, (b-1)/a), p = Node(p[0]+c*a, p[1]+c*a, p[2]); // 不能相等，所以要减 1 else c = min(up, (a-1)/b), p = Node(p[0], p[1]-c*b, p[2]-c*b); d += c; up -= c; return get(p, up, d);&#125;int main()&#123; freopen("throw.in", "r", stdin); freopen("throw.out", "w", stdout); s = Node(read(), read(), read()); t = Node(read(), read(), read()); if(get(s, INF, ds) != get(t, INF, dt)) puts("NO"); else &#123; puts("YES"); if(ds &lt; dt) swap(s, t), swap(ds, dt); int l = 0, r = dt; s = get(s, ds-dt, buf); while(l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if(get(s, mid, buf) == get(t, mid, buf)) ans = mid, r = mid-1; else l = mid+1; &#125; printf("%d\n", ans*2+ds-dt); // 注意乘2 &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>容斥</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[42609102 NOIP模拟题]]></title>
    <url>%2F2019%2F06%2F24%2F42609102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[施工 已知 $F(t)\ =\ \sum_{i=1}^nt_i^2+\sum_{i=2}^n|h_i+t_i-t_{i-1}-h_{i-1}|$ ，求 $F_{min}$ 设 $f_{i,j}$ 表示 $t_i\ =\ j$ 时 $F_i(t)$ 的最小值则有如下转移 $$f_{i,j}\ =\begin{cases}f_{i-1,k}+j^2+|k+h_{i-1}-h_i-j| ,\ j&gt;1\\j^2,\ i\ =\ 1\end{cases}$$时间复杂度 $O(nh_{max}^2)$，空间复杂度 $O(nh_{max})$，期望得分 $11$ 考虑优化，很明显最关键的是优化掉第二维，结合贪心我们发现最终一定有一定的区间的 $t+h$ 相同，不依次来转移 $$f_i\ =\begin{cases}f_j+\sum_{k=j+1}^{i-1}(h-h_k)^2+c(h_i+h_j-2h),\ j&lt;i-1,max_{j+1\le k\le i-1}\lbrace h_k\rbrace \le \min\lbrace h_i,h_j\rbrace \\f_j+|h_i-h_j|,\ j\ =\ i-1\end{cases}$$ 观察上述式子，其中 $h$ 可由二次函数对称轴确定，具体来说 $$\begin{aligned}g(h)\ &amp;=\ \sum_{k=j+1}^{i-1}(h-h_i)^2+c(h_i+h_j-2h)\\&amp;=\ \sum_{k=j+1}^{i-1}(h^2+h_i^2-2hh_i)-c(h_i+h_j)-2ch\\&amp;=\ (i-j-1)h^2-2(\sum_{k=j+1}^{i-1}h_k+c)h+\sum_{k=j+1}^{i-1}h_k^2-c(h_i+h_j)\end{aligned}$$ 那么当$h\approx \frac{\sum_{k=j+1}^{i-1}h_k+c}{i-j-1}$ 时，$g$ 值最小 现在空间复杂度 $O(n)$ 考虑优化时间 注意到第一个转移的条件 $j&lt;i-1,max_{j+1\le k\le i-1}\lbrace h_k\rbrace$ 这不就是个裸的单调栈吗 用单调栈维护即可 $O(n)$ 还有一件事 这样表示状态对于 $i=1$ 或 $i=n$ 比较麻烦，所以我们不妨增加两个虚拟节点，之后特判即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1e6+5;const int64 INF = 0x3f3f3f3f3f3f3f3fLL;int n, m, c, h[N];int64 ans = INF, f[N], s1[N], s2[N];int s[N], top;int64 calc(int i, int j, int hk)&#123; int64 A = i-j-1; int64 B = -2*(s1[i-1]-s1[j])-(i!=n+1)*c-(j!=0)*c; int64 C = s2[i-1]-s2[j]+1ll*(i!=n+1)*h[i]*c+1ll*(j!=0)*h[j]*c; int x = (int)round(-1.0*double(B)/double(A)/2.0); x = max(x, hk); if(i != n+1) x = min(x, h[i]); if(j != 0) x = min(x, h[j]); return A*x*x+B*x+C;&#125;int main()&#123; freopen("construct.in", "r", stdin); freopen("construct.out", "w", stdout); n = read(), c = read(); for(int i = 1; i &lt;= n; ++i) h[i] = read(), m = max(h[i], m), s1[i] = s1[i-1]+h[i], s2[i] = s2[i-1]+1ll*h[i]*h[i]; s[++top] = 0; h[0] = h[n+1] = m+1; for(int i = 1; i &lt;= n+1; ++i) &#123; f[i] = f[i-1]+1ll*(i != 1&amp;&amp;i != n+1)*c*abs(h[i]-h[i-1]); while(top&amp;&amp;h[s[top]] &lt;= h[i]) &#123; if(top &gt; 1) f[i] = min(f[i], f[s[top-1]]+calc(i, s[top-1], h[s[top]])); --top; &#125; s[++top] = i; &#125; printf("%lld\n", f[n+1]); return 0;&#125;``` ## 蔬菜&gt; 求矩形区域内颜色的出现次数的平方和玄学题目，正解是按照出现次数分组，然而莫队可以水过去，但考场上看到转移是 $O(n)$ 就果断放弃了，但确实能过 ㄟ( ▔, ▔ )ㄏ莫队复杂度 $O(qT+\frac&#123;n^2&#125;&#123;T&#125;+\frac&#123;n^3&#125;&#123;T^2&#125;+\frac&#123;n^4&#125;&#123;T^3&#125;)$ 差不多在 $T = \frac&#123;n&#125;&#123;q^&#123;\frac&#123;1&#125;&#123;4&#125;&#125;&#125;$ 时最优最后，记得跳指针时先扩张再减小```cpp#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int M = 2e2+5, N = 1e6+5;int n, m, t;int _[N], tot;int c[M][M];int bel[N], T;struct Query&#123; int px, py, qx, qy, p; Query(int px = 0, int py = 0, int qx = 0, int qy = 0, int p = 0):px(px), py(py), qx(qx), qy(qy), p(p) &#123;&#125; bool operator &lt; (const Query &amp;_) const &#123; if(bel[px] != bel[_.px]) return px &lt; _.px; if(py != _.py) return py &lt; _.qy; if(qx != _.qx) return qx &lt; _.qx; return qy &lt; _.qy; &#125;&#125;q[N];int ans[N];int px = 1, py = 1, qx = 1, qy = 1, cnt[N], ret = 1;void cUpdate(int x, int d)&#123; for(int y = py; y &lt;= qy; ++y) if(c[x][y]) ret -= cnt[c[x][y]]*cnt[c[x][y]], cnt[c[x][y]] += d, ret += cnt[c[x][y]]*cnt[c[x][y]];&#125;void rUpdate(int y, int d)&#123; for(int x = px; x &lt;= qx; ++x) if(c[x][y]) ret -= cnt[c[x][y]]*cnt[c[x][y]], cnt[c[x][y]] += d, ret += cnt[c[x][y]]*cnt[c[x][y]];&#125;int main()&#123; n = read(), m = read(), t = read(); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) c[i][j] = read(), _[++tot] = c[i][j]; sort(_+1, _+tot+1); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) c[i][j] = lower_bound(_+1, _+tot+1, c[i][j])-_; T = int(1.0*n/pow(t, 0.25))+1; for(int i = 1; i &lt;= n; ++i) bel[i] = i/T+1; for(int i = 1; i &lt;= t; ++i) &#123; int px = read(), py = read(), qx = read(), qy = read(); q[i] = Query(px, py, qx, qy, i); &#125; sort(q+1, q+1+t); ++cnt[c[1][1]]; for(int i = 1; i &lt;= t; ++i) &#123; while(px &gt; q[i].px) --px, cUpdate(px, 1); while(qx &lt; q[i].qx) ++qx, cUpdate(qx, 1); while(px &lt; q[i].px) cUpdate(px, -1), ++px; while(qx &gt; q[i].qx) cUpdate(qx, -1), --qx; while(py &gt; q[i].py) --py, rUpdate(py, 1); while(qy &lt; q[i].qy) ++qy, rUpdate(qy, 1); while(py &lt; q[i].py) rUpdate(py, -1), ++py; while(qy &gt; q[i].qy) rUpdate(qy, -1), --qy; ans[q[i].p] = ret; &#125; for(int i = 1; i &lt;= t; ++i) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调栈</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JXOI2017]颜色]]></title>
    <url>%2F2019%2F05%2F11%2FJXOI2017-%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题面描述一个颜色序列删去颜色的方案使得最后剩下来的序列非空且连续 题解首先一个序列非空且连续就是原颜色序列的一段连续区间，这段颜色区间的每个颜色仅在该区间里出现，对于每个颜色都有一个左端点和右端点，我们枚举合法区间的左端点就可以通过某些数据结构来后面的位置找有多少个合法右端点即可然而分析到这就结束了，因为认为对于合法区间有可能会算重合法方案 我真傻，真的 让我们复读看一下这句话 这段颜色区间的每个颜色仅在该区间里出现 若存在两个区间的颜色集合相同又怎么可以合法呢 但是就直接去看了题解 同时在看题解时看到了一个神奇的解法 对于每种颜色的每个位置随机赋值，最后一个位置赋值为前面位置的和的相反数，合法区间的权值为 $0$ 所以说我们维护前缀和，扫描数组前缀和相同累积答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;cstdint&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 3e5+5;const int64_t P = 1e12; // 哈希冲突有些严重，大一点好int n, t, a[N];int64_t f[N];int64_t sum, ans; vector&lt;int&gt; p[N];map&lt;int64_t, int&gt; h;int main()&#123; t = read(); while(t--) &#123; n = read(); ans = 0; h.clear(); for(int i = 1; i &lt;= n; ++i) f[i] = 0, p[i].clear(); for(int i = 1; i &lt;= n; ++i) a[i] = read(), p[a[i]].push_back(i); for(int i = 1; i &lt;= n; ++i) &#123; if(p[i].size() &lt; 2) continue; sum = 0; for(int j = 0; j &lt; p[i].size()-1; ++j) &#123; int q = p[i][j]; int64_t d = 1ll*rand()*rand()%P*rand()%P*rand()%P; if(rand()&amp;1) d = -d; sum += d; f[q] = d; &#125; f[p[i][p[i].size()-1]] = -sum; &#125; sum = 0; h[0] = 1; for(int i = 1; i &lt;= n; ++i) sum += f[i], ans += h[sum], ++h[sum]; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JXOI2017]数列]]></title>
    <url>%2F2019%2F05%2F11%2FJXOI2017-%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题面描述求满足题目中限制条件的合法填数数量 题解我不会推性质，只好写一个状压得 $60$ 暴力分 我们发现题目中得状态必须和位置与至于有关，不妨考虑状态 $f_{i,l,r}$ 代表在位置 $i$ 取值范围为 $[l,\ r]$ 得方案数，考虑这个状态如何转移出去我们发现 $A_{i-1}$ 和 $A_i$ 都不会超过这个值域，我们讨论一下他们的大小 当 $A_i\ =\ A_{i-1}\ = l$ 时，$A_{i+1}\in [l,\ l]$ 当 $l &lt; A_i\ \le\ A_{i-1}\ &lt; r$ 时，$A_{i+1}\in [l,\ A_{i-1}]$ 当 $l &lt; A_{i-1}\ \le\ A_i\ &lt; r$ 时，$A_{i+1}\in [A_{i-1},\ r]$ 当 $A_i\ =\ A_{i-1}\ = r$ 时，$A_{i+1}\in [r,\ r]$ 因此我们可以通过枚举 $A_{i-1}$ 的取值确定下一部分的值 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 50+5, M = 150+5, P = 998244353;int n, a[N];int f[N][M][M];int dp(int p, int l, int r)&#123; if(p == n+1) return f[p][l][r] = 1; int &amp;ret = f[p][l][r]; if(~ret) return ret; ret = 0; for(int i = max(l, 1); i &lt;= min(r, a[p]); ++i) // 枚举 A_i-1 的值 if(i == l||i == r) ret = (ret+dp(p+1, i, i))%P; else ret = (((ret+dp(p+1, l, i))%P+dp(p+1, i, r))%P-dp(p+1, i, i)+P)%P; // 减去重复的 return ret;&#125;int main()&#123; n = read(); memset(f, -1, sizeof(f)); for(int i = 1; i &lt;= n; ++i) a[i] = read(); printf("%d\n", dp(1, 0, 151)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[FJOI2017]矩阵填数]]></title>
    <url>%2F2019%2F05%2F11%2FFJOI2017-%E7%9F%A9%E9%98%B5%E5%A1%AB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题面描述给定矩阵和多个子矩形权值，对矩阵填数满足给定子矩阵的最大值为权值，求方案数 题解很容易想到容斥，但是我太菜了不知道怎么算，一直认为补集转换时由等于必须变为不等于，但是却没想到全集是可以自己定义的，这样就可以由等于变为小于了，剩下就比较好办了，离散化后分割矩阵即可具体来说我们定义问题的全集 $S$ 每个元素的值域为 $[1,\ min(m,v_k)]$ 我们现在对限制进行补集转化，变为性质 $p_k=w_{i,j}&lt;v_k$，具有该性质的集合为 $A_k$ ，我们现在要求求出不满足任意一条性质的方案数 $T$，根据组合容斥公式$$T\ =\ |S|-\sum_{k=1}^n(-1)^k\sum_{1\le i_1&lt;i_2&lt;…&lt;i_k\le n}|A_{i_1}\cap A_{i_2}\cap …\cap A_{i_k}|$$ 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int P = 1e9+7, N = 1e3+5;inline int qpow(int a, int b)&#123; int ret = 1; for( ; b; b &gt;&gt;= 1, a = 1ll*a*a%P) if(b&amp;1) ret = 1ll*ret*a%P; return ret;&#125;int n, a, b, m;int t, tx, ty, tv;int xs[N], ys[N], vs[N], w[N][N], fv[N][N], c[N];int x1[N], y1[N], x2[N], y2[N], v[N];int ans;signed main()&#123; t = read(); while(t--) &#123; a = read(), b = read(), m = read(), n = read(); tx = ty = tv = ans = 0; xs[++tx] = 1; xs[++tx] = a+1; ys[++ty] = 1; ys[++ty] = b+1; vs[++tv] = m; for(int i = 1; i &lt;= n; ++i) &#123; x1[i] = read(), y1[i] = read(); x2[i] = read(), y2[i] = read(); v[i] = read(); vs[++tv] = v[i]; vs[++tv] = v[i]-1; xs[++tx] = x1[i]; xs[++tx] = x2[i]+1; // 左闭右开 ys[++ty] = y1[i]; ys[++ty] = y2[i]+1; &#125; sort(xs+1, xs+1+tx); sort(ys+1, ys+1+ty); sort(vs+1, vs+1+tv); tx = unique(xs+1, xs+1+tx)-xs-1; ty = unique(ys+1, ys+1+ty)-ys-1; tv = unique(vs+1, vs+1+tv)-vs-1; for(int i = 1; i &lt; tx; ++i) for(int j = 1; j &lt; ty; ++j) w[i][j] = (xs[i+1]-xs[i])*(ys[j+1]-ys[j]); for(int i = 1; i &lt;= n; ++i) &#123; x1[i] = lower_bound(xs+1, xs+1+tx, x1[i])-xs; y1[i] = lower_bound(ys+1, ys+1+ty, y1[i])-ys; x2[i] = lower_bound(xs+1, xs+1+tx, x2[i]+1)-xs; y2[i] = lower_bound(ys+1, ys+1+ty, y2[i]+1)-ys; v[i] = lower_bound(vs+1, vs+1+tv, v[i])-vs; &#125; for(int s = 0; s &lt; 1&lt;&lt;n; ++s) &#123; int f = 1; for(int i = 1; i &lt; tx; ++i) for(int j = 1; j &lt; ty; ++j) fv[i][j] = tv; for(int i = 1; i &lt;= n; ++i) &#123; int cv = v[i]; if(s&gt;&gt;(i-1)&amp;1) f = P-f, --cv; for(int j = x1[i]; j &lt; x2[i]; ++j) for(int k = y1[i]; k &lt; y2[i]; ++k) fv[j][k] = min(cv, fv[j][k]); &#125; for(int i = 1; i &lt;= tv; ++i) c[i] = 0; for(int i = 1; i &lt; tx; ++i) for(int j = 1; j &lt; ty; ++j) c[fv[i][j]] += w[i][j]; int ret = 1; for(int i = 1; i &lt;= tv; ++i) ret = 1ll*ret*qpow(vs[i], c[i])%P; ans = (ans+1ll*f*ret%P)%P; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合计数</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论出题组比赛 数列]]></title>
    <url>%2F2019%2F05%2F11%2F%E6%95%B0%E8%AE%BA%E5%87%BA%E9%A2%98%E7%BB%84%E6%AF%94%E8%B5%9B-%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述求二阶线性常系数齐次递推的平方和。 题解由于这道题意要求，下文数列下标都从 1 开始 前置知识线性常系数齐次递推关系若递推关系满足 $$f_n\ =\ \sum_{i=1}^kc_if_{n-i}\ (n &gt;k)$$且对于 $f_1,\ c_1,\ f_2,\ c_2\ …\ f_k,\ c_k$ 都为常数 则称这种递推关系为线性常系数齐次递推关系，其中 $k$ 为阶数 斐波那契数列就是常见的满足二阶线性常系数齐次递推关系的数列 特征方程求解线性常系数齐次递推方法的有很多，特征方程是常见的一种 对于递推 $f_n\ =\ 2f_{n-1}+3f_{n-2}$ 来说 我们构造等比数列 $\langle\ 1,\ -1,\ 1\ …\ \rangle$ 满足这种关系，其中 $g_n\ =\ (-1)^{n-1}$ 又另一个构造等比数列 $\langle\ 1,\ 3,\ 9\ …\ \rangle$ 满足这种关系，其中 $h_n\ =\ 3^{n-1}$ 仔细思考发现对于常数 $\alpha$ 和 $\beta$ 而言 $\lbrace \alpha g_n\rbrace$ 和 $\lbrace \beta h_n\rbrace$ 都满足 进一步思考后感觉对于 $\lbrace \alpha g_n\ +\ \beta h_n\rbrace$ 也都满足，其正确性十分明显无需多言 也就是说我们可以通过一些等比数列作为基底，通过它们的线性组合，生成很多满足线性常系数齐次递推的数列 如何找到这些等比数列呢？拿二阶来说 我们不妨设等比数列 $q_n$ 的公比为 $x$，我们发现递推关系可以写成$$x^2q_n\ =\ axq_n+\ bq_n$$两边同时消去 $q_n$，只剩下$$x^2\ =\ ax\ + b$$ 这个方程叫做特征方程，通过这个我们就可以找到所有满足条件的等比数列 现在用斐波那契数列举例，特征方程为 $$x^2\ =\ x\ +\ 1$$ 解得 $x_1\ =\ \frac{1+\sqrt{5}}{2}$，$x_2\ =\ \frac{1-\sqrt{5}}{2}$ 我们现在要解出 $\alpha$ 和 $\beta$，则有 $f_n= \alpha(x_1)^{n-1}+\beta(x_2)^{n-1}$ 带入 $f_1=1$ 和 $f_2=1$ 得 $$\begin{cases}\alpha+\beta=1\\\alpha x_1+\beta x_2=1\\end{cases}\Rightarrow\begin{cases}\alpha=\frac{\sqrt{5}-1}{2\sqrt{5}}\\\beta=\frac{\sqrt{5}+1}{2\sqrt{5}}\\end{cases}$$ 所以 $f_n=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-\frac{1-\sqrt{5}}{2})^n]$ 模意义下的根式运算假如我们在计算过程中出现了根式，但保证根号下的数不变且结果一定不包含根式，要求在模$P$意义下进行，保证计算过程中的任何数有逆元，如何解决呢？ 我们可以把根式写作类似复数的形式 $a+\sqrt{k}b$ 其中 $k$ 是所有数的根号下面的部分，如 $a+\sqrt{2}\ b$ 等 我们把 $a$ 称作有理部，$b$ 称作无理部，$\sqrt{k}$ 称作基 下面给出几项重要的运算，基不会被取模 加法 $(a+\sqrt{k}b)+(c+\sqrt{k}d)\ \equiv\ (a+b)+\sqrt{k}(c+d)\ (mod\ P)$ 减法 $(a-\sqrt{k}b)+(c-\sqrt{k}d)\ \equiv\ (a-b)+\sqrt{k}(c-d)\ (mod\ P)$ 共轭 $conj(a+\sqrt{k}b)\ \equiv\ a+\sqrt{k}(-b)\ (mod\ P)$ 乘法 $(a+\sqrt{k}b)(c+\sqrt{k}d)\ \equiv\ (ac+bdk)+\sqrt{k}(ad+bc)\ (mod\ P)$ 除法比较特殊，我们需要先将分母有理化，即同时将分子和分母同时乘上分母的共轭，这是分母就只剩下有理部了，这是再把分子部分除以分母有理部的逆元即可 除法 $\frac{a+\sqrt{k}b}{c+\sqrt{k}d}\ \equiv\ \frac{(a+\sqrt{k}b)(c+\sqrt{k}d)}{c^2-kd^2} (mod\ P)$ 写出来就是 123456789101112131415161718192021struct Complex&#123; int rat, irr; // rat 有理部 irr 无理部 irr_base 基 Complex(int rat = 0, int irr = 0):rat(rat), irr(irr) &#123;&#125;; Complex conj() const &#123; return Complex(rat, P-irr); &#125; Complex operator - (const Complex &amp;_) const &#123; return Complex((rat-_.rat+P)%P, (irr-_.irr+P)%P); &#125; Complex operator + (const Complex &amp;_) const &#123; return Complex((rat+_.rat)%P, (irr+_.irr)%P); &#125; Complex operator * (const Complex &amp;_) const &#123; Complex ret; ret.rat = (rat*_.rat%P+irr*_.irr%P*irr_base%P)%P; ret.irr = (rat*_.irr%P+irr*_.rat%P)%P; return ret; &#125; Complex operator / (const Complex &amp;_) const &#123; Complex a = Complex(rat, irr)*_.conj(); Complex b = _*_.conj(); a = a*Complex(qpow(b.rat, P-2), 0); // 求逆 return a; &#125;&#125;; 题目主体题干给出的是一个二阶线性常系数齐次递推数列，而让求出前 $n$ 项平方和 有前置知识得出这个数列的通项的是几个等比数列的线性组合，那么最后也无非是几个等比数列求和罢了 同时这道题保证了特征方程有两根和根式模运算的前提条件，所以下面做法极其暴力 设数列为 $\lbrace f_n\rbrace$ 其他变量名含义与前置知识中的相同 则有$$\begin{cases}x_1\ =\ \frac{a+\sqrt{a^2+4b}}{2}\\x_2\ =\ \frac{a-\sqrt{a^2+4b}}{2}\\\alpha\ =\ \frac{x_1f_1-f_2}{x_1-x_2}\\\beta\ =\ \frac{f_2-x_2f_1}{x_1-x_2}\end{cases}$$ 而 $f_n= \alpha(x_1)^{n-1}+\beta(x_2)^{n-1}$ 那么 $f_n^2= \alpha^2(x_1^2)^{n-1}+\beta^2(x_2^2)^{n-1}+2\alpha\beta(x_1x_2)^{n-1}$ 每一部分都是等比数列，用公式 $S_n\ =\ \frac{x^n-1}{x-1}$ 即可 暴力代码如下，没有加任何常数优化居然跑得最快 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define int long long // 虽然习惯不好，但是在这题比较方便using namespace std;const int P = 1e9+7;int n, t, a, b, irr_base, f1, f2;int qpow(int a, int b)&#123; int ret = 1; for( ; b; b &gt;&gt;= 1, a = a*a%P) if(b&amp;1) ret = ret*a%P; return ret;&#125;struct Complex&#123; int rat, irr; Complex(int rat = 0, int irr = 0):rat(rat), irr(irr) &#123;&#125;; Complex conj() const &#123; return Complex(rat, P-irr); &#125; Complex operator - (const Complex &amp;_) const &#123; return Complex((rat-_.rat+P)%P, (irr-_.irr+P)%P); &#125; Complex operator + (const Complex &amp;_) const &#123; return Complex((rat+_.rat)%P, (irr+_.irr)%P); &#125; Complex operator * (const Complex &amp;_) const &#123; Complex ret; ret.rat = (rat*_.rat%P+irr*_.irr%P*irr_base%P)%P; ret.irr = (rat*_.irr%P+irr*_.rat%P)%P; return ret; &#125; Complex operator / (const Complex &amp;_) const &#123; Complex a = Complex(rat, irr)*_.conj(); Complex b = _*_.conj(); a = a*Complex(qpow(b.rat, P-2), 0); return a; &#125;&#125;;Complex qpow(Complex a, int b)&#123; Complex ret = Complex(1, 0); for( ; b; b &gt;&gt;= 1, a = a*a) if(b&amp;1) ret = ret*a; return ret;&#125;Complex alpha, beta, x1, x2, fn;Complex sum1, sum2, sum3, ans;signed main()&#123; scanf("%lld", &amp;t); while(t--) &#123; scanf("%lld%lld%lld%lld%lld", &amp;n, &amp;f1, &amp;f2, &amp;a, &amp;b); irr_base = (a*a%P+4*b%P)%P; x1 = Complex(a, 1)/Complex(2, 0); x2 = Complex(a, P-1)/Complex(2, 0); alpha = (Complex(f2, 0)-x2*Complex(f1, 0))/(x1-x2); beta = (x1*Complex(f1, 0)-Complex(f2, 0))/(x1-x2); fn = alpha*qpow(x1, n-1)+beta*qpow(x2, n-1); sum1 = (qpow(x1*x1, n)-Complex(1, 0))/(x1*x1-Complex(1, 0))*alpha*alpha; sum2 = (qpow(x2*x2, n)-Complex(1, 0))/(x2*x2-Complex(1, 0))*beta*beta; sum3 = (qpow(x1*x2, n)-Complex(1, 0))/(x1*x2-Complex(1, 0))*beta*alpha*Complex(2, 0); ans = sum1+sum2+sum3; printf("%lld\n", ans.rat); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[90509102 NOIP模拟题]]></title>
    <url>%2F2019%2F05%2F09%2F90509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[C题面描述树上快速维护位运算 题解设 $u$ 和 $v$ 的有向简单路径构成的集合为 $S(u,\ v)$ 题意即是求$$\sum_{w\in S(u,v)}a_w\ or\ dis(u,\ w)$$ $dis(u,\ w)$ 表示边数位运算和倍增结合的神仙题，题解看了好久 首先，题目询问有向路径，我们把路径用 $lca(u,\ v)$ 分为两半 先考虑向上部分，首先 $or$ 操作不会使贡献减少，它一定有 $\sum_{w\in S}a_w$ 的基础贡献，并且对于位 $k$ 它会增加 $2^k$ 贡献仅当 $2^k\ and\ dis(u,w) =\ 2^k$ 我们发现这样和倍增的思想意外的吻合，倍增中的合并是貌似可以在不考虑进位的情况下快速计算增加的贡献 不妨设 $c_{i,x}$ 表示 $x$ 到根的路径上满足 $x$ 的位 $i$ 为 $0$ 的个数，$fa_{i,x}$ 表示 $x$ 的 $2^i$ 级祖先 很容易写出转移 $$\begin{aligned}fa_{i,x}\ &amp;=\ fa_{i-1,fa_{i-1,x}}\ (i&gt;0)\\c_{i,x}\ &amp;=\ c_{i,fa_{x,0}}+[a_x&gt;&gt;k\&amp;1==0]\\end{aligned}$$ 1for(int i = 1; i &lt;= 20; ++i) fa[i][x] = fa[i-1][fa[i-1][x]]; 1for(int i = 0; i &lt;= 20; ++i) c[i][x] = c[i][fa[0][x]]+((a[x]&gt;&gt;i&amp;1)==0); 设 $f_{i,x}$ 表示 $x$ 向上走 $2^i-1$ 条边的收益，它经过点集 $S$ 即 $$f_{i,x}\ =\ \sum_{w\in S}a_w\ or\ dis(x,\ w)$$ 首先边界为 $f_{0,x}\ =\ a_x$ 考虑转移，设 $y\ =\ fa_{i-1,x},\ z\ =\ fa_{i,x}$ 则有 $$f_{i,x}\ =\ f_{i-1,x}+f_{i-1,y}+2^{i-1}(c_{i-1,y}-c_{i-1,z})$$ 其道理蕴含在下面 原来的答案并不会减少所以先把基础贡献相加，而多出的贡献来源于右半部分原本位 $i-1$ 为 $0$ 的 $a$ 却因为相对距离原本多加了 $2^{i-1}$ 而在 $i-1$ 产生了贡献，利用前缀和的思想从而得出转移方程 这一过程并不会多算或没有考虑进位，因为对于右半部分最大的相对距离 $2^{i-1}-1$ 小于 $2^{i-1}$ 因此不会进位 12for(int i = 1; i &lt;= 20; ++i) f[i][x] = f[i-1][x]+f[i-1][fa[i-1][x]]+(1ll&lt;&lt;(i-1))*(c[i-1][fa[i-1][x]]-c[i-1][fa[i][x]]); 预处理出这些后我们考虑怎么查询向上的答案 由于倍增数组，我们无非是对于 $u$ 到 $lca$ 的路径长度二进制分解，再向上跳父亲的过程中像上述转移方程一样计算后半部分相对距离增加后对答案的贡献 比如说 我们现在在 $1$ 号节点到 $6$ 号节点，可以使用 $1$ 的倍增数组，因为相对距离的偏移量再之前已经算过了 我们现在可以跳到 $5$ 号节点，中间累加 $f_{1,2}$ 的贡献即点集 $S(1,4)$ 的贡献，同时后半部分 $S(5,6)$ 再从 $5$ 出发相对距离增加 $4$，即位 $2$ 由 $0$ 变为 $1$ ，类比上述转移，答案增加 $2^2(cnt_{2,5}-cnt_{2,7})$ 但是我们是从小到大进行二进制分解，还是从大到小是一个问题 我们是必须要避免相对距离增加过程是否有进位的 所以假设从大到小枚举 $i$ 对于当前 $2^i$，而后面的和由等比数列求和得到 $2^i-1$ 所以没有进位，而逆序枚举就不一样了 所以向上统计时需要这样做 1234567891011int64_t queryUp(int u, int tar) // tar 是 lca 的父亲，但最后点集只会到lca，想一想为什么(考虑fa[i][x]和f[i][x]走到节点的不同)&#123; int w = u; int64_t ret = 0; for(int i = 20; ~i; --i) if(d[fa[i][w]] &gt;= d[tar]) // 从大到小枚举即使贪心的向上条就行了 &#123; ret += f[i][w]; w = fa[i][w]; ret += (1ll&lt;&lt;i)*(c[i][w]-c[i][tar]); &#125; return ret;&#125; 向下差不多就是类比向上了 设 $g_{i,x}$ 表示 $x$ 从 $2^i-1$级祖先，向下走 $2^i-1$ 条边的收益 边界为 $g_{0,x}\ =\ a_x$ 考虑转移，设 $y\ =\ fa_{i-1,x}$，则有 $$g_{i,x}\ =\ g_{i-1,x}+g_{i-1,y}+2^{i-1}(c_{i-1,x}-c_{i-1,y})$$ 转移过程差不多和 $f$ 一样，只不过产生贡献是左半部分 12for(int i = 1; i &lt;= 20; ++i) g[i][x] = g[i-1][x]+g[i-1][fa[i-1][x]]+(1ll&lt;&lt;(i-1))*(c[i-1][x]-c[i-1][fa[i-1][x]]); 我们考虑怎么统计向下路径，标程的想法极富创造性 我们要统计 $3$ 向下到 $6$ 的路径，可是相对距离增初始加的就不是 $2$ 的整数次幂，就非常麻烦 我们考虑把路径的另一半对称上去，使其变为到根节点的直链 这时就相当于从 $u$ 的 $dis(u,v)$ 级祖先向下走 $dis(u,v)$ 步的收益，利用前缀和的思想再减去 从 $lca$ 的 $dis(u,lca)$ 级祖先向下走 $dis(u,lca)$ 步 的收益 这样貌似就是对 $g$ 做二进制拆分的操作了 但此时 $i$ 出现了枚举顺序的问题 考虑从$3$向上跳到$5$的过程，这是 $S(1,2)$ 的相对路径增加了 $2$，贡献增加了 $2^1(cnt_{1,3}-cnt_{1,1})$ 所以我们再不进位的情况下要求前缀和小与当前值，当从小到大枚举时，前缀和 $2^i-1$ 小于 $2^i$ 所以进行如下操作 1234567891011int64_t queryDown(int v, int dis)&#123; int w = v; int64_t ret = 0; ++dis; // 和上文的 tar 同理 for(int i = 0; i &lt;= 20; ++i) // 从小到大枚举 if(dis&gt;&gt;i&amp;1) &#123; ret += g[i][w]; ret += (1ll&lt;&lt;i)*(c[i][v]-c[i][w]); w = fa[i][w]; &#125; return ret;&#125; 完整如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;cstdint&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch=='-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 3e5+5, L = 21;int n, q;vector&lt;int&gt; edge[N];int fa[L][N], d[N], a[N];int64_t g[L][N], f[L][N], c[L][N]; // 由于毒瘤卡常所以小的一维在前void dfs(int x, int f)&#123; fa[0][x] = f; d[x] = d[f]+1; for(int i = 0; i &lt;= 20; ++i) c[i][x] = c[i][f]+((a[x]&gt;&gt;i&amp;1)==0); for(int i = 0; i &lt; edge[x].size(); ++i) &#123; int y = edge[x][i]; if(y == f) continue; dfs(y, x); &#125;&#125;int LCA(int x,int y)&#123; if(d[x] &lt; d[y]) swap(x, y); for(int i = 20; ~i; --i) if(d[fa[i][x]] &gt;= d[y]) x = fa[i][x]; if(x == y) return x; for(int i = 20; ~i; --i) if(fa[i][x] != fa[i][y]) x = fa[i][x], y = fa[i][y]; return fa[0][x];&#125;int64_t queryUp(int u, int tar)&#123; int w = u; int64_t ret = 0; for(int i = 20; ~i; --i) if(d[fa[i][w]] &gt;= d[tar]) &#123; ret += f[i][w]; w = fa[i][w]; ret += (1ll&lt;&lt;i)*(c[i][w]-c[i][tar]); &#125; return ret;&#125;int64_t queryDown(int v, int dis)&#123; int w = v; int64_t ret = 0; ++dis; for(int i = 0; i &lt;= 20; ++i) if(dis&gt;&gt;i&amp;1) &#123; ret += g[i][w]; ret += (1ll&lt;&lt;i)*(c[i][v]-c[i][w]); w = fa[i][w]; &#125; return ret;&#125;int main()&#123; n = read(); q = read(); for(int x = 1; x &lt;= n; ++x) f[0][x] = g[0][x] = a[x] = read(); for(int i = 1; i &lt; n; ++i) &#123; int x = read(), y = read(); edge[x].push_back(y); edge[y].push_back(x); &#125; dfs(1, 0); for(int i = 1; i &lt;= 20; ++i) for(int x = 1; x &lt;= n; ++x) &#123; fa[i][x] = fa[i-1][fa[i-1][x]]; f[i][x] = f[i-1][x]+f[i-1][fa[i-1][x]]+(1ll&lt;&lt;(i-1))*(c[i-1][fa[i-1][x]]-c[i-1][fa[i][x]]); g[i][x] = g[i-1][x]+g[i-1][fa[i-1][x]]+(1ll&lt;&lt;(i-1))*(c[i-1][x]-c[i-1][fa[i-1][x]]); &#125; while(q--) &#123; int u = read(), v = read(); int uv = LCA(u, v); printf("%lld\n", queryUp(u, fa[0][uv])+queryDown(v, d[u]+d[v]-2*d[uv])-queryDown(uv, d[u]-d[uv])); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
        <tag>概率期望</tag>
        <tag>倍增</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[永远学不会的Miller–Rabin和Pollard-Rho算法]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%B0%B8%E8%BF%9C%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84Miller%E2%80%93Rabin%E5%92%8CPollard-Rho%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下文未特殊说明则使用 $p$ 代表素数, $n$ 代表自然数 Miller-Rabin素性检验前置知识费马小定理费马小定理的一般表述为 $$\begin{aligned}a^{p-1}\ \equiv\ 1\ (\ mod\ p\ ),\ \forall\ a \in \mathbb{N},\ (a,\ p)\ =\ 1\end{aligned}$$然而遗憾的是费马小定理的逆命题并不成立，也就是 $$\begin{aligned}a^{n-1}\ \equiv\ 1\ (\ mod\ n\ ),\ \exists\ a \in \mathbb{N},\ \,(a,\ p)\ =\ 1 \nRightarrow n \in\ P\end{aligned}$$ 尤其是对于一类强伪素数 $Carmichael$ 数 恰好能满足能满足费马小定理，例如 $561$ 因此，仅使用费马小定理逆命题进行素性检验喜闻乐见的失败了 然而幸运的是，费马小定理存在逆否定理，我们可以据此给素性判定提供证据 二次探测再用费马小定理进行素性检验失败后，我们注意到一个十分有趣的引理 $$\begin{aligned}\forall p,\ x^2\ \equiv\ 1\ (\ mod\ p)\ \Rightarrow x_1\ =\ -1,\ x_2\ =\ 1\end{aligned}$$ 我们把 $-1,\ 1$ 称作 $1\ mod\ p$ 的平凡平方根 并且，对于 $p$ 而言不存在非凡平凡根 下面给出一个简短的证明 设 $1\ mod\ p$ 存在非凡平方根 $x$ 满足 $x\ \ne 1,\ x\ \ne\ -1$ $\because\ x^2\ \equiv\ 1\ (\ mod\ p)\ \therefore\ (x-1)(x+1)\ \equiv\ 0\ (\ mod\ p)$ $\because(x-1)\perp(x+1)\ \therefore\ p\ |\ (x-1)$ 或 $p\ |\ (x+1)$ 与假设矛盾，所以不成立 我们就可以提供另一类强伪证 算法内容具体来说，我们对 $n$ 进行素性检测时 若 $n$ 为偶数，则可以直接提供证据 若 $n$ 为奇数，则有 $n-1\ =\ 2^tr$ 我们设 $x_k\ =\ x^{2^kt}$ 则有 $x_k\ =\ x_{k-1}^2$ 根据上述引理当 $x_k\ \equiv\ 1\ (\ mod\ n)$ 我们只需验证 $x_{k-1}$ 是否为 $1$ 或 $-1$ 就可以提供证据 同时，通过最后的 $x^{n-1}\ mod\ p$ 的值使用费马小定理的逆否定理再此提供证据 也就是说我们选择足够多的 $x$ 就可以通过这些强伪证得出 $n$ 时否为质数的结论 假设 $k$ 为试验次数，出错概率 $P\ =\ 4^{-k}$ 而事实上，对于算法竞赛的常见数据范围，我们可以通过一些特定的 $x$ 判断，如图 一般来说，前 $12$ 个质数即可 P3383 [模板]线性筛素数素性检测虽然这是线筛的板子，但是 $Miller-Robin$ 素性检验明显由于线筛 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int p[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;; // 前12个质数即可int qpow(int a, int b, int n)&#123; int ret = 1; for( ; b; b &gt;&gt;= 1, a = 1ll*a*a%n) if(b&amp;1) ret = 1ll*ret*a%n; return ret;&#125;bool miller_rabin(int64 n)&#123; if(n == 1) return false; for(int i = 0; i &lt; 12; ++i) if(n%p[i] == 0) return n == p[i]; // 整除直接判断 int64 r, x, y; int t; for(r = n-1, t = 0; ~r&amp;1; r &gt;&gt;= 1, ++t); // n = r*2^t for(int i = 0; i &lt; 12; ++i) &#123; x = qpow(p[i], r, n); for(int j = 1; j &lt;= t; ++j) // 二次探测 &#123; y = 1ll*x*x%n; if(y == 1&amp;&amp;x != n-1&amp;&amp;x != 1) return false; // 确定一定为合数 x = y; &#125; if(x != 1) return false; // 费马小定理逆否定理确定为合数 &#125; return true; // 通过这些强伪证证明是素数&#125;int t, n;int main()&#123; n = read(); t = read(); while(t--) &#123; n = read(); if(miller_rabin(n)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; Pollard-Rho算法前置知识生日悖论在一个房间里需要有 $23$ 人使两个人生日相同的概率超过 $50\%$ 在一个房间里需要有 $64$ 使人两个人生日相同的概率接近 $1$ 所以，这种组合随机抽样的方式有很高的概率出现相同 由于这个问题与常识不相同，所以被叫做生日悖论 Floyd判圈算法假设序列 ${x_k}$ 再 $x_u$ 之后出现长度为 $v$ 的循环，既满足 $x_{u+v}\ =\ x_u$，考虑龟兔赛跑的过程，我们让一个指针走的快，另一个指针走的慢，最后一定会的相遇而此时周期即为时间 $t$ 算法演示 算法内容考虑 $n\ =\ ab$ 其中 $a,\ b$ 是 $n$ 的非平凡因子，即 $a,\ b\ \ne\ 1,\ n$ 且 $a,\ b\ |\ n$ 我们如果单纯随机 $a$ 是不可能的 我们注意到如果 $x-y\ |\ a$ 和 $x-y\ \nmid n$ 那么 $a\ =\ (x-y,\ n)$ 所以，我们可以随机选择不相等的 $x$ 和 $y$ 的算出 $a$ 而且我们只需随机 $O(n^{\frac{1}{4}})$ 组即可关键是如何选出不相等的和如何储存大量随机数 考虑模 $n$ 意义下随机多项式 $g(x)\ \equiv\ x^2+c\ (mod\ n)$ 生成伪随机数列 ${x_k}$ 但由于 ${x_k}$ 是 $n$ 的剩余系，所以是有限的 因此根据生日悖论 $O(\sqrt{n})$ 的期望下我们可以找到一个相同的 $x$ 和 $y$ 之后出现周期，实现即使用 $Floyd$ 判圈算法，而在出现环前我们有极大可能找到了非平凡因子，否则就更换参数 $c$ 重新寻找 这个过程就像走希腊字母 $\rho$ 路径因此得名 P4718 [模板]Pollard-Rho算法Pollar-Rho板子题 按照上述口胡 我们大致写出程序主体，但事实上发现喜闻乐见的 $TLE$ 了 1234567891011121314151617181920212223uint64 func(uint64 x, uint64 c, uint64 n) &#123; return ((int128)x*x%n+c)%n; &#125;uint64 find(uint64 n)&#123; for(int i = 0; i &lt; 12; ++i) if(n%p[i] == 0) return p[i]; // 用12个质数判一下，小数据不能达到期望 int s = 0, c = rand(); uint64 x, y; x = y = func(rand(), c, n); do &#123; uint64 d = gcd((x-y+n)%n, n); // 验证是否为非平凡因子 if(d != 1&amp;&amp;d != n) return d; x = func(x, c, n); y = func(func(y, c, n), c, n); ++s; // floyd 判圈 &#125; while(x != y&amp;&amp;s &lt;= S); return 0;&#125;void pollar_rho(uint64 n, uint64 &amp;mfact)&#123; if(n &lt;= mfact) return; while(~n&amp;1) n &gt;&gt;= 1, mfact = max(mfact, (uint64)2); if(n == 1||miller_robin(n)) return void(mfact = max(mfact, n)); uint64 d = find(n); for( ; !d; d = find(n)); d = max(d, n/d); // 继续分解 pollar_rho(d, mfact); pollar_rho(n/d, mfact); &#125; 以下是我也看不懂，但感觉很有道理的优化 $TLE$ 的瓶颈在于 $gcd$ 的多次计算 考虑 $gcd(ac,\ b) = gcd(a, b)$，我们可以把多个 $gcd$ 一起计算 同时使用倍增的思想依次增大样本集合，每次选择组大小一定的 $x, y$ 一起计算 目的是达到不再环上停留同时优化 $gcd$ 至于组的大小，$wiki$ 上是 $100$，$zzt$ 是 $512$，也有人是 $127$ 1234567891011121314151617uint64 find(uint64 n)&#123; for(int i = 0; i &lt; 12; ++i) if(n%p[i] == 0) return p[i]; int c = rand(); uint64 y = rand(), x = y, z, g; for(int s = 1; ; s &lt;&lt;= 1, x = y) &#123; for(int k = 1; k &lt;= s; k += S) // 一组一组的算 &#123; int t = min(S, s-k); g = 1, z = y; for(int i = 1; i &lt;= t; ++i) y = f(y), g = (int128)g*(y-x+n)%n; g = gcd(g, n); if(g == 1) continue; if(g == n) for(g = 1, y = z; g == 1; ) y = f(y), g = gcd(y-x+n, n); // 若最大公约数不为 1 则出现了 大于 1的因子 return g; &#125; &#125;&#125; 完整代码 数据类型转换过于毒瘤 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define f(x) ((int128)x*x+c)%nusing namespace std;typedef unsigned long long uint64;typedef __int128 int128;inline uint64 read(int f = 1, uint64 x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int p[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;, S = 127;uint64 qpow(uint64 a, uint64 b, uint64 n)&#123; uint64 ret = 1; for( ; b; b &gt;&gt;= 1, a = (int128)a*a%n) if(b&amp;1) ret = (int128)ret*a%n; return ret;&#125;uint64 gcd(uint64 a, uint64 b) &#123; return b?gcd(b, a%b):a; &#125;bool miller_robin(uint64 n)&#123; if(n == 1) return false; for(int i = 0; i &lt; 12; ++i) if(n%p[i] == 0) return n == p[i]; uint64 r; int t; for(r = n-1, t = 0; ~r&amp;1; r &gt;&gt;= 1, ++t); for(int i = 0; i &lt; 12; ++i) &#123; uint64 x = qpow(p[i], r, n), xs; for(int j = 1; j &lt;= t; ++j) &#123; xs = (int128)x*x%n; if(xs == 1&amp;&amp;x != 1&amp;&amp;x != n-1) return false; x = xs; &#125; if(x != 1) return false; &#125; return true;&#125;uint64 find(uint64 n)&#123; for(int i = 0; i &lt; 12; ++i) if(n%p[i] == 0) return p[i]; int c = rand(); uint64 y = rand(), x = y, z, g; for(int s = 1; ; s &lt;&lt;= 1, x = y) &#123; for(int i = 1; i &lt;= s; ++i) y = f(y); for(int k = 1; k &lt;= s; k += S) &#123; int t = min(S, s-k); g = 1, z = y; for(int i = 1; i &lt;= t; ++i) y = f(y), g = (int128)g*(y-x+n)%n; g = gcd(g, n); if(g == 1) continue; if(g == n) for(g = 1, y = z; g == 1; ) y = f(y), g = gcd(y-x+n, n); return g; &#125; &#125;&#125;void pollard_rho(uint64 n, uint64 &amp;mfact)&#123; if(n &lt;= mfact) return; while(~n&amp;1) n &gt;&gt;= 1, mfact = max(mfact, (uint64)2); if(n == 1||miller_robin(n)) return void(mfact = max(mfact, n)); uint64 d = find(n); for( ; d == n; d = find(n)); d = max(d, n/d); pollar_rho(d, mfact); pollar_rho(n/d, mfact); &#125;int t;int main()&#123; srand(19260817); t = read(); while(t--) &#123; uint64 n = read(), m = 0; if(miller_robin(n)) puts("Prime"); else pollar_rho(n, m), printf("%llu\n", m); &#125; return 0;&#125; 特别感谢 wikipedia visualgo whzzt LinearOD 资料来源 Pollard Rho 算法简介 Pollard-Rho algorithm Birthday problem Pollard’s Rho Algorithm Miller-Rabin primality test]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>素数相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[60509102 NOIP模拟题]]></title>
    <url>%2F2019%2F05%2F06%2F60509102-NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ZYB和售货机题面描述基环内向树森林，每个点有一个容量和权值，每次可以选择一个容量不为 $0$ 的点把它的出点容量减少，答案增加减少量乘点权，最大化收益 题解由题意知，$(i,\ f_i)$ 构成的边集和所给点集构成了基环内向树森林 基环内向树即使有且仅有一个有向环，且所有点出度为 $1$ 的树形图 稍加思考我们可以发现对于每一个非叶节点的容量都可以通过找连向它的点权最大值来配对直到容量变为 $1$ 并且通过每个节点找连向它的节点的最大值这样的构造使树形图分割成若干个有向链和不超过 $1$ 个的有向环 并且在这种构造下，每个点的入度和出度都不超过 $1$ 所以一定不相交 而且如果存在环，一定是基环树的环 像这样 或这样 对于链而言，我们从出度为 $0$ 的点一直选下去就是合法的 对于环而言，我们必须断掉一个环边换成树边，所以我们必须找到一个最大值和次大值差最小的点 断环加边不会出现新的环，因为基环树只有一个环 对于上一张图，需要这样断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x; &#125;const int N = 1e5+5, INF = 0x3f3f3f3f;int n, f[N], c[N], d[N], a[N];int col[N], w[N], fm[N], sm[N], mind;int64 ans;void dfs(int x, int p)&#123; if(col[x] == p) &#123; ans -= mind; return; &#125; else if(col[x]) return; // 是之前遍历到的链 col[x] = p; if(!fm[x]) return; ans += 1ll*w[fm[x]]*a[x]; mind = min(mind, w[fm[x]]-w[sm[x]]); if(fm[x] != x) dfs(fm[x], p);&#125;int main()&#123; freopen("goods.in", "r", stdin); freopen("goods.out", "w", stdout); n = read(); for(int x = 1; x &lt;= n; ++x) f[x] = read(), c[x] = read(), d[x] = read(), a[x] = read(); for(int x = 1; x &lt;= n; ++x) &#123; w[x] = d[f[x]]-c[x]; if(w[x] &gt; w[fm[f[x]]]) sm[f[x]] = fm[f[x]], fm[f[x]] = x; else if(w[x] &gt; w[sm[f[x]]]) sm[f[x]] = x; &#125; for(int x = 1; x &lt;= n; ++x) if(!col[x]) mind = INF, dfs(x, x); // 如果x在环上则一定遍历了环的所有部分，而链有可能只有一部分 printf("%lld\n", ans); return 0;&#125; ZYB玩字符串 给定字符串并已知该字符串是由若干个原串按顺序离散后重组成的，求出长度最小且字典序最小原串 我们考虑判断一个串是否合法的过程，发现如果按从左向右的顺序依次考虑则对于 $[l,\ r]$ 来说以合法地删去若干原串 $p$ 后剩下的部分一定是 $p$ 的前缀 考虑状态 $f_{l,r}$ 表示 $[l,\ r]$ 合法地删去若干原串后是否为 $p$ 的前缀，并且当 $l_p|r-l+1$ 时 $[l,\ r]$ 恰好被 $p$ 删完 所以考虑 $f_{l,r}$ 如何转移出去 首先可以在 $f_{l,r}$ 后匹配当前前缀的下一个字符 $$\begin{aligned}f_{l,r+1}\ =\ f_{l,r}\ \&amp;\ [\ s[r+1]\ ==\ p[(r-l+1)\ mod\ l_p+1]\ ]\end{aligned}$$ 其次可以在 $f_{l,r}$ 后加上一个合法的恰好被完全删完的区间 $$\begin{aligned}f_{l,r+k\times l_p}\ =\ f_{l,r}\ \&amp;\ f_{r+1,r+k\times l_p}\end{aligned}$$ 我们把刷表改成填表差不多就是一个常规的区间 $DP$ 了 注意微小的剪枝即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 2e2+5;int t, n;string s, p;vector&lt;string&gt; ans;int f[N][N];int c[N];bool dfs(int l, int r, int lp)&#123; if(~f[l][r]) return f[l][r]; if(l == r) return f[l][r] = p[1] == s[l]; for(int k = 1; l &lt;= r-k*lp; ++k) if(dfs(l, r-k*lp, lp)&amp;&amp;dfs(r-k*lp+1, r, lp)) return f[l][r] = 1; if(s[r] == p[(r-l)%lp+1]) return f[l][r] = dfs(l, r-1, lp); else return f[l][r] = 0; &#125;bool valid(int lp)&#123; memset(f, -1, sizeof(f)); for(int i = 'a'; i &lt;= 'z'; ++i) c[i] = 0; for(int i = 1; i &lt;= lp; ++i) ++c[p[i]]; for(int i = 1; i &lt;= n; ++i) if(!c[s[i]]) return false; return dfs(1, n, lp);&#125;int main()&#123; freopen("string.in", "r", stdin); freopen("string.out", "w", stdout); cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;s; n = s.length(); s = ' '+s; ans.clear(); for(int lp = 1; lp &lt;= n&amp;&amp;ans.empty(); ++lp) &#123; if(n%lp) continue; for(int i = 1; i &lt;= n-lp+1; ++i) &#123; p = s.substr(i, lp); p = ' '+p; if(valid(lp)) ans.push_back(s.substr(i, lp)); &#125; &#125; sort(ans.begin(), ans.end()); cout&lt;&lt;ans[0]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2017]异或和]]></title>
    <url>%2F2019%2F05%2F06%2FTJOI2017-%E5%BC%82%E6%88%96%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题面描述连续和的异或值。 题解题目实际要求出 $$\begin{aligned}ans\ =\ \oplus \sum_{i=1}^n\sum_{j=0}^{i-1}sum_i-sum_j\end{aligned}$$ 然后，我看了一下二进制加法器后直接弃疗实际上，几乎所有二进制题都是按位考虑的 我们把它改写成按位考虑的形式 $$\begin{aligned}ans = \sum_{k=0}^{2^k\le sum_n} ( \sum_{i=1}^n\sum_{j=0}^{i-1}(sum_i-sum_j)&gt;&gt;k\&amp; 1\ (mod 2) )&lt;&lt;k\end{aligned}$$ 按位考虑后实际上就是对于 $sum_i$ 而言， 前面有多少 $sum_j$ 与 $sum_i$ 差在 $k$ 为 $1$ 当 $sum_i$ 这一位为 $1$ 则差仍为此的情况必定为 $sum_j$ 这一位为 $0$ 且之前没有借位 另一种情况恰好相反 所以问题在于是否借位，考虑竖式计算的过程，发现 当且仅当 $sum_i \&amp;(2^k-1)\ \ge\ sum_j\&amp;(2^k-1)$ 不会借位 用权值树状数组维护一下就好了 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;typedef long long int64;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 2e6+5;int n, m, sum[N];struct Fenwick&#123; int64 c[N]; void clear() &#123; memset(c, 0, sizeof(c)); &#125; void add(int x) &#123; ++x; for( ; x &lt;= m+1; x += x&amp;-x) ++c[x]; &#125; int64 ask(int x) &#123; int ret = 0 ; ++x; for( ; x; x -= x&amp;-x) ret += c[x]; return ret; &#125; int64 query(int l, int r) &#123; return ask(r)-ask(l-1); &#125; &#125;t[2];int ans;int main()&#123; n = read(); for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i-1]+read(); for(int k = 0; (1&lt;&lt;k) &lt;= sum[n]; ++k) &#123; m = (1&lt;&lt;k)-1; int64 p = 0; t[0].clear(); t[1].clear(); for(int i = 0; i &lt;= n; ++i) &#123; int c = (sum[i]&gt;&gt;k&amp;1), d = (sum[i]&amp;m); p += t[c^1].query(0, d)+t[c^0].query(d+1, m); t[c].add(d); &#125; ans += (1&lt;&lt;k)*(p%2); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>进制</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HEOI2013]SAO]]></title>
    <url>%2F2019%2F05%2F05%2FHEOI2013-SAO%2F</url>
    <content type="text"><![CDATA[题面描述树形图拓扑排序计数 题解论用一种错误的顺序做三倍经验是一种怎样的体验DAG 的拓扑排序计数一般是用 状压DP 解决的 但由于这道题树形图的特殊性质，我们可以考虑 树形DP 设 $f_x$ 表示以 $x$ 为根的子树拓扑排序的个数 考虑 $f_x$ 如何由 $f_y$ , $y\in son_x$ 推出 发现目前状态不足以表示状态，我们需要知道拓扑排序的大致形态 注意到 $x$ 的取值只受 $y$ 的取值的影响，所以就有 设 $f_{x,n}$ 表示以 $x$ 为根的子树 $x$ 排名为 $n$ 的拓扑排序个数 以此设计转移 当 $y$ 在 $x$ 前面时 考虑把 $y$ 中有 $j$ 在排名已为$i$ 的 $x$ 之前，我们枚举 $y$ 的不超过 $j$ 的排名就有 $$\begin{aligned}f_{x,i+j-1}\ =\ \sum_{k=1}^j\binom{i+j-1}{i-1} \binom{size_x+size_y-i-j}{size_y-j}f_{x,i}\ f_{y,k}\end{aligned}$$ 当 $y$ 在 $x$ 后面时 考虑把 $y$ 中有 $j$ 在排名已为$i$ 的 $x$ 之前，我们枚举 $y$ 的超过 $j$ 的排名就有 $$\begin{aligned}f_{x,i+j-1}\ =\ \sum_{k=j+1}^{size_y}\binom{i+j-1}{i-1} \binom{size_x+size_y-i-j}{size_y-j}f_{x,i}\ f_{y,k}\end{aligned}$$ 当我们把交换和式后发现只需要维护前缀和和后缀和即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#define int unsigned long longusing namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 1000+5, P = 1e9+7;int t, n, c[N][N];vector&lt;pair&lt;int, int&gt; &gt; edge[N];int f[N][N], size[N], g[N];int pre[N][N], suf[N][N];int C(int n, int m) &#123; return n&lt;m?0:c[n][m]; &#125;void dfs(int x, int fa)&#123; size[x] = f[x][1] = 1; for(int i = 0; i &lt; edge[x].size(); ++i) &#123; int y = edge[x][i].first, z = edge[x][i].second; if(y == fa) continue; dfs(y, x); memset(g, 0, sizeof(g)); if(z) // y 在 x 前面 &#123; for(int i = 1; i &lt;= size[x]; ++i) for(int j = 1; j &lt;= size[y]; ++j) // 枚举有多少个在x前面 g[i+j] = (g[i+j]+f[x][i]*pre[y][j]%P*C(i+j-1, i-1)%P*C(size[x]+size[y]-i-j, size[x]-i)%P)%P; &#125; else // y 在 x 后面 &#123; for(int i = 1; i &lt;= size[x]; ++i) for(int j = 0; j &lt;= size[y]; ++j) // 枚举有多少个在x前面 g[i+j] = (g[i+j]+f[x][i]*suf[y][j+1]%P*C(i+j-1, i-1)%P*C(size[x]+size[y]-i-j, size[x]-i)%P)%P; &#125; memcpy(f[x], g, sizeof(f[x])); size[x] += size[y]; &#125; for(int i = 1; i &lt;= size[x]; ++i) pre[x][i] = (pre[x][i-1]+f[x][i])%P; for(int i = size[x]; i; --i) suf[x][i] = (suf[x][i+1]+f[x][i])%P; &#125; int ans;signed main()&#123; t = read(); for(int i = 0; i &lt; N; ++i) c[i][0] = 1; for(int i = 1; i &lt; N; ++i) for(int j = 1; j &lt;= i; ++j) c[i][j] = (c[i-1][j]+c[i-1][j-1])%P; while(t--) &#123; n = read(); for(int x = 1; x &lt;= n; ++x) edge[x].clear(); memset(pre, 0, sizeof(pre)); memset(suf, 0, sizeof(suf)); for(int i = 1; i &lt; n; ++i) &#123; int x, y, z; char op[7]; scanf("%llu%s%llu", &amp;x, op, &amp;y); z = op[0] == '&lt;'; ++x; ++y; edge[x].push_back(make_pair(y, z)); edge[y].push_back(make_pair(x, z^1)); &#125; dfs(1, 0); ans = 0; for(int i = 1; i &lt;= n; ++i) ans = (ans+f[1][i])%P; printf("%llu\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CQOI2017]老C的方块]]></title>
    <url>%2F2019%2F05%2F05%2FCQOI2017-%E8%80%81C%E7%9A%84%E6%96%B9%E5%9D%97%2F</url>
    <content type="text"><![CDATA[题面描述在棋盘内破坏指定联通块的最小代价 题解观察联通块，我们发现可以一个需要破坏的联通块是以蓝线为中心的八联通块，其中蓝线两边必须有2个方块，除此之外，蓝线两边至少要有1个方块 其次，我们知道破坏棋盘问题网络流一般是黑白染色 但是这道题无法黑白染色，因为无法体现蓝线的性质，所以我们采取如下的染色 我们发现这样染色可以很好体现刚才分析的性质 蓝线恰好位于红蓝两色之前，除了红蓝两色以外，两边各有3个不同颜色的块 我们考虑建模表示破坏联通块的方法 断掉联通块后不连通，实际上就是就是求最小割 破坏的最小代价就是三绿，三黄，红，蓝最小值 网络流中并联表示或，串联表示与 因此采用如下建图 源点并联黄点 容量为黄点权值 绿点并联汇点 容量为绿点权值 黄点连红点 蓝点连绿点 容量为INF 红点连蓝点 容量为红蓝最小值 至于染色判断，找规律即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;inline int read(int f = 1, int x = 0, char ch = ' ')&#123; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) x = x*10+ch-'0', ch = getchar(); return f*x;&#125;const int N = 6e6+5, INF = 0x3f3f3f3f;const int dx[4] = &#123;1, -1, 0, 0&#125;;const int dy[4] = &#123;0, 0, 1, -1&#125;;struct Edge&#123; int next, to, w; Edge(int next = 0, int to = 0, int w = 0): next(next), to(to), w(w) &#123;&#125;;&#125;edge[N];int tot = 1, head[N], s, t, n, m;void _add(int x, int y, int z) &#123; edge[++tot] = Edge(head[x], y, z); head[x] = tot; &#125;void add(int x, int y, int z) &#123; _add(x, y, z); _add(y, x, 0); &#125;int d[N];bool bfs()&#123; memset(d, 0, sizeof(d)); queue&lt;int&gt; q; q.push(s); d[s] = 1; while(q.size()) &#123; int x = q.front(); q.pop(); for(int i = head[x]; i; i = edge[i].next) &#123; int y = edge[i].to, z = edge[i].w; if(!z||d[y]) continue; d[y] = d[x]+1; q.push(y); if(y == t) return true; &#125; &#125; return false;&#125;int dinic(int x, int flow)&#123; if(x == t) return flow; int rest = flow, k; for(int i = head[x]; i&amp;&amp;rest; i = edge[i].next) &#123; int y = edge[i].to, z = edge[i].w; if(!z||d[y] != d[x]+1) continue; k = dinic(y, min(z, rest)); edge[i].w -= k; edge[i^1].w += k; rest -= k; if(!k) d[y] = 0; &#125; return flow-rest;&#125;map&lt;pair&lt;int, int&gt; , int&gt; h;int r, c, col[N], px[N], py[N], w[N]; /*x%4 == 1&amp;&amp;y%2 == 1 = red x%4 == 0&amp;&amp;y%2 == 0 = red x%4 == 1&amp;&amp;y%2 == 0 = yellow x%4 == 0&amp;&amp;y%2 == 1 = yellowx%4 == 2&amp;&amp;y%2 == 1 = blue x%4 == 3&amp;&amp;y%2 == 0 = bluex%4 == 2&amp;&amp;y%2 == 0 = green x%4 == 3&amp;&amp;y%2 == 1 = green蓝线恰好在红块与蓝块之间源点并联黄点 绿点并联汇点黄点连红点 蓝点连绿点 红点连蓝点*/void addpurple(int x)&#123; int _x = px[x], _y = py[x]; for(int i = 0; i &lt; 2; ++i) &#123; int nx = _x+dx[i], ny = _y; if(!h.count(make_pair(nx, ny))) continue; int y = h[make_pair(nx, ny)]; if(col[y] == 3) add(x, y, min(w[x], w[y])); &#125;&#125;void addyellow(int x)&#123; int _x = px[x], _y = py[x]; add(s, x, w[x]); for(int i = 0; i &lt; 4; ++i) &#123; int nx = _x+dx[i], ny = _y+dy[i]; if(!h.count(make_pair(nx, ny))) continue; int y = h[make_pair(nx, ny)]; if(col[y] == 1) add(x, y, INF); &#125; &#125;void addgreen(int x)&#123; int _x = px[x], _y = py[x]; add(x, t, w[x]); for(int i = 0; i &lt; 4; ++i) &#123; int nx = _x+dx[i], ny = _y+dy[i]; if(!h.count(make_pair(nx, ny))) continue; int y = h[make_pair(nx, ny)]; if(col[y] == 3) add(y, x, INF); &#125;&#125;int maxflow, flow;int main()&#123; c = read(), r = read(), n = read(); s = n+1; t = n+2; for(int i = 1; i &lt;= n; ++i) &#123; px[i] = read(), py[i] = read(), w[i] = read(); h[make_pair(px[i], py[i])] = i; &#125; for(int i = 1; i &lt;= n; ++i) &#123; int x = px[i], y = py[i]; if((x%4 == 1&amp;&amp;y%2 == 1)||(x%4 == 0&amp;&amp;y%2 == 0)) col[i] = 1; if((x%4 == 1&amp;&amp;y%2 == 0)||(x%4 == 0&amp;&amp;y%2 == 1)) col[i] = 2; if((x%4 == 2&amp;&amp;y%2 == 1)||(x%4 == 3&amp;&amp;y%2 == 0)) col[i] = 3; if((x%4 == 2&amp;&amp;y%2 == 0)||(x%4 == 3&amp;&amp;y%2 == 1)) col[i] = 4; &#125; for(int x = 1; x &lt;= n; ++x) &#123; if(col[x] == 1) addpurple(x); else if(col[x] == 2) addyellow(x); else if(col[x] == 4) addgreen(x); &#125; while(bfs()) while(flow = dinic(s, INF)) maxflow += flow; printf("%d\n", maxflow); return 0;&#125; 图片来源 特别感谢 shadowice1984]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一直学不会的莫比乌斯反演]]></title>
    <url>%2F2019%2F03%2F05%2F%E4%B8%80%E7%9B%B4%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[本文会出现大量口胡，请见谅 莫比乌斯函数设 $x\in N$ 唯一分解后为 $x\ =\ p_1^{c_1}p_2^{c_2}p_3^{c_3}\cdots p_n^{c_n}$ 我们定义莫比乌斯函数 $$ \mu(x)\ = \\begin{cases}0&amp;\exists\ c_i &gt; 1\\-1&amp;n\ \equiv\ 1\ (\ mod\ 2\ )\\1&amp;n\ \equiv\ 0\ (\mod\ 2\ )\end{cases}$$通过观察定义，稍有常识的人 除了我 都能看出这是个积性函数，并且我们对莫比乌斯函数分析也通常是对唯一分解后的素数集合进行分析，这也是分析一般积性函数的一般方法 通过 口胡 打表 正经分析 得出对于莫比乌斯函数的积性函数的递推式 $$ \mu(np)\ = \\begin{cases}0&amp;\ n \perp p\\-\mu(n)&amp;\ n \not\perp p\end{cases}$$ 那么，欧拉筛莫比乌斯函数有如下操作 1234567891011121314void sieve(int d)&#123; mo[1] = 1; for(int i = 2; i &lt;= d; ++i) &#123; if(!vis[i]) p[++tp] = i, mo[i] = -1; for(int j = 1; j &lt;= tp&amp;&amp;i*p[j] &gt; d; ++j) &#123; vis[i*p[j]] = 1; if(i%p[j] == 0) mo[i*p[j]] = 0, j += tp; else mo[i*p[j]] = -mo[i]; &#125; &#125;&#125; 莫比乌斯反演蒟蒻一直学的是的假莫反 莫比乌斯反演通常表现为 $$\begin{aligned}&amp;g(x)\ =\ \sum_{d|x}f(d)\\&amp;f(x)\ =\ \sum_{d|x}\mu(\frac{x}{d})g(d)\end{aligned}$$ 或 $$\begin{aligned}&amp;g(x)\ =\ \sum_{x|d}^{n}f(d)\\&amp;f(x)\ =\ \sum_{x|d}^{n}\mu(\frac{d}{x})g(d)\end{aligned}$$ 可是蒟蒻都不会用 所以一直使用莫比乌斯函数，而是使用这一个性质 $$\begin{aligned}[\ x = 1\ ]\ =\ \sum_{d|x}\mu(d)\end{aligned}$$ 下面给出这个性质的证明 我们考虑在只有枚举 $d$ 满足 $d\ =\ p_1^{c_1}p_2^{c_2}p_3^{c_3}\cdots p_n^{c_n},\ \forall c &lt; 2$ 时才会对答案产生贡献 所以有 $$\begin{aligned}\sum_{d|x}\mu(d)\ =\ \sum_{i\ =\ 0}^n(-1)^{i+1}\tbinom{i}{n}\end{aligned}$$ 则有 $$\sum_{d|x}\mu(d)\ =\\begin{cases}1&amp;n\ =\ 1\\0&amp;n\ \neq\ 1\\end{cases}=\ [x\ =\ 1]$$ 例题例题中的 n 均小于 m，p是质数集合任意一个元素 暂无裸题$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\ j)\ =\ 1]\end{aligned}$$ 根据性质$\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\ j)\ =\ 1] \ =\ \sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,\ j)}\mu(d)$把 $d|gcd(i,\ j)$ 拆开$\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,\ j)} =\ \sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,\ d|j}\mu(d)$更改枚举形式，把条件写在和式右端，并根据条件扩大枚举范围$\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i,\ d|j}\mu(d)\ =\ \sum_{i=1}^n\sum_{j=1}^m\sum_{d=1}^n\mu(d)[d|i][d|j]$交换和式$\sum_{i=1}^n\sum_{j=1}^m\sum_{d=1}^n\mu(d)[d|i][d|j]\ =\ \sum_{d=1}^n\mu(d)\sum_{i=1}^n[d|i]\sum_{j=1}^m[d|j]$发现实际上为枚举约数个数$\sum_{d=1}^n\mu(d)\sum_{i=1}^n[d|i]\sum_{j=1}^m[d|j]\ =\ \sum_{d=1}^n\mu(d)\lfloor \frac{n}{d}\rfloor \lfloor \frac{m}{d}\rfloor$ P2522 [HAOI2011]Problem b$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\ j)\ =\ k]\end{aligned}$$ 我们把所有满足条件的 $gcd(i,\ j)$ 剔除约数 $k$ 实际上相当于求$$\begin{aligned}\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}[gcd(i,\ j)\ =\ 1]\end{aligned}$$所以$$\begin{aligned}\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}[gcd(i,\ j)\ =\ 1] =\ \sum_{d=1}^{\lfloor \frac{n}{k}\rfloor}\mu(d)\lfloor \frac{n}{kd}\rfloor \lfloor \frac{m}{kd}\rfloor\end{aligned}$$ 暂无裸题$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^mij[gcd(i,\ j)\ =\ k]\end{aligned}$$ 与上题一样，我们把所有满足条件的 $gcd(i,\ j)$ 剔除约数 $k$ 实际上相当于求$$\begin{aligned}\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}ij[gcd(i,\ j)\ =\ 1]\ k^2\end{aligned}$$注意此时虽然我们把所有数剔除 $k$ 后，依然需要累加贡献$$\begin{aligned}\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}ij[gcd(i,\ j)\ =\ 1]\ k^2\ &amp;=\ k^2\sum_{d=1}^{\lfloor \frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}ij[d|i][d|j]\end{aligned}$$观察后面的和式，把 $d$ 提出即变成等差数列$$\begin{aligned}k^2\sum_{d=1}^{\lfloor \frac{n}{k}\rfloor}\mu(d)*d^2\sum_{i=1}^{\lfloor \frac{n}{kd}\rfloor}i\sum_{j=1}^{\lfloor \frac{m}{kd}\rfloor}j\end{aligned}$$ P1447 [NOI2010]能量采集$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^mgcd(i,\ j)\end{aligned}$$ 这道题虽然可以根据欧拉函数性质直接得出$$\begin{aligned}x \ =\ \sum_{d|x}\phi(d)\end{aligned}$$从而$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^mgcd(i,\ j)\ =\ \sum_{d=1}^n\phi(d)\lfloor \frac{n}{d}\rfloor \lfloor \frac{m}{d}\rfloor\end{aligned}$$但用莫比乌斯函数推导会更有意义一些我们枚举 $gcd(i,\ j)$ 得到$\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\ j)\ =\ d]$后面根据前文，化简为$\sum_{d=1}^nd\sum_{k=1}^{\lfloor \frac{n}{d} \rfloor}\mu(k)\lfloor \frac{n}{kd} \rfloor \lfloor \frac{m}{kd} \rfloor$设 $T = kd$ 则有$\sum_{d=1}^nd\sum_{k=1}^{\lfloor \frac{n}{d} \rfloor}\mu(k)\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor\ =\ \sum_{d=1}^nd\sum_{T=1}^n\mu(\frac{T}{d})\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T}\rfloor[d|T]\ =\ \sum_{T=1}^n\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})d$设 $F(n)\ =\ \sum_{d|n}\mu(\frac{n}{d})d$ ，并考虑在欧拉筛过程中求出下面是一个很重要的技巧，考虑加入 $p$ 对于原来的约数集合的影响则有$F(np)\ =\ \sum_{d|n}\mu(\frac{np}{d})d+\sum_{d|n}\mu(\frac{np}{dp})dp$当 $n\ \perp\ p$ 时，$\sum_{d|n}\mu(\frac{np}{d})d+\sum_{d|n}\mu(\frac{np}{dp})dp\ =\ -F(n)+pF(n)$当 $n\ \not\perp\ p$ 时，$\sum_{d|n}\mu(\frac{np}{d})d+\sum_{d|n}\mu(\frac{np}{dp})dp\ =\ pF(n)$综上，$$ F(np)\ = \\begin{cases}(p-1)F(n)&amp;\ n \perp p\\pF(n)&amp;\ n \not\perp p\\end{cases}$$我们发现这恰好是 $\phi(n)$ 的递推式，因此是正确的这样推式子是一种套路，请仔细思考 P2257 YY的GCD$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^m[\ gcd(i,\ j)\ =\ p\ ]\end{aligned}$$ 我们设有函数 $f(n)\ =\ [n\ =\ p]$则题意变为$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,\ j))\end{aligned}$$我们枚举 $gcd(i,\ j)$ 得到$\sum_{d=1}^nf(d)\sum_{i=1}^n\sum_{j=1}^m[gcd(i,\ j)\ =\ d]$后面根据前文，化简为$\sum_{d=1}^nf(d)\sum_{k=1}^{\lfloor \frac{n}{d} \rfloor}\mu(k)\lfloor \frac{n}{kd} \rfloor \lfloor \frac{m}{kd} \rfloor$设 $T = kd$ 则有$\sum_{d=1}^nf(d)\sum_{k=1}^{\lfloor \frac{n}{d} \rfloor}\mu(k)\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor =\sum_{d=1}^nf(d)\sum_{T=1}^n\mu(\frac{T}{d})\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T}\rfloor[d|T] =\sum_{T=1}^n\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})f(d)$设 $F(n)\ =\ \sum_{d|n}\mu(\frac{n}{d})f(d)$ ，并考虑在欧拉筛过程中求出考虑加入 $p$ 对于原来的约数集合的影响则有$F(np)\ =\ \sum_{d|n}\mu(\frac{np}{d})f(d)+\sum_{d|n}\mu(\frac{np}{dp})f(dp)$当 $n\ \perp\ p$ 时，$\sum_{d|n}\mu(\frac{np}{d})f(d)+\sum_{d|n}\mu(\frac{np}{dp})f(dp)\ =\ -F(n)+\mu(n)$当 $n\ \not\perp\ p$ 时，$\sum_{d|n}\mu(\frac{np}{d})f(d)+\sum_{d|n}\mu(\frac{np}{dp})f(dp)\ =\ \mu(n)$综上，$$ F(np)\ = \\begin{cases}-F(n)+\mu(n)&amp;\ n \perp p\\\mu(n)&amp;\ n \not\perp p\\end{cases}$$我们发现这道和上一道有许多复读的部分，总结一下发现如果有一道题可以表示为$$\begin{aligned}\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,\ j))\end{aligned}$$实际上就是求出$$\begin{aligned}\sum_{T=1}^n\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T}\rfloor\sum_{d|T}\mu(\frac{T}{d})f(d)\end{aligned}$$并且按照上面的技巧讨论即可 数据删除[数据删除]]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[40309102 省选模拟题]]></title>
    <url>%2F2019%2F03%2F04%2F40309102-%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[LOJ6038 [雅礼集训 2017 Day5]远行 动态维护指定节点为端点的树上最长链 树的直径的性质 树上任意节点为一段的最长链必定是直径的一个端点 若存在树多个直径则一定相交 两个联通块合并时，新的树的直径的端点必定来自于原四个端点的其中两个 那么问题即转化为动态维护树的直径 树的联通块及直径信息用并查集维护，树的联通性和简单路径用LCT维护 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int N = 300000+5;inline int read()&#123; int f = 1, x = 0; char ch; while(!isdigit(ch = getchar())) if(ch == '-') f = -1; while(isdigit(ch)) &#123; x = x*10+ch-'0'; ch = getchar(); &#125; return f*x;&#125;int n, q, type;int ch[N][2], fa[N], f[N];int val[N], rev[N];int d1[N], d2[N];void pushup(int x) &#123; if(x) val[x] = val[ch[x][0]]+val[ch[x][1]]+1; &#125;bool nroot(int x) &#123; return ch[fa[x]][0] == x || ch[fa[x]][1] == x; &#125;void pushr(int x) &#123; if(x) swap(ch[x][0], ch[x][1]), rev[x] ^= 1; &#125;void pushdown(int x) &#123; if(rev[x]) pushr(ch[x][0]), pushr(ch[x][1]), rev[x] = 0; &#125;void rotate(int x)&#123; int y = fa[x], z = fa[y], k = ch[y][1]==x, w = ch[x][!k]; ch[x][!k] = y; ch[y][k] = w; if(nroot(y)) ch[z][ch[z][1]==y] = x; fa[x] = z; fa[y] = x; if(w) fa[w] = y; pushup(y); pushup(x);&#125;void pushshall(int x)&#123; if(nroot(x)&amp;&amp;x) pushshall(fa[x]); pushdown(x);&#125;void splay(int x)&#123; pushshall(x); while(nroot(x)) &#123; int y = fa[x], z = fa[y]; if(nroot(y)) (ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;&#125;void access(int x)&#123; for(int y = 0; x; x = fa[y=x]) splay(x), ch[x][1] = y, pushup(x);&#125;void makeroot(int x) &#123; access(x); splay(x); pushr(x); &#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y); &#125;int query(int x, int y) &#123; split(x, y); return val[y]; &#125;int find(int x) &#123; return f[x] == x?x:f[x] = find(f[x]); &#125;void link(int x, int y)&#123; makeroot(x); fa[x] = y; int fx = find(x), fy = find(y); f[fx] = fy; int x1 = d1[fx], y1 = d2[fx], x2 = d1[fy], y2 = d2[fy]; int v = query(x2, y2), t = 0; t = query(x1, y1); if(t &gt; v) v = t, d1[fy] = x1, d2[fy] = y1; t = query(x1, y2); if(t &gt; v) v = t, d1[fy] = x1, d2[fy] = y2; t = query(x2, y1); if(t &gt; v) v = t, d1[fy] = x2, d2[fy] = y1; t = query(x1, x2); if(t &gt; v) v = t, d1[fy] = x1, d2[fy] = x2; t = query(y1, y2); if(t &gt; v) v = t, d1[fy] = y1, d2[fy] = y2;&#125;int ans;int main()&#123; // freopen("hike.in", "r", stdin); // freopen("hike.out", "w", stdout); type = read(); n = read(), q = read(); for(int x = 1; x &lt;= n; ++x) val[x] = 1, d1[x] = d2[x] = f[x] = x; while(q--) &#123; int op = read(), x = read()^ans, y; if(op == 1) y = read()^ans, link(x, y); else y = find(x), printf("%d\n", ans = max(query(d1[y], x), query(d2[y], x))-1); if(!type) ans = 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再也学不会的置换与群]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%86%8D%E4%B9%9F%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%BD%AE%E6%8D%A2%E4%B8%8E%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[这就是BZOJ挨个做题的下场吗 群的定义对于二元组 $(G,\ \circ )$ 其中 $G$ 是一个集合，$\circ $ 是一个二元运算，若满足以下性质，则称 $G$ 是 $\circ $ 下的群 封闭性: $\forall \ a,\ b \in G, \ a\circ b \in G$ 交换律: $\forall \ a,\ b,\ c \in G,\ a\circ b\circ c\ =\ a\circ (b\circ c)$ 单位元: $\exists \ e\ \in G,\ \forall\ a\ \in G,\ a\circ e\ =\ a$ 逆元: $\forall \ a\ \in G,\ \exists\ a^{-1}\ \in\ G,\ a\circ a^{-1} = e$ 比如，复数集合 $C$ 是二元运算 $+$ 的群，即加法群 置换群定义 $G$ 为 $S = { 1,\ 2,\ 3,\ 4,\ …\ ,\ n }$ 上双射构成的集合，并定义二元运算 $\circ$ 满足 $(f\ \circ\ g)[x] = f(g(x))$，若保证运算 $\circ$ 对于 $S$ 封闭，则称 $G$ 是运算 $\circ$ 的置换群，且这种双射称为置换，通常以这种形式表示$$\begin{bmatrix}1&amp;2&amp;3&amp;{\cdots}&amp;n\\{a_1}&amp;{a_2}&amp;{a_3}&amp;{\cdots}&amp;{a_n}\\end{bmatrix}$$ 其中置换 $$\begin{bmatrix}1&amp;2&amp;3&amp;{\cdots}&amp;n\\{1}&amp;{2}&amp;{3}&amp;{\cdots}&amp;{n}\\end{bmatrix}$$ 为 $G$ 的单位元 其中 $$\begin{bmatrix}{a_1}&amp;{a_2}&amp;{a_3}&amp;{\cdots}&amp;{a_n}\\1&amp;2&amp;3&amp;{\cdots}&amp;n\\end{bmatrix}$$ 为 $G$ 的逆元 同时，我们定义： $E_i$ 表示元素 $i$ 经过 $G$ 的诱导下可以得到的元素集合，即等价类 就是置换形成的有向图的环· $Z_i$ 表示使元素 $i$ 为不动点的置换的全体所构成的集合 Burnside 引理设 $G$ 是作用在 $S = {1,\ 2,\ 3,\ \cdots,\ n}$ 的置换群，则对于等价类 $E$ 的个数 $l$ 有 $$l\ =\ \frac{1}{|G|}\sum_{g\ \in\ G}D(g)$$ 其中 $D(x)$ 表示置换 $x$ 中的不动点的数量 证明 引理 $$\sum_{i=1}^n|Z_i| = \sum_{g\ \in\ G}D(g)$$ 自己口胡一遍就行了$\sum_{i=1}^n|Z_i|\ =\ \sum_{i=1}^n\sum_{g\ \in \ G}[i == a_i][a_i\ \in g]\ =\ \sum_{g\ \in \ G}\sum_{i=1}^n[i == a_i][a_i\ \in g]\ =\ \sum_{g\ \in \ G}D(g)$ 引理 $$\forall\ k\ \in\ S,\ |E_k||Z_k|\ =\ |G|$$ 设 $E_k\ =\ {a_1,\ a_2,\ a_3,\ \cdots,\ a_{|E_k|} },\ a_1\ =\ k$由 $E_k$ 的定义知，$\exists\ p_i\ \in\ G,\ p_i(a_1)\ =\ a_i$于是构造 $Z_kp_i\ =\ {\pi\circ p_i\ |\ \pi \in\ Z_k}$对于 $Z_kp_i$ 具有以下性质$$|Z_kp_i|\ =\ |Z_k|$$$\because \pi_1\circ p_i\ =\ \pi_2\circ p_i \rightarrow\ \pi_1\ =\ \pi_2\ \therefore\ \pi_1\ \ne\ \pi_2\ \rightarrow \pi_1\circ p_i\ \ne\ \pi_2\circ p_i$结合下一条性质感性理解$$Z_kp_i\ \cap\ Z_kp_j = \varnothing\ (i\ \ne\ j)$$$\because\ Z_kp_i(a_1)\ =\ a_i,\ Z_kp_j(a_1)\ =\ a_j\ \therefore\ p_i(a_1)\ \ne\ p_j(a_1)$$$G\ =\ Z_kp_1\ \cup\ Z_kp_2\ \cup\ Z_kp_3\ \cup\ \cdots\ \cup\ Z_kp_{|E_k|}$$首先，显然$Z_kp_1\ \cup\ Z_kp_2\ \cup\ Z_kp_3\ \cup\ \cdots\ \cup\ Z_kp_{|E_k|}\ \subseteq G$$\forall\ p\ \in\ G,\ p(a_1) = a = k\rightarrow a\ \in \ E_k$，设 $a = a_j$$\because\ p\circ p_j^{-1}(a_1)\ =\ p_j^{-1}\circ p(a_1)\ =\ a_1$$\therefore\ p\circ p_j^{-1}\ \in\ Z_k,\ p\ \in\ Z_kp_j$$\ \ \ \ G\ \subseteq\ Z_kp_1\ \cup\ Z_kp_2\ \cup\ Z_kp_3\ \cup\ \cdots\ \cup\ Z_kp_{|E_k|}$$\therefore\ G\ =\ Z_kp_1\ \cup\ Z_kp_2\ \cup\ Z_kp_3\ \cup\ \cdots\ \cup\ Z_kp_{|E_k|}$综合各项性质$|G|\ = \sum_{i=1}^{|E_k|}|Z_kp_i|\ = \sum_{i=1}^{E_k}|Z_k|\ = |E_k||Z_k|$ 综上 $\frac{1}{|G|}\sum_{g\ \in\ G}D(g)\ = \frac{1}{|G|}\sum_{i=1}^{n}|Z_i|\ = \frac{1}{|G|}\sum_{i=1}^l\sum_{j\ \in\ E_i}|Z_j|\ = \frac{1}{|G|}\sum_{i=1}^l|G|\ = l$ 例题 一正方形分成4格，2着色，求方案，其中，经过转动相同的图象算同一方案 设 $G\ =\ {a_1,\ a_2,\ a_3,\ a_4}$ 分别代表顺时针 $0^{\circ}$ ，$90^{\circ}$ ，$180^{\circ}$ ，$270^{\circ}$ 由题意得 $$a_1\ = \begin{bmatrix}1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\end{bmatrix}$$ $$a_2\ = \begin{bmatrix}1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\1&amp;2&amp;6&amp;3&amp;4&amp;5&amp;10&amp;7&amp;8&amp;9&amp;12&amp;11&amp;16&amp;13&amp;14&amp;15\\end{bmatrix}$$ $$a_3\ = \begin{bmatrix}1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\1&amp;2&amp;5&amp;6&amp;3&amp;4&amp;9&amp;10&amp;7&amp;8&amp;11&amp;12&amp;15&amp;16&amp;13&amp;14\\end{bmatrix}$$ $$a_4\ = \begin{bmatrix}1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\1&amp;2&amp;4&amp;5&amp;6&amp;3&amp;8&amp;9&amp;10&amp;7&amp;12&amp;11&amp;14&amp;15&amp;16&amp;13\\end{bmatrix}$$ 由Burnside引理得 $$l\ =\ \frac{1}{4}\times (16+2+4+2)\ =\ 6$$ Polya 定理我们考虑染色问题，$S$ 大小是指数级的，无法枚举，所以产生了Polya定理 引入循环的概念 约定一个记号 $$(a_1\ a_2\ a_3\ \cdots\ a_n)\ =\ \begin{bmatrix}{a_1}&amp;{a_2}&amp;{a_3}&amp;{\cdots}&amp;{a_n}\\{a_2}&amp;{a_3}&amp;{a_4}&amp;{\cdots}&amp;{a_1}\\end{bmatrix}$$ 循环可以理解为压缩表示的置换，对于循环内的数没有先后之分 一个十分显然的结论，一个置换可以表示成若干个不相交循环的组合 例如 $$(a_1\ a_2\ a_3)(a_4\ a_5)\ =\ \begin{bmatrix}{a_1}&amp;{a_2}&amp;{a_3}&amp;{a_4}&amp;{a_5}\\{a_2}&amp;{a_3}&amp;{a_1}&amp;{a_5}&amp;{a_4}\\end{bmatrix}$$ 设 $G$ 是作用在 $S = {1,\ 2,\ 3,\ \cdots,\ n}$ 的置换群，我们需要对 $n$ 染 $m$ 种颜色，则对于等价类 $E$ 的个数 $l$ 有 $$l\ =\ \frac{1}{|G|}\sum_{g\ \in\ G}m^{C(g)}$$ 其中 $C(x)$ 表示置换 $x$ 中的不相交循环的数量 证明对于每个循环都对应的是该置换的不动点，我们只要把循环内的数染成相同颜色即可，即 $m^{C(g)}$ 个 人类本质 一正方形分成4格，2着色，求方案，其中，经过转动相同的图象算同一方案 设 $G\ =\ {a_1,\ a_2,\ a_3,\ a_4}$ 分别代表顺时针 $0^{\circ}$ ，$90^{\circ}$ ，$180^{\circ}$ ，$270^{\circ}$ 由题意得 $$a_1\ =\ (1)(2)(3)(4)$$ $$a_2\ =\ (1\ \ \ 2\ \ \ 3\ \ \ 4)$$ $$a_3\ =\ (1\ \ \ 3)(2\ \ \ 4)$$ $$a_4\ =\ (1\ \ \ 2\ \ \ 3\ \ \ 4)$$ 由Polya定理得 $$l\ =\ \frac{1}{4}\times (2^4+2^1+2^2+2^1)\ =\ 6$$ P4980 【模板】Polya定理群论真是人类的智慧]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组十三题]]></title>
    <url>%2F2019%2F02%2F21%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8D%81%E4%B8%89%E9%A2%98%2F</url>
    <content type="text"><![CDATA[由于蒟蒻的分组导致多个字符串有个可能需要特判只有1个情况 本文也会出现大量口胡，请见谅 蒟蒻的字符串太差了(ಥ _ ಥ) 蒟蒻这辈子再也学不会了≡(▔﹏▔)≡ P2743 [USACO5.1]乐曲主题Musical Themes题面描述求不重叠的最长重复子串，其中两个字符串相等的条件变为相同位置两字符差值一定 题解首先，我们需要解决被重新定义的匹配的问题，相同位置字符差值一定，那么同一个字符串相邻差值与另一个位置的差值相等例如：$$1\quad 2\quad 3\quad 5 \\ 3\quad 4\quad 5\quad 2$$两个字符串转成差分后变为 $$1\quad 1\quad\ 2 \\ 1\quad 1\quad \text{-3}$$那么 1 2 3 与 3 4 5 相等， 就可以由 1 1 与 1 1 相等得出 即问题变为在差分数组下求原定义的相等的不重叠最大子串，需注意的是差分数组的子串长度+1才是原子串 其次，我们要知道，最大重复子串即为height数组里的最大值，这不难证明，因为重复子串必定是任意两后缀的LCP，而LCP就对应的是height数组一段连续区间的最小值，必定小于等于height的最大值 而现在题目要求不重叠，对长度k进行二分，将问题变为判定长为k的不重叠重复子串的存在问题 所以我们把height值大于等于k的归在一组，只有这样才存在至少长为k的不重叠子串，该组内sa的最大值与最小值的差若小于等于k，就存在 按height分组是常见方法，如图 实现格式较固定 123456for(int i = 1; i &lt;= n; ++i)&#123; if(height[i] &lt; k) maxv = -INF, minv = INF;// 重新更新 // 每一组内维护的信息 // 判断是否合法&#125; 因此第一道题就解决了 差分转化 123n = read();for(int i = 1; i &lt;= n; ++i) a[i] = read();for(int i = 1; i &lt;= n; ++i) s[i] = a[i]-a[i-1]+100; // 防止负数 判断二分答案合法 123456789101112bool valid(int k)&#123; int maxv = -INF, minv = INF; for(int i = 1; i &lt;= n; ++i) &#123; if(height[i] &lt; k) maxv = -INF, minv = INF; maxv = max(sa[i], maxv); minv = min(sa[i], minv); if(maxv-minv &gt; k) return true; //注意为小于k，因为这是差分数组 &#125; return false;&#125; 二分答案 12345678910int l = 0, r = n;while(l &lt;= r)&#123; int mid = (l+r)&gt;&gt;1; if(valid(mid)) l = mid+1, ans = mid; else r = mid-1;&#125;++ans;if(ans &lt; 5) ans = 0; // 按题意判断printf("%d\n", ans); P2852 [USACO06DEC]牛奶模式Milk Patterns题面描述求至少出现k次的最长重复子串 题解同样，我们发现答案具有单调性，因此问题变为在字符串中判定长度为m的重复子串是否出现k次，height分组后每一组重复子串为这些后缀的公共前缀，那么有多少个后缀就有子串就重复了多少次，若存在一组后缀个数大于k那么m是合法解 判断二分答案 12345678910bool valid(int k)&#123; int cnt = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(height[i] &lt; k) cnt = 0; if(++cnt &gt;= tot) return true; // 子串重复次数即为组的大小 &#125; return false;&#125; SP694 DISUBSTR - Distinct Substrings题面描述求本质不同的子串个数 题解每一个后缀的一段前缀就对应了一个子串，我们枚举排名i会产生n-sa[i]+1，由于本质不同，需要减去和已经枚举重复的，即实际贡献n-sa[i]+1-height[i]，注意只需要减与上一个后缀的LCP，因为更前面的实际上已包含在该LCP里了 其次，SPOJ不支持swap(x, y)，所以有些改动 不需要浪费变量名了ヾ(≧▽≦*)o 不开long long 见祖宗 累积答案 12for(int i = 1; i &lt;= n; ++i) ans += n-sa[i]+1-height[i]; URAL1297 Palindrome题面描述求一个字符串的最大回文子串 题解把正串和反串拼在一起，枚举对称轴，问题就转化为新字符串中某两个后缀的LCP，长度要用奇偶性分类讨论 查询LCP 1234567int LCP(int i, int j) // 查询位置为i和j的后缀的LCP&#123; int l = rak[i], r = rak[j]; if(l &gt; r) swap(l, r); ++l; int k = log2(r-l+1); return min(f[l][k], f[r-(1&lt;&lt;k)+1][k]); // f为喜闻乐见的ST表&#125; 合并正反两串 1234scanf("%s", s+1); len = strlen(s+1); n = 2*len+1;for(int i = 1; i &lt;= len; ++i) s[n+1-i] = s[i];s[len+1] = 1; // 放置特殊特殊节点，最好是1，其他由于数据类型的原因会有奇怪错误 这种写法较麻烦，后文有更普适的 奇偶分类讨论，画图模拟即可 123456789101112131415161718for(int i = 1; i &lt;= len; ++i)&#123; int cur = LCP(i, n+1-i); if(2*cur-1 &gt; ans) &#123; ans = 2*cur-1; pos1 = i-cur+1; pos2 = i+cur-1; &#125; if(i &lt; 2) continue; cur = LCP(i, n+2-i); if(2*cur &gt; ans) &#123; ans = 2*cur; pos1 = i-cur; pos2 = i+cur-1; &#125;&#125; UVA10298 Power Strings题面描述求循环同构串的最小循环节 题解蒟蒻连KMP都不会写了 (～﹃～)~zZ 枚举长度的约数，假设枚举值为k，即查找位置为1与位置为k+1的后缀的LCP是否为n-k即可 画图感性理解 枚举过程 12for(int k = 1; k &lt; n; ++k) if(n%k == 0 &amp;&amp; LCP(1, k+1) == n-k) ans = n/k, k = n; POJ3693 Maximum repetition substring题面描述求一个字符串的循环次数最多的循环同构子串，其次满足字典序最小 题解蒟蒻调了好久，还是网上抄的的题解 ◑﹏◐ 但是这确实是一道好题 o(￣▽￣)o 首先，这道题和上一道类似，我们可以考虑枚举循环节的长度，同时枚举每一个位置，假设当前枚举的位置为j，长度i，则计算j和i+j的LCP，那么这个循环同构子串循环为LCP/i+1，更新答案和位置即可 但是时间复杂度为O(n^2)，显然过不了，考虑优化 对于长度i的循环节，如果只枚举S(1, i), S(i+1, i*2+1) … 会发生什么，我们会漏记循环次数，但此时它一定是一个更多循环次数子串的后缀，所以我们再向前寻找i个即可，向前匹配了LCP%i个字符循环次数+1 但时间复杂度不太会算啊（；´д｀）ゞ ， 感性上，均摊和随机都比较优秀，大概是O(nlogn+k)，k是一个与n无关的常数 1234567891011for(int i = 1; i &lt;= n/2; ++i) // 枚举到n/2即可 for(int j = 1; j+i &lt;= n; j += i) &#123; if(s[j] != s[j+i]) continue; int lcp = LCP(j, j+i); int curr = lcp/i+1, exl = j-(i-lcp%i), curl = j, cnt = 0; // curr 重复次数，exl 匹配到这个位置curr+1 for(int k = j-1; k &gt; j-i&amp;&amp;k&amp;&amp;s[k] == s[i+k]; --k) // 如果不大于exl则重复次数增加，但还会继续枚举 &#123; if(exl == k) ++curr, curl = k; &#125; &#125; 接下来，我们考虑字典序最小 暴力统计，我们考虑rank数组，通过rank[i] 和 rank[j] 我们可以比较任意两个后缀的排名，而子串一定是某个后缀的前缀，对于完全不同的子串，若首字符位置不同，我们可以通过直接比较后缀即可，若位置相同，就比较长度，对于完全相同的子串，细节留给读者思考 1234567891011121314for(int i = 1; i &lt;= n/2; ++i) for(int j = 1; j+i &lt;= n; j += i) &#123; if(s[j] != s[j+i]) continue; int lcp = LCP(j, j+i); int curr = lcp/i+1, exl = j-(i-lcp%i), curl = j, cnt = 0; for(int k = j-1; k &gt; j-i&amp;&amp;k&amp;&amp;s[k] == s[i+k]; --k) &#123; if(exl == k) ++curr, curl = k; else curl = rak[k]&lt; rak[curl]?k:curl; // 时刻更新首字符 &#125; if(curr &gt; maxr) maxr = curr, len = i, p = curl; else if(curr == maxr &amp;&amp; rak[curl] &lt; rak[p]) maxr = curr, len = i, p = curl; // 按照长度枚举rank相同先枚举的字典序大 &#125; POJ2274 Long Long Message题面描述求两个字符串的最长公共子串 题解两个字符串的最长公共子串必定是两个字符串任意两个后缀的最长公共前缀，我们把两个字符串拼在一起，从中取满足sa[i-1] 和 sa[i] 分别属于两个字符串的height的最大值 123for(int i = 2; i &lt;= n; ++i) if((sa[i] &lt; p &amp;&amp; sa[i-1] &gt; p) || (sa[i] &gt; p&amp;&amp;sa[i-1] &lt; p)) ans = max(ans, height[i]); 之后会更改判断子串位置的写法 POJ3415 Common Substrings题面描述求两个字符串长度不小于 k 的公共子串的个数（可以相同） 题解好题 ヾ(≧▽≦*)o 那一刻我仿佛会了单调栈 题意可以转化为，我们定义 $$A(i,\ k)$$ 表示字符串A从第i个位置开始长度为k的子串 定义集合 $$S = {(i,\ j,\ k)\ |\ K \le k,\ A(i,\ k) = B(j,\ k) }$$ 代表公共子串集合，题目实际上就是求$|S|$ 那么 $$|S|\ = \sum_{i=1}\sum_{j=1}\sum_{k=1}[A(i,\ k)==B(j,\ k)][K \le k]$$ $$=\sum_{i=1}\sum_{j=1}LCP(i,\ j)-K+1[K \le k]\ $$ 所以，我们把两个字符串拼在一起，按照$height$分组，先考虑枚举A的子串S，求出字典序比S小的B的子串$LCP-K+1$的总和，然后在反过来枚举B的子串，相当于把大于A的子串字典序的贡献计算一遍，就得到了$|S|$ 相当于对于枚举A的位置i来说它的贡献为 $$\sum_{j&lt;i}\min_{k=j}^{i}(height_k)-K+1[sa[j-1]\in B]\ [sa[i] \in A]$$ 很显然 $\min_{k=j}^{i}(height_k)$ 具有单调性，对于$j’$&lt;$j$，就有 $\min_{k=j}^{i}(height_k)\le\min_{k=j’}^{i}(height_k)$，并且当$i\ \rightarrow i+1$时，决策集合靠后的可能会变小 所以，我们可以用一个单调栈维护$height$和$cnt$，当一个新的决策入栈后，把若$height_{top} \ge height_i$弹出栈顶，并更新具有相同$height$的$cnt$ 具体来说 1234567891011121314int top = 0; // 枚举B，计算All sum = 0;for(int i = 1; i &lt;= n; ++i)&#123; if(height[i] &lt; len) &#123; sum = top = 0; continue; &#125; // 和之前分组不同的是height是主要决策，当这一个height不满足时直接跳过 int cnt = 0; if(bel[sa[i-1]] == 1) ++cnt, sum += height[i]-len+1; // 假如是上一个后缀是Aheight更新贡献 while(top&amp;&amp;stak[top][0] &gt;= height[i]) sum -= stak[top][1]*(stak[top][0]-height[i]), cnt += stak[top][1], --top; // 维护单调性 stak[++top][0] = height[i]; stak[top][1] = cnt; if(bel[sa[i]] == 2) ans += sum; // 如果是B串累计贡献&#125; POJ3294 Life Forms题面描述求不小于k个字符串中的最长子串 题解把字符串拼在一起，中间用特殊字符隔开 123456for(int k = 1; k &lt;= tot; ++k)&#123; scanf("%s", inps+1); for(int i = 1; inps[i]; ++i) s[++n] = inps[i], bel[n] = k; s[++n] = (++spc)+S; bel[n] = k;&#125; 这是合并字符串的最终版本，s是int类型的，S是字符集大小 二分长度，判断每组内是否有k个不同的字符串 123456789101112bool valid(int k)&#123; int t = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(height[i] &lt; k) for(int j = 1; j &lt;= tot; ++j) t = cnt[j] = 0; int x = bel[sa[i]]; if(x &amp;&amp; ++cnt[x] == 1) ++t; if(t &gt;= tot/2+1) return true; &#125; return false;&#125; 再把满足条件的最大长度，来统计字符串 12345678910111213int getAns(int k)&#123; if(!k) return 0; int t = 0, ta = 0, tag = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(height[i] &lt; k) for(int j = 1; j &lt;= tot; ++j) tag = t = cnt[j] = 0; int x = bel[sa[i]]; if(x &amp;&amp; ++cnt[x] == 1) ++t; if(t == tot/2+1 &amp;&amp; !tag) ans[++ta] = sa[i], tag = 1; &#125; return ta;&#125; 输出格式有锅 ㄟ( ▔, ▔ )ㄏ SP220 PHRASES - Relevant Phrases of Annihilation题面描述求每个字符串至少出现两次且不重叠的最长子串 题解前面几道题的综合，拼在一起，二分，统计每组不同串的个数，用相同串的$sa_{max}-sa_{min}$是否大于二分值即可 123456789101112131415161718192021bool valid(int k)&#123; for(int x = 1; x &lt;= tot; ++x) cnt[x] = 0, maxv[x] = -1, minv[x] = n; for(int i = 1; i &lt;= n; ++i) &#123; if(height[i] &lt; k) &#123; bool cor = true; for(int x = 1; x &lt;= tot &amp;&amp; cor; ++x) if(cnt[x] &lt; 2) cor = false; else if(maxv[x]-minv[x] &lt; k) cor = false; if(cor) return true; for(int x = 1; x &lt;= tot; ++x) cnt[x] = 0, maxv[x] = -1, minv[x] = n; &#125; int x = bel[sa[i]]; ++cnt[x]; maxv[x] = max(maxv[x], sa[i]); minv[x] = min(minv[x], sa[i]); &#125; return false;&#125; POJ1226 Substrings题面描述求出现或反转后出现在每个字符串中的最长子串 题解正串反串拼一块，所有串拼一块，二分即可 拼串 123456789for(int k = 1; k &lt;= tot; ++k)&#123; scanf("%s", inps+1); int strl = strlen(inps+1); for(int i = 1; i &lt;= strl; ++i) s[++n] = inps[i], bel[n] = k; s[++n] = (++spc)+128; bel[n] = k; for(int i = strl; i; --i) s[++n] = inps[i], bel[n] = k; s[++n] = (++spc)+128; bel[n] = k;&#125; 完结散花ヾ(•ω•`)o SA真是人类的智慧 可是蒟蒻还是不会字符串啊 参考论文 后缀数组——处理字符串的有力工具]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>后缀数组</tag>
        <tag>差分</tag>
      </tags>
  </entry>
</search>
